[{"uri":"//fsharp.github.io/FSharp.Compiler.Service/devnotes.html","title":"Developer Notes","content":"\nDeveloper notes\n===============\n\nModified clone of F# compiler exposing additional functionality for editing clients and embedding F# compiler\nand F# interactive as services.\n\n## Components\n\nThere is one main component, `FSharp.Compiler.Service.dll`.\nThe main aim is to have a stable and documented fork of the main compiler that allows various\ntools to share this common code.\nThis component allows embedding F# Interactive as a service and contains a number of\nmodifications to the source code of `fsi.exe` that adds `EvalExpression` and `EvalInteraction` functions.\n\nThis repo should be _identical_ to 'fsharp' except:\n\n  - Changes for building `FSharp.Compiler.Service.dll`, notably\n    - Change the assembly name\n    - Only build `FSharp.Compiler.Service.dll`\n    - No bootstrap or proto compiler is used - an installed F# compiler is assumed\n\n  - Build script using FAKE that builds everything, produces NuGet package and\n    generates documentation, files for publishing NuGet packages etc.\n    (following [F# project scaffold](https://github.com/fsprojects/FSharp.ProjectScaffold))\n\n  - Changes to compiler source code to expose new functionality; Changes to the\n    F# Interactive service to implement the evaluation functions.\n\n  - Additions to compiler source code which improve the API for the use of F# editing clients\n\n  - Additions to compiler source code which add new functionality to the compiler service API\n\nIf language or compiler additions are committed to `fsharp/fsharp`, they should be merged into\nthis repo and a new NuGet package released.\n\n## Building and NuGet\n\nThe build process follows the standard recommended by [F# project scaffold](https://github.com/fsprojects/FSharp.ProjectScaffold)\nIf you want to build the project yourself then you can follow these instructions:\n\n    [lang=text]\n    git clone https://github.com/fsharp/FSharp.Compiler.Service\n    cd FSharp.Compiler.Service\n\nNow follow build everything by running `build.cmd` (Windows) or `build.sh` (Linux + Mac OS).\nThe output will be located in the `bin` directory. If you also wish to build the documentation\nand NuGet package, run `build Release` (this also attempts to publish the documentation to\nGitHub, which only works if you have access to the GitHub repository).\n\n## Release checklist\n\nRelease checklist to publish a new version on nuget.org\n\n1. Update `RELEASE_NOTES.md`\n2. Check the version numbers are correct across the source (some files duplicate them)\n3. Commit and add the necessary tag to the repo\n4. Publish the nupkgs for `FSharp.Compiler.Service` once it appears in AppVeyor artifacts\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/index.html","title":"F# Compiler Services","content":"\nF# Compiler Services\n====================\n\nThe F# compiler services package is a component derived from the F# compiler source code that\nexposes additional functionality for implementing F# language bindings, additional\ntools based on the compiler or refactoring tools. The package also includes F#\ninteractive service that can be used for embedding F# scripting into your applications.\n\n<div class=\"row\">\n  <div class=\"span1\"></div>\n  <div class=\"span6\">\n    <div class=\"well well-small\" id=\"nuget\">\n      The F# Compiler Services package can be <a href=\"https://nuget.org/packages/FSharp.Compiler.Service\">installed from NuGet</a>:\n      <pre>PM> Install-Package FSharp.Compiler.Service</pre>\n    </div>\n  </div>\n  <div class=\"span1\"></div>\n</div>\n\nAvailable services\n------------------\n\nThe project currently exposes the following services that are tested & documented on this page.\nThe libraries contain additional public API that can be used, but is not documented here.\n\n* [**F# Language tokenizer**](tokenizer.html) - turns any F# source code into a stream of tokens.\n  Useful for implementing source code colorization and basic tools. Correctly handle nested\n  comments, strings etc.\n\n* [**Processing untyped AST**](untypedtree.html) - allows accessing the untyped abstract syntax tree (AST).\n  This represents parsed F# syntax without type information and can be used to implement code formatting\n  and various simple processing tasks.\n\n* [**Using editor (IDE) services**](editor.html) - expose functionality for auto-completion, tool-tips,\n  parameter information etc. These functions are useful for implementing F# support for editors\n  and for getting some type information for F# code.\n\n* [**Working with signatures, types, and resolved symbols**](symbols.html) - many services related to type checking\n  return resolved symbols, representing inferred types, and the signatures of whole assemblies.\n\n* [**Working with resolved expressions**](typedtree.html) - services related to working with\n  type-checked expressions and declarations, where names have been resolved to symbols.\n\n* [**Working with projects and project-wide analysis**](project.html) - you can request a check of\n  an entire project, and ask for the results of whole-project analyses such as find-all-references.\n\n* [**Hosting F# interactive**](interactive.html) - allows calling F# interactive as a .NET library\n  from your .NET code. You can use this API to embed F# as a scripting language in your projects.\n\n* [**Hosting the F# compiler**](compiler.html) - allows you to embed calls to the F# compiler.\n\n* [**File system API**](filesystem.html) - the `FSharp.Compiler.Service` component has a global variable\n  representing the file system. By setting this variable you can host the compiler in situations where a file system\n  is not available.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\nProjects using the F# Compiler Services\n------------------\n\nSome of the projects using the F# Compiler Services are:\n\n* [**The Visual F# Power Tools**](https://fsprojects.github.io/VisualFSharpPowerTools/)\n* [**The Xamarin and MonoDevelop Tools for F#**](https://github.com/mono/monodevelop/tree/master/main/external/fsharpbinding)\n* [**The Emacs Plugin for F#**](https://github.com/fsharp/emacs-fsharp-mode)\n* [**The Vim Plugin for F#**](https://github.com/fsharp/vim-fsharp)\n* [**F# language support for JetBrains Rider**](https://github.com/JetBrains/fsharp-support/)\n* [**iFSharp**](https://github.com/BayardRock/IfSharp)  - iPython-style notebook engine for F#\n* [**CloudSharper**](https://cloudsharper.com/) - Online web and mobile programming with big data and charting\n* [**Tsunami**](http://tsunami.io) - Tsunami enhances applications and workflows with the power of Type Safe Scripting\n* [**FQuake3**](https://github.com/TIHan/FQuake3/)  - integrates F# as an interactive game scripting engine\n* [**FCell**](http://fcell.io) - Deliver the power of .NET from within Microsoft Excel\n* [**FSharpLint**](https://fsprojects.github.io/FSharpLint/) - Lint tool for F#\n* [**FsReveal**](https://fsprojects.github.io/FsReveal/) - FsReveal parses markdown and F# script file and generate reveal.js slides\n* [**Elucidate**](https://github.com/rookboom/Elucidate) - Visual Studio extension for rich inlined comments using MarkDown\n* [**Fable**](https://fable-compiler.github.io/) - F# to JavaScript Compiler\n* [**FSharp.Formatting**](http://tpetricek.github.io/FSharp.Formatting/) - F# tools for generating documentation (Markdown processor and F# code formatter)\n* [**FAKE**](https://fsharp.github.io/FAKE/) - \"FAKE - F# Make\" is a cross platform build automation system\n* [**FsLab Journal**](https://visualstudiogallery.msdn.microsoft.com/45373b36-2a4c-4b6a-b427-93c7a8effddb) - Template that makes it easy to do interactive data analysis using F# Interactive and produce nice HTML reports of your work\n* [**FarNet.FSharpFar**](https://github.com/nightroman/FarNet/tree/master/FSharpFar) - F# scripting and interactive services in Far Manager\n\nContributing and copyright\n--------------------------\n\nThis project is a fork of the [fsharp/fsharp](https://github.com/fsharp/fsharp) which has been\nmodified to expose additional internals useful for creating editors and F# tools and also for\nembedding F# interactive.\n\nThe F# source code is copyright by Microsoft Corporation and contributors, the extensions have been\nimplemented by Dave Thomas, Anh-Dung Phan, Tomas Petricek and other contributors.\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/devnotes.html","title":"開発者用メモ","content":"\n\n開発者用メモ\n============\n\nF#コンパイラの修正版クローンではクライアントの編集機能やF#コンパイラの埋め込み、\nF# Interactiveをサービスとして動作させるための機能が追加されています。\n\n## コンポーネント\n\nまず `FSharp.Compiler.Service.dll` というコンポーネントがあります。\nこのコンポーネントにはリファクタリングやその他の編集ツールが完全なF# ASTやパーサ機能を利用できるように\n可視性を変更するというマイナーな変更だけが加えられています。\n主な狙いとしては、メインコンパイラの安定版かつドキュメントが備えられたフォークを用意することにより、\nこのコンポーネントにある共通コードを様々なツールで共有できるようにすることです。\n\n2つ目のコンポーネントはF# Interactiveをサービスとして組み込めるようにするためのもので、\n`fsi.exe` のソースコードに多数の変更が加えられており、\n`EvalExpression` や `EvalInteraction` といった関数が追加されています。\n\nこのレポジトリは以下の点を除けば 'fsharp' と **同一** です:\n\n  - `FSharp.Compiler.Service.dll` のビルド、特に以下の点に関する変更:\n    - アセンブリ名の変更\n    - `FSharp.Compiler.Service.dll` のみビルドされる\n    - ブートストラッパーやプロトコンパイラを使用しない。\n      F#コンパイラがインストール済みであることを想定。\n\n  - FAKEを使用するビルドスクリプト。\n    すべてのコードのビルドとNuGetパッケージ、ドキュメントの生成、\n    NuGetパッケージの配布に必要なファイルの生成などがFAKEによって行われる。\n    ([F# プロジェクト スキャフォールド](https://github.com/fsprojects/FSharp.ProjectScaffold) に準拠)\n\n  - 新機能追加のためにコンパイラのソースコードを変更。\n    また、評価用関数を実装するためにF# Interactiveサービスに対する変更を追加。\n\n  - F#編集用クライアントで使用されるAPIを改善するためにコンパイラのソースコードを変更。\n\n  - コンパイラサービスAPIに新機能を追加するためにコンパイラのソースコードを変更。\n\n`fsharp/fsharp` のレポジトリに言語あるいはコンパイラが追加コミットされた場合、\nそれらはこのレポジトリにもマージされるべきで、同時に新しいNuGetパッケージもリリースする必要があります。\n\n## ビルドとNuGet\n\nビルドの手順は [F# プロジェクト スキャフォールド](https://github.com/fsprojects/FSharp.ProjectScaffold)\nで推奨されているものに準じます。\nプロジェクトを独自にビルドする場合、以下の手順に従ってください:\n\n    [lang=text]\n    git clone https://github.com/fsharp/FSharp.Compiler.Service\n    cd FSharp.Compiler.Service\n\n次に、(Windowsであれば) `build.cmd` または(LinuxやMac OSであれば) `build.sh` を実行してすべてをビルドします。\nファイルは `bin` ディレクトリ内に出力されます。\nドキュメントやNuGetパッケージもビルドしたい場合には `build Release` を実行します\n(このコマンドはGitHub上のドキュメントを更新しようとしますが、GitHubのレポジトリに適切な権限を持っている場合にのみ有効です)。\n\n## クライアント\n\nこのコンポーネントは以下のようなツールで使用されています:\n\n * [Fantomas](https://github.com/dungpa/fantomas) - F# コードフォーマットツール\n * [Fsharp-Refactor](https://github.com/Lewix/fsharp-refactor) - F#用リファクタリングツール\n * [FSharpbinding](https://github.com/fsharp/fsharpbinding) - Xamarin Studio バインディング\n * [F# Snippets web site](http://fssnip.net/) - F# 版のpastebin\n * [F# ACE Code Editor](https://github.com/BayardRock/FSharpWebIntellisense/) - Web上のF#編集ツール\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/index.html","title":"F# コンパイラサービス","content":"\nF# コンパイラサービス\n=====================\n\nF# コンパイラサービスパッケージはF# コンパイラのソースコードから派生したコンポーネントです。\nこのソースコードにはF# 言語バインディングを実装するための機能や、\nコンパイラやリファクタリングツールを元にしたツールを作成するための機能が追加されています。\nまた、パッケージには自身のアプリケーションにF# スクリプトを埋め込む際に利用できるような\nF# インタラクティブサービスも含まれています。\n\n<div class=\"row\">\n  <div class=\"span1\"></div>\n  <div class=\"span6\">\n    <div class=\"well well-small\" id=\"nuget\">\n      F# コンパイラサービスパッケージは <a href=\"https://nuget.org/packages/FSharp.Compiler.Service\">NuGet経由でインストールできます</a>:\n      <pre>PM> Install-Package FSharp.Compiler.Service</pre>\n    </div>\n  </div>\n  <div class=\"span1\"></div>\n</div>\n\n利用可能なサービス\n------------------\n\nプロジェクトには現在以下のサービスがあり、いずれもテストされ、\nこのページから参照可能なドキュメントがあります。\nライブラリには他にも使用可能な公開APIがありますが、\nここではドキュメント化されていません。\n\n * [** F# 言語トークナイザ **](tokenizer.html) - F#ソースコードをトークンのストリームへと変換します。\n   この機能はソースコードを色つき表示したり、基本的なツールを作成するような場合に有効です。\n   ネストされたコメントや文字列なども適切に処理できます。\n\n * [** 型無しASTの処理 **](untypedtree.html) - この機能を使うことで型無し抽象構文木(AST: abstract syntax tree)にアクセスできます。\n   型無しASTとは型情報を含まない解析済みのF#の文法を表すもので、\n   コードフォーマットやその他様々な単純処理に利用できます。\n\n * [** エディタ (IDE) サービスの使用 **](editor.html) - 自動補完やツールチップ、\n   引数の情報などを表示するための機能があります。\n   この機能を使うと、F#サポート機能をエディタに追加したり、F#コードから\n   何らかの型情報を取得したりすることができるようになります。\n\n * [** シグネチャや型、解決済みのシンボルの処理 **](symbols.html) -\n   解決済みのシンボルや推測された型の表現、アセンブリ全体のシグネチャなどを\n   型のチェック時に返すような多数のサービスがあります。\n\n * [** 複数プロジェクトやプロジェクト全体の処理 **](project.html) -\n   すべてのプロジェクトに対するチェックを実行することにより、\n   プロジェクト全体の解析結果を使って\\[すべての参照の検索\\] のような\n   機能を実現できます。\n\n * [** F# Interactive のホスティング **](interactive.html) - 自身の.NETコードから\n   F# Interactiveを.NETライブラリとして呼び出すことができるようになります。\n   このAPIを使用すると、自身のプロジェクト内でF#をスクリプト言語として\n   埋め込むことができるようになります。\n\n * [** F#コンパイラのホスティング **](compiler.html) - F# コンパイラを\n   呼び出すコードを組み込むことができます。\n\n * [** ファイルシステムAPI **](filesystem.html) - `FSharp.Compiler.Service` コンポーネントには\n   ファイルシステムを表すグローバル変数が定義されています。\n   この変数を設定することによって、ファイルシステムが使用できない状況であっても\n   コンパイラをホストすることができるようになります。\n\n> **注釈:** FSharp.Compiler.Service.dll には既存のものと重複する機能が多数あるため、\n  将来的にはもっときちんとした形に変更されます。\n  そのため、これらのサービスを使用するAPIには破壊的変更が加えられる可能性があります。\n\n貢献および著作権について\n------------------------\n\nこのプロジェクトは [fsharp/fsharp](https://github.com/fsharp/fsharp) からフォークしたもので、\nそこへさらにエディタやF#用ツール、F# Interactiveの組み込みに必要となる機能を\n追加したものです。\n\nF# ソースコードの著作権はMicrosoft Corporationおよび貢献者に、\n拡張機能の著作権は Dave Thomas, Anh-Dung Phan, Tomas Petricek および\nその他の貢献者にあります。\nソースコードは [MIT ライセンス](https://github.com/fsharp/FSharp.Compiler.Service/blob/master/LICENSE) の元に公開されています。\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/typedtree.html","title":"Processing typed expression tree","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Processing typed expression tree\n=================================================\n\nThis tutorial demonstrates how to get the checked, typed expressions tree (TAST)\nfor F# code and how to walk over the tree.\n\nThis can be used for creating tools such as source code analyzers and refactoring tools.\nYou can also combine the information with the API available\nfrom [symbols](symbols.html).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nGetting checked expressions\n-----------------------\n\nTo access the type-checked, resolved expressions, you need to create an instance of `InteractiveChecker`.\n\nTo use the interactive checker, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n(**\n\n### Checking code\n\nWe first parse and check some code as in the [symbols](symbols.html) tutorial.\nOne difference is that we set keepAssemblyContents to true.\n\n*)\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create(keepAssemblyContents=true)\n\nlet parseAndCheckSingleFile (input) =\n    let file = Path.ChangeExtension(System.IO.Path.GetTempFileName(), \"fsx\")\n    File.WriteAllText(file, input)\n    // Get context representing a stand-alone (script) file\n    let projOptions, _errors =\n        checker.GetProjectOptionsFromScript(file, SourceText.ofString input)\n        |> Async.RunSynchronously\n\n    let fprojOptions = projOptions\n\n    checker.ParseAndCheckProject (fprojOptions)\n    |> Async.RunSynchronously\n\n(**\n## Getting the expressions\n\nAfter type checking a file, you can access the declarations and contents of the assembly, including expressions:\n\n*)\n\nlet input2 =\n      \"\"\"\nmodule MyLibrary\n\nopen System\n\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\", \" \", \"world\")\n    if msg.Length > 10 then\n        10\n    else\n        20\n\ntype MyClass() =\n    member x.MyMethod() = 1\n      \"\"\"\nlet checkProjectResults =\n    parseAndCheckSingleFile(input2)\n\ncheckProjectResults.Errors // should be empty\n\n\n(**\n\nChecked assemblies are made up of a series of checked implementation files.  The \"file\" granularity\nmatters in F# because initialization actions are triggered at the granularity of files.\nIn this case there is only one implementation file in the project:\n\n*)\n\nlet checkedFile = checkProjectResults.AssemblyContents.ImplementationFiles.[0]\n\n(**\n\nChecked assemblies are made up of a series of checked implementation files.  The \"file\" granularity\nmatters in F# because initialization actions are triggered at the granularity of files.\nIn this case there is only one implementation file in the project:\n\n*)\n\nlet rec printDecl prefix d =\n    match d with\n    | FSharpImplementationFileDeclaration.Entity (e, subDecls) ->\n        printfn \"%sEntity %s was declared and contains %d sub-declarations\" prefix e.CompiledName subDecls.Length\n        for subDecl in subDecls do\n            printDecl (prefix+\"    \") subDecl\n    | FSharpImplementationFileDeclaration.MemberOrFunctionOrValue(v, vs, e) ->\n        printfn \"%sMember or value %s was declared\" prefix  v.CompiledName\n    | FSharpImplementationFileDeclaration.InitAction(e) ->\n        printfn \"%sA top-level expression was declared\" prefix\n\n\nfor d in checkedFile.Declarations do\n   printDecl \"\" d\n\n// Entity MyLibrary was declared and contains 4 sub-declarations\n//     Member or value foo was declared\n//     Entity MyClass was declared and contains 0 sub-declarations\n//     Member or value .ctor was declared\n//     Member or value MyMethod was declared\n\n(**\n\nAs can be seen, the only declaration in the implementation file is that of the module MyLibrary, which\ncontains fours sub-declarations.\n\n> As an aside, one peculiarity here is that the member declarations (e.g. the \"MyMethod\" member) are returned as part of the containing module entity, not as part of their class.\n\n> Note that the class constructor is returned as a separate declaration. The class type definition has been \"split\" into a constructor and the other declarations.\n\n*)\n\nlet myLibraryEntity, myLibraryDecls =\n   match checkedFile.Declarations.[0] with\n   | FSharpImplementationFileDeclaration.Entity (e, subDecls) -> (e, subDecls)\n   | _ -> failwith \"unexpected\"\n\n\n(**\n\nWhat about the expressions, for example the body of function \"foo\"? Let's find it:\n*)\n\nlet (fooSymbol, fooArgs, fooExpression) =\n    match myLibraryDecls.[0] with\n    | FSharpImplementationFileDeclaration.MemberOrFunctionOrValue(v, vs, e) -> (v, vs, e)\n    | _ -> failwith \"unexpected\"\n\n\n(** Here 'fooSymbol' is a symbol associated with the declaration of 'foo',\n'fooArgs' represents the formal arguments to the 'foo' function, and 'fooExpression'\nis an expression for the implementation of the 'foo' function.\n\nOnce you have an expression, you can work with it much like an F# quotation.  For example,\nyou can find its declaration range and its type:\n\n*)\n\nfooExpression.Type  // shows that the return type of the body expression is 'int'\nfooExpression.Range  // shows the declaration range of the expression implementing 'foo'\n\n(**\n\n### Walking over expressions\n\n\nExpressions are analyzed using active patterns, much like F# quotations.\nHere is a generic expression visitor:\n\n*)\n\nlet rec visitExpr f (e:FSharpExpr) =\n    f e\n    match e with\n    | BasicPatterns.AddressOf(lvalueExpr) ->\n        visitExpr f lvalueExpr\n    | BasicPatterns.AddressSet(lvalueExpr, rvalueExpr) ->\n        visitExpr f lvalueExpr; visitExpr f rvalueExpr\n    | BasicPatterns.Application(funcExpr, typeArgs, argExprs) ->\n        visitExpr f funcExpr; visitExprs f argExprs\n    | BasicPatterns.Call(objExprOpt, memberOrFunc, typeArgs1, typeArgs2, argExprs) ->\n        visitObjArg f objExprOpt; visitExprs f argExprs\n    | BasicPatterns.Coerce(targetType, inpExpr) ->\n        visitExpr f inpExpr\n    | BasicPatterns.FastIntegerForLoop(startExpr, limitExpr, consumeExpr, isUp) ->\n        visitExpr f startExpr; visitExpr f limitExpr; visitExpr f consumeExpr\n    | BasicPatterns.ILAsm(asmCode, typeArgs, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.ILFieldGet (objExprOpt, fieldType, fieldName) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.ILFieldSet (objExprOpt, fieldType, fieldName, valueExpr) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.IfThenElse (guardExpr, thenExpr, elseExpr) ->\n        visitExpr f guardExpr; visitExpr f thenExpr; visitExpr f elseExpr\n    | BasicPatterns.Lambda(lambdaVar, bodyExpr) ->\n        visitExpr f bodyExpr\n    | BasicPatterns.Let((bindingVar, bindingExpr), bodyExpr) ->\n        visitExpr f bindingExpr; visitExpr f bodyExpr\n    | BasicPatterns.LetRec(recursiveBindings, bodyExpr) ->\n        List.iter (snd >> visitExpr f) recursiveBindings; visitExpr f bodyExpr\n    | BasicPatterns.NewArray(arrayType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewDelegate(delegateType, delegateBodyExpr) ->\n        visitExpr f delegateBodyExpr\n    | BasicPatterns.NewObject(objType, typeArgs, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewRecord(recordType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewAnonRecord(recordType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewTuple(tupleType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewUnionCase(unionType, unionCase, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.Quote(quotedExpr) ->\n        visitExpr f quotedExpr\n    | BasicPatterns.FSharpFieldGet(objExprOpt, recordOrClassType, fieldInfo) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.AnonRecordGet(objExpr, recordOrClassType, fieldInfo) ->\n        visitExpr f objExpr\n    | BasicPatterns.FSharpFieldSet(objExprOpt, recordOrClassType, fieldInfo, argExpr) ->\n        visitObjArg f objExprOpt; visitExpr f argExpr\n    | BasicPatterns.Sequential(firstExpr, secondExpr) ->\n        visitExpr f firstExpr; visitExpr f secondExpr\n    | BasicPatterns.TryFinally(bodyExpr, finalizeExpr) ->\n        visitExpr f bodyExpr; visitExpr f finalizeExpr\n    | BasicPatterns.TryWith(bodyExpr, _, _, catchVar, catchExpr) ->\n        visitExpr f bodyExpr; visitExpr f catchExpr\n    | BasicPatterns.TupleGet(tupleType, tupleElemIndex, tupleExpr) ->\n        visitExpr f tupleExpr\n    | BasicPatterns.DecisionTree(decisionExpr, decisionTargets) ->\n        visitExpr f decisionExpr; List.iter (snd >> visitExpr f) decisionTargets\n    | BasicPatterns.DecisionTreeSuccess (decisionTargetIdx, decisionTargetExprs) ->\n        visitExprs f decisionTargetExprs\n    | BasicPatterns.TypeLambda(genericParam, bodyExpr) ->\n        visitExpr f bodyExpr\n    | BasicPatterns.TypeTest(ty, inpExpr) ->\n        visitExpr f inpExpr\n    | BasicPatterns.UnionCaseSet(unionExpr, unionType, unionCase, unionCaseField, valueExpr) ->\n        visitExpr f unionExpr; visitExpr f valueExpr\n    | BasicPatterns.UnionCaseGet(unionExpr, unionType, unionCase, unionCaseField) ->\n        visitExpr f unionExpr\n    | BasicPatterns.UnionCaseTest(unionExpr, unionType, unionCase) ->\n        visitExpr f unionExpr\n    | BasicPatterns.UnionCaseTag(unionExpr, unionType) ->\n        visitExpr f unionExpr\n    | BasicPatterns.ObjectExpr(objType, baseCallExpr, overrides, interfaceImplementations) ->\n        visitExpr f baseCallExpr\n        List.iter (visitObjMember f) overrides\n        List.iter (snd >> List.iter (visitObjMember f)) interfaceImplementations\n    | BasicPatterns.TraitCall(sourceTypes, traitName, typeArgs, typeInstantiation, argTypes, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.ValueSet(valToSet, valueExpr) ->\n        visitExpr f valueExpr\n    | BasicPatterns.WhileLoop(guardExpr, bodyExpr) ->\n        visitExpr f guardExpr; visitExpr f bodyExpr\n    | BasicPatterns.BaseValue baseType -> ()\n    | BasicPatterns.DefaultValue defaultType -> ()\n    | BasicPatterns.ThisValue thisType -> ()\n    | BasicPatterns.Const(constValueObj, constType) -> ()\n    | BasicPatterns.Value(valueToGet) -> ()\n    | _ -> failwith (sprintf \"unrecognized %+A\" e)\n\nand visitExprs f exprs =\n    List.iter (visitExpr f) exprs\n\nand visitObjArg f objOpt =\n    Option.iter (visitExpr f) objOpt\n\nand visitObjMember f memb =\n    visitExpr f memb.Body\n\n(**\nLet's use this expresssion walker:\n\n*)\nfooExpression |> visitExpr (fun e -> printfn \"Visiting %A\" e)\n\n// Prints:\n//\n// Visiting Let...\n// Visiting Call...\n// Visiting Const (\"Hello\", ...)\n// Visiting Const (\" \", ...)\n// Visiting Const (\"world\", ...)\n// Visiting IfThenElse...\n// Visiting Call...\n// Visiting Call...\n// Visiting Value ...\n// Visiting Const ...\n// Visiting Const ...\n// Visiting Const ...\n\n(**\nNote that\n\n* The visitExpr function is recursive (for nested expressions).\n\n* Pattern matching is removed from the tree, into a form called 'decision trees'.\n\nSummary\n-------\nIn this tutorial, we looked at basic of working with checked declarations and expressions.\n\nIn practice, it is also useful to combine the information here\nwith some information you can obtain from the [symbols](symbols.html)\ntutorial.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/filesystem.html","title":"Virtualized File System","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Virtualized File System\n==========================================\n\nThe `FSharp.Compiler.Service` component has a global variable\nrepresenting the file system. By setting this variable you can host the compiler in situations where a file system\nis not available.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\n\nSetting the FileSystem\n----------------------\n\nIn the example below, we set the file system to an implementation which reads from disk\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen System.Collections.Generic\nopen System.Text\nopen FSharp.Compiler.AbstractIL.Internal.Library\n\nlet defaultFileSystem = Shim.FileSystem\n\nlet fileName1 = @\"c:\\mycode\\test1.fs\" // note, the path doesn't exist\nlet fileName2 = @\"c:\\mycode\\test2.fs\" // note, the path doesn't exist\n\ntype MyFileSystem() =\n    let file1 = \"\"\"\nmodule File1\n\nlet A = 1\"\"\"\n    let file2 = \"\"\"\nmodule File2\nlet B = File1.A + File1.A\"\"\"\n    let files = dict [(fileName1, file1); (fileName2, file2)]\n\n    interface IFileSystem with\n        // Implement the service to open files for reading and writing\n        member __.FileStreamReadShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> new MemoryStream(Encoding.UTF8.GetBytes(text)) :> Stream\n            | _ -> defaultFileSystem.FileStreamReadShim(fileName)\n\n        member __.FileStreamCreateShim(fileName) =\n            defaultFileSystem.FileStreamCreateShim(fileName)\n\n        member __.FileStreamWriteExistingShim(fileName) =\n            defaultFileSystem.FileStreamWriteExistingShim(fileName)\n\n        member __.ReadAllBytesShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> Encoding.UTF8.GetBytes(text)\n            | _ -> defaultFileSystem.ReadAllBytesShim(fileName)\n\n        // Implement the service related to temporary paths and file time stamps\n        member __.GetTempPathShim() =\n            defaultFileSystem.GetTempPathShim()\n\n        member __.GetLastWriteTimeShim(fileName) =\n            defaultFileSystem.GetLastWriteTimeShim(fileName)\n\n        member __.GetFullPathShim(fileName) =\n            defaultFileSystem.GetFullPathShim(fileName)\n\n        member __.IsInvalidPathShim(fileName) =\n            defaultFileSystem.IsInvalidPathShim(fileName)\n\n        member __.IsPathRootedShim(fileName) =\n            defaultFileSystem.IsPathRootedShim(fileName)\n\n        member __.IsStableFileHeuristic(fileName) =\n            defaultFileSystem.IsStableFileHeuristic(fileName)\n\n        // Implement the service related to file existence and deletion\n        member __.SafeExists(fileName) =\n            files.ContainsKey(fileName) || defaultFileSystem.SafeExists(fileName)\n\n        member __.FileDelete(fileName) =\n            defaultFileSystem.FileDelete(fileName)\n\n        // Implement the service related to assembly loading, used to load type providers\n        // and for F# interactive.\n        member __.AssemblyLoadFrom(fileName) =\n            defaultFileSystem.AssemblyLoadFrom fileName\n\n        member __.AssemblyLoad(assemblyName) =\n            defaultFileSystem.AssemblyLoad assemblyName\n\nlet myFileSystem = MyFileSystem()\nShim.FileSystem <- MyFileSystem()\n\n(**\n\nDoing a compilation with the FileSystem\n---------------------------------------\n\n*)\nopen FSharp.Compiler.SourceCodeServices\n\nlet checker = FSharpChecker.Create()\n\nlet projectOptions =\n    let sysLib nm =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\\" + nm + \".dll\"\n        else\n            let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n            let (++) a b = System.IO.Path.Combine(a,b)\n            sysDir ++ nm + \".dll\"\n\n    let fsCore4300() =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"\n        else\n            sysLib \"FSharp.Core\"\n\n    let allFlags =\n        [| yield \"--simpleresolution\";\n           yield \"--noframework\";\n           yield \"--debug:full\";\n           yield \"--define:DEBUG\";\n           yield \"--optimize-\";\n           yield \"--doc:test.xml\";\n           yield \"--warn:3\";\n           yield \"--fullpaths\";\n           yield \"--flaterrors\";\n           yield \"--target:library\";\n           let references =\n             [ sysLib \"mscorlib\"\n               sysLib \"System\"\n               sysLib \"System.Core\"\n               fsCore4300() ]\n           for r in references do\n                 yield \"-r:\" + r |]\n\n    { ProjectFileName = @\"c:\\mycode\\compilation.fsproj\" // Make a name that is unique in this directory.\n      ProjectId = None\n      SourceFiles = [| fileName1; fileName2 |]\n      OriginalLoadReferences = []\n      ExtraProjectInfo=None\n      Stamp = None\n      OtherOptions = allFlags\n      ReferencedProjects = [| |]\n      IsIncompleteTypeCheckEnvironment = false\n      UseScriptResolutionRules = true\n      LoadTime = System.DateTime.Now // Note using 'Now' forces reloading\n      UnresolvedReferences = None }\n\nlet results = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\nresults.Errors\nresults.AssemblySignature.Entities.Count //2\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.Count //1\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"B\"\n\n(**\nSummary\n-------\nIn this tutorial, we've seen how to globally customize the view of the file system used by the FSharp.Compiler.Service\ncomponent.\n\nAt the time of writing, the following System.IO operations are not considered part of the virtualized file system API.\nFuture iterations on the compiler service implementation may add these to the API.\n\n  - Path.Combine\n  - Path.DirectorySeparatorChar\n  - Path.GetDirectoryName\n  - Path.GetFileName\n  - Path.GetFileNameWithoutExtension\n  - Path.HasExtension\n  - Path.GetRandomFileName (used only in generation compiled win32 resources in assemblies)\n\n**NOTE:** Several operations in the `SourceCodeServices` API accept the contents of a file to parse\nor check as a parameter, in addition to a file name. In these cases, the file name is only used for\nerror reporting.\n\n**NOTE:** Type provider components do not use the virtualized file system.\n\n**NOTE:** The compiler service may use MSBuild for assembly resolutions unless `--simpleresolution` is\nprovided. When using the `FileSystem` API you will normally want to specify `--simpleresolution` as one\nof your compiler flags. Also specify `--noframework`.  You will need to supply explicit resolutions of all\nreferenced .NET assemblies.\n\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/symbols.html","title":"Working with symbols","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Working with symbols\n============================================\n\nThis tutorial demonstrates how to work with symbols provided by the F# compiler. See also [project wide analysis](project.html)\nfor information on symbol references.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\nAs usual we start by referencing `FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `FSharpChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\n\nWe now perform type checking on the specified input:\n\n*)\n\nlet parseAndTypeCheckSingleFile (file, input) =\n    // Get context representing a stand-alone (script) file\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let parseFileResults, checkFileResults =\n        checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n        |> Async.RunSynchronously\n\n    // Wait until type checking succeeds (or 100 attempts)\n    match checkFileResults with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseFileResults, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet file = \"/home/user/Test.fsx\"\n\n(**\n## Getting resolved signature information about the file\n\nAfter type checking a file, you can access the inferred signature of a project up to and including the\nchecking of the given file through the `PartialAssemblySignature` property of the `TypeCheckResults`.\n\nThe full signature information is available for modules, types, attributes, members, values, functions,\nunion cases, record types, units of measure and other F# language constructs.\n\nThe typed expression trees are also available, see [typed tree tutorial](typedtree.html).\n\n*)\n\nlet input2 =\n      \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n        printfn \"x = %d, y = %d\" x y\n        printfn \"%s\" msg\n\ntype C() =\n    member x.P = 1\n      \"\"\"\nlet parseFileResults, checkFileResults =\n    parseAndTypeCheckSingleFile(file, SourceText.ofString input2)\n\n(**\nNow get the partial assembly signature for the code:\n*)\nlet partialAssemblySignature = checkFileResults.PartialAssemblySignature\n\npartialAssemblySignature.Entities.Count = 1  // one entity\n\n\n(**\nNow get the entity that corresponds to the module containing the code:\n*)\nlet moduleEntity = partialAssemblySignature.Entities.[0]\n\nmoduleEntity.DisplayName = \"Test\"\n\n(**\nNow get the entity that corresponds to the type definition in the code:\n*)\nlet classEntity = moduleEntity.NestedEntities.[0]\n\n(**\nNow get the value that corresponds to the function defined in the code:\n*)\nlet fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n(**\nNow look around at the properties describing the function value. All of the following evaluate to `true`:\n*)\nfnVal.Attributes.Count = 1\nfnVal.CurriedParameterGroups.Count // 1\nfnVal.CurriedParameterGroups.[0].Count // 2\nfnVal.CurriedParameterGroups.[0].[0].Name // \"x\"\nfnVal.CurriedParameterGroups.[0].[1].Name // \"y\"\nfnVal.DeclarationLocation.StartLine // 3\nfnVal.DisplayName // \"foo\"\nfnVal.DeclaringEntity.Value.DisplayName // \"Test\"\nfnVal.DeclaringEntity.Value.DeclarationLocation.StartLine // 1\nfnVal.GenericParameters.Count // 0\nfnVal.InlineAnnotation // FSharpInlineAnnotation.OptionalInline\nfnVal.IsActivePattern // false\nfnVal.IsCompilerGenerated // false\nfnVal.IsDispatchSlot // false\nfnVal.IsExtensionMember // false\nfnVal.IsPropertyGetterMethod // false\nfnVal.IsImplicitConstructor // false\nfnVal.IsInstanceMember // false\nfnVal.IsMember // false\nfnVal.IsModuleValueOrMember // true\nfnVal.IsMutable // false\nfnVal.IsPropertySetterMethod // false\nfnVal.IsTypeFunction // false\n\n(**\nNow look at the type of the function if used as a first class value. (Aside: the `CurriedParameterGroups` property contains\nmore information like the names of the arguments.)\n*)\nfnVal.FullType // int * int -> unit\nfnVal.FullType.IsFunctionType // int * int -> unit\nfnVal.FullType.GenericArguments.[0] // int * int\nfnVal.FullType.GenericArguments.[0].IsTupleType // int * int\nlet argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\nargTy1.TypeDefinition.DisplayName // int\n\n(**\nOK, so we got an object representation of the type `int * int -> unit`, and we have seen the first 'int'. We can find out more about the\ntype 'int' as follows, determining that it is a named type, which is an F# type abbreviation, `type int = int32`:\n*)\n\nargTy1.HasTypeDefinition\nargTy1.TypeDefinition.IsFSharpAbbreviation // \"int\"\n\n(**\nWe can now look at the right-hand-side of the type abbreviation, which is the type `int32`:\n*)\n\nlet argTy1b = argTy1.TypeDefinition.AbbreviatedType\nargTy1b.TypeDefinition.Namespace // Some \"Microsoft.FSharp.Core\"\nargTy1b.TypeDefinition.CompiledName // \"int32\"\n\n(**\nAgain we can now look through the type abbreviation `type int32 = System.Int32` to get the\nfull information about the type:\n*)\nlet argTy1c = argTy1b.TypeDefinition.AbbreviatedType\nargTy1c.TypeDefinition.Namespace // Some \"SystemCore\"\nargTy1c.TypeDefinition.CompiledName // \"Int32\"\n\n(**\nThe type checking results for a file also contain information extracted from the project (or script) options\nused in the compilation, called the `ProjectContext`:\n*)\nlet projectContext = checkFileResults.ProjectContext\n\nfor assembly in projectContext.GetReferencedAssemblies() do\n    match assembly.FileName with\n    | None -> printfn \"compilation referenced an assembly without a file\"\n    | Some s -> printfn \"compilation references assembly '%s'\" s\n\n\n(**\n**Notes:**\n\n  - If incomplete code is present, some or all of the attributes may not be quite as expected.\n  - If some assembly references are missing (which is actually very, very common), then 'IsUnresolved'  may\n    be true on values, members and/or entities related to external assemblies.  You should be sure to make your\n    code robust against IsUnresolved exceptions.\n\n*)\n\n(**\n\n## Getting symbolic information about whole projects\n\nTo check whole projects, create a checker, then call `parseAndCheckScript`. In this case, we just check\nthe project for a single script. By specifying a different \"projOptions\" you can create\na specification of a larger project.\n*)\nlet parseAndCheckScript (file, input) =\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    checker.ParseAndCheckProject(projOptions) |> Async.RunSynchronously\n\n(**\nNow do it for a particular input:\n*)\n\nlet tmpFile = Path.ChangeExtension(System.IO.Path.GetTempFileName() , \"fs\")\nFile.WriteAllText(tmpFile, input2)\n\nlet projectResults = parseAndCheckScript(tmpFile, SourceText.ofString input2)\n\n\n(**\nNow look at the results:\n*)\n\nlet assemblySig = projectResults.AssemblySignature\n\nassemblySig.Entities.Count = 1  // one entity\nassemblySig.Entities.[0].Namespace  // one entity\nassemblySig.Entities.[0].DisplayName // \"Tmp28D0\"\nassemblySig.Entities.[0].MembersFunctionsAndValues.Count // 1\nassemblySig.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"foo\"\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/interactive.html","title":"Embedding F# Interactive","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nInteractive Service: Embedding F# Interactive\n=============================================\n\nThis tutorial demonstrates how to embed F# interactive in your application. F# interactive\nis an interactive scripting environment that compiles F# code into highly efficient IL code\nand executes it on the fly. The F# interactive service allows you to embed F# evaluation in\nyour application.\n\n> **NOTE:** There is a number of options for embedding F# Interactive. The easiest one is to use the\n`fsi.exe` process and communicate with it using standard input and standard output. In this\ntutorial, we look at calling F# Interactive directly through .NET API. However, if you have\nno control over the input, it is a good idea to run F# interactive in a separate process.\nOne reason is that there is no way to handle `StackOverflowException` and so a poorly written\nscript can terminate the host process. **Remember that while calling F# Interactive through .NET API,\n` --shadowcopyreferences` option will be ignored**. For detailed discussion, please take a look at\n[this thread](https://github.com/fsharp/FSharp.Compiler.Service/issues/292).\n> **NOTE:** If `FsiEvaluationSession.Create` fails with an error saying that `FSharp.Core.dll` cannot be found,\nadd the `FSharp.Core.sigdata` and `FSharp.Core.optdata` files. More info [here](https://fsharp.github.io/FSharp.Compiler.Service/corelib.html).\n\nHowever, the F# interactive service is still useful, because you might want to wrap it in your\nown executable that is then executed (and communicates with the rest of your application), or\nif you only need to execute limited subset of F# code (e.g. generated by your own DSL).\n\nStarting the F# interactive\n---------------------------\n\nFirst, we need to reference the libraries that contain F# interactive service:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Interactive.Shell\n\n(**\nTo communicate with F# interactive, we need to create streams that represent input and\noutput. We will use those later to read the output printed as a result of evaluating some\nF# code that prints:\n*)\nopen System\nopen System.IO\nopen System.Text\n\n// Initialize output and input streams\nlet sbOut = new StringBuilder()\nlet sbErr = new StringBuilder()\nlet inStream = new StringReader(\"\")\nlet outStream = new StringWriter(sbOut)\nlet errStream = new StringWriter(sbErr)\n\n// Build command line arguments & start FSI session\nlet argv = [| \"C:\\\\fsi.exe\" |]\nlet allArgs = Array.append argv [|\"--noninteractive\"|]\n\nlet fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\nlet fsiSession = FsiEvaluationSession.Create(fsiConfig, allArgs, inStream, outStream, errStream)\n\n\n\n(**\nEvaluating and executing code\n-----------------------------\n\nThe F# interactive service exposes several methods that can be used for evaluation. The first\nis `EvalExpression` which evaluates an expression and returns its result. The result contains\nthe returned value (as `obj`) and the statically inferred type of the value:\n*)\n/// Evaluate expression & return the result\nlet evalExpression text =\n  match fsiSession.EvalExpression(text) with\n  | Some value -> printfn \"%A\" value.ReflectionValue\n  | None -> printfn \"Got no result!\"\n\n(**\nThis takes a string as an argument and evaluates (i.e. executes) it as F# code.\n*)\nevalExpression \"42+1\" // prints '43'\n\n(**\nThis can be used in a strongly typed way as follows:\n*)\n\n/// Evaluate expression & return the result, strongly typed\nlet evalExpressionTyped<'T> (text) =\n    match fsiSession.EvalExpression(text) with\n    | Some value -> value.ReflectionValue |> unbox<'T>\n    | None -> failwith \"Got no result!\"\n\nevalExpressionTyped<int> \"42+1\"  // gives '43'\n\n\n(**\nThe `EvalInteraction` method can be used to evaluate side-effectful operations\nsuch as printing, declarations, or other interactions that are not valid F# expressions, but can be entered in\nthe F# Interactive console. Such commands include `#time \"on\"` (and other directives), `open System`\nall declarations and other top-level statements. The code\ndoes not require `;;` at the end. Just enter the code that you want to execute:\n*)\nfsiSession.EvalInteraction \"printfn \\\"bye\\\"\"\n\n\n(**\nThe `EvalScript` method allows to evaluate a complete .fsx script.\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 10 + 10\")\nfsiSession.EvalScript \"sample.fsx\"\n\n(**\nCatching errors\n------------------\n\n``EvalExpression``, ``EvalInteraction`` and ``EvalScript`` are awkward if the\ncode has type checking warnings or errors, or if evaluation fails with an exception.\nIn these cases you can use ``EvalExpressionNonThrowing``, ``EvalInteractionNonThrowing``\nand ``EvalScriptNonThrowing``. These return a tuple of a result and an array of ``FSharpErrorInfo`` values.\nThese represent the errors and warnings. The result part is a ``Choice<_,_>`` between an actual\nresult and an exception.\n\nThe result part of ``EvalExpression`` and ``EvalExpressionNonThrowing`` is an optional ``FSharpValue``.\nIf that value is not present then it just indicates that the expression didn't have a tangible\nresult that could be represented as a .NET object.  This situation shouldn't actually\noccur for any normal input expressions, and only for primitives used in libraries.\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 'a' + 10.0\")\nlet result, warnings = fsiSession.EvalScriptNonThrowing \"sample.fsx\"\n\n// show the result\nmatch result with\n| Choice1Of2 () -> printfn \"checked and executed ok\"\n| Choice2Of2 exn -> printfn \"execution exception: %s\" exn.Message\n\n\n(**\nGives:\n\n    execution exception: Operation could not be completed due to earlier error\n*)\n\n// show the errors and warnings\nfor w in warnings do\n   printfn \"Warning %s at %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n\n(**\nGives:\n\n    Warning The type 'float' does not match the type 'char' at 1,19\n    Warning The type 'float' does not match the type 'char' at 1,17\n\nFor expressions:\n*)\n\n\nlet evalExpressionTyped2<'T> text =\n   let res, warnings = fsiSession.EvalExpressionNonThrowing(text)\n   for w in warnings do\n       printfn \"Warning %s at %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n   match res with\n   | Choice1Of2 (Some value) -> value.ReflectionValue |> unbox<'T>\n   | Choice1Of2 None -> failwith \"null or no result\"\n   | Choice2Of2 (exn:exn) -> failwith (sprintf \"exception %s\" exn.Message)\n\nevalExpressionTyped2<int> \"42+1\"  // gives '43'\n\n\n(**\nExecuting in parallel\n------------------\n\nBy default the code passed to ``EvalExpression`` is executed immediately. To execute in parallel, submit a computation that starts a task:\n*)\n\nopen System.Threading.Tasks\n\nlet sampleLongRunningExpr =\n    \"\"\"\nasync {\n    // The code of what you want to run\n    do System.Threading.Thread.Sleep 5000\n    return 10\n}\n  |> Async.StartAsTask\"\"\"\n\nlet task1 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\nlet task2 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\n\n(**\nBoth computations have now started.  You can now fetch the results:\n*)\n\n\ntask1.Result // gives the result after completion (up to 5 seconds)\ntask2.Result // gives the result after completion (up to 5 seconds)\n\n(**\nType checking in the evaluation context\n------------------\n\nLet's assume you have a situation where you would like to typecheck code\nin the context of the F# Interactive scripting session. For example, you first\nevaluation a declaration:\n*)\n\nfsiSession.EvalInteraction \"let xxx = 1 + 1\"\n\n(**\n\nNow you want to typecheck the partially complete code `xxx + xx`\n*)\n\nlet parseResults, checkResults, checkProjectResults =\n    fsiSession.ParseAndCheckInteraction(\"xxx + xx\")\n    |> Async.RunSynchronously\n\n(**\nThe `parseResults` and `checkResults` have types `ParseFileResults` and `CheckFileResults`\nexplained in [Editor](editor.html). You can, for example, look at the type errors in the code:\n*)\ncheckResults.Errors.Length // 1\n\n(**\nThe code is checked with respect to the logical type context available in the F# interactive session\nbased on the declarations executed so far.\n\nYou can also request declaration list information, tooltip text and symbol resolution:\n*)\nopen FSharp.Compiler\n\n// get a tooltip\ncheckResults.GetToolTipText(1, 2, \"xxx + xx\", [\"xxx\"], FSharpTokenTag.IDENT)\n\ncheckResults.GetSymbolUseAtLocation(1, 2, \"xxx + xx\", [\"xxx\"]) // symbol xxx\n\n(**\nThe 'fsi' object\n------------------\n\nIf you want your scripting code to be able to access the 'fsi' object, you should pass in an implementation of this object explicitly.\nNormally the one from FSharp.Compiler.Interactive.Settings.dll is used.\n*)\n\nlet fsiConfig2 = FsiEvaluationSession.GetDefaultConfiguration(fsiSession)\n\n(**\nCollectible code generation\n------------------\n\nEvaluating code in using FsiEvaluationSession generates a .NET dynamic assembly and uses other resources.\nYou can make generated code collectible by passing `collectible=true`.  However code will only\nbe collected if there are no outstanding object references involving types, for example\n`FsiValue` objects returned by `EvalExpression`, and you must have disposed the `FsiEvaluationSession`.\nSee also [Restrictions on Collectible Assemblies](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/dd554932(v=vs.100)#restrictions).\n\nThe example below shows the creation of 200 evaluation sessions. Note that `collectible=true` and\n`use session = ...` are both used.\n\nIf collectible code is working correctly,\noverall resource usage will not increase linearly as the evaluation progresses.\n*)\n\nlet collectionTest() =\n\n    for i in 1 .. 200 do\n        let defaultArgs = [|\"fsi.exe\";\"--noninteractive\";\"--nologo\";\"--gui-\"|]\n        use inStream = new StringReader(\"\")\n        use outStream = new StringWriter()\n        use errStream = new StringWriter()\n\n        let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\n        use session = FsiEvaluationSession.Create(fsiConfig, defaultArgs, inStream, outStream, errStream, collectible=true)\n\n        session.EvalInteraction (sprintf \"type D = { v : int }\")\n        let v = session.EvalExpression (sprintf \"{ v = 42 * %d }\" i)\n        printfn \"iteration %d, result = %A\" i v.Value.ReflectionValue\n\n// collectionTest()  <-- run the test like this\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/corelib.html","title":"Notes on FSharp.Core.dll","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on FSharp.Core.dll\n=================================================\n\nShipping an FSharp.Core with your application\n---------------------------------------------\n\nWhen building applications or plug-in components which use FSharp.Compiler.Service.dll, you will normally also\ninclude a copy of FSharp.Core.dll as part of your application.\n\nFor example, if you build a ``HostedCompiler.exe``, you will normally place an FSharp.Core.dll (say 4.3.1.0) alongside\nyour ``HostedCompiler.exe``.\n\nBinding redirects for your application\n--------------------------------------\n\nThe FSharp.Compiler.Service.dll component depends on FSharp.Core 4.4.0.0.  Normally your application will target\na later version of FSharp.Core, and you may need a [binding redirect](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/redirect-assembly-versions) to ensure\nthat other versions of FSharp.Core forward to the final version of FSharp.Core.dll your application uses.\nBinding redirect files are normally generated automatically by build tools. If not, you can use one like this\n(if your tool is called ``HostedCompiler.exe``, the binding redirect file is called ``HostedCompiler.exe.config``)\n\nSome other dependencies may also need to be reconciled and forwarded.\n\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <configuration>\n        <runtime>\n          <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n            <dependentAssembly>\n              <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\"/>\n              <bindingRedirect oldVersion=\"2.0.0.0-4.4.0.0\" newVersion=\"4.4.1.0\"/>\n            </dependentAssembly>\n            <dependentAssembly>\n              <assemblyIdentity name=\"System.Collections.Immutable\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n              <bindingRedirect oldVersion=\"1.0.0.0-1.2.0.0\" newVersion=\"1.2.1.0\" />\n            </dependentAssembly>\n          </assemblyBinding>\n        </runtime>\n    </configuration>\n\nWhich FSharp.Core and .NET Framework gets referenced in compilation?\n--------------------------------------\n\nThe FSharp.Compiler.Service component can be used to do more or less any sort of F# compilation.\nIn particular you can reference an explicit FSharp.Core and/or framework\nassemblies in the command line arguments (different to the FSharp.Core and a .NET Framework being used to run your tool).\n\nTo target a specific FSharp.Core and/or .NET Framework assemblies, use the ``--noframework`` argument\nand the appropriate command-line arguments:\n\n    [<Literal>]\n    let fsharpCorePath =\n        @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.1.0\\FSharp.Core.dll\"\n    let errors2, exitCode2 =\n      scs.Compile(\n        [| \"fsc.exe\"; \"--noframework\";\n           \"-r\"; fsharpCorePath;\n           \"-r\"; @\"C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorlib.dll\";\n           \"-o\"; fn3;\n           \"-a\"; fn2 |])\n\nYou will need to determine the location of these assemblies.  The easiest way to locate these DLLs in a cross-platform way and\nconvert them to command-line arguments is to [crack an F# project file](https://fsharp.github.io/FSharp.Compiler.Service/project.html).\nAlternatively you can compute SDK paths yourself, and some helpers to do this are in [the tests for FSharp.Compiler.Service.dll](https://github.com/fsharp/FSharp.Compiler.Service/blob/8a943dd3b545648690cb3bed652a469bdb6dd869/tests/service/Common.fs#L54).\n\n\nWhat about if I am processing a script or using ``GetCheckOptionsFromScriptRoot``\n-------------------------------------------------------------------------\n\nIf you do _not_ explicitly reference an FSharp.Core.dll from an SDK location, or if you are processing a script\nusing ``FsiEvaluationSession`` or ``GetCheckOptionsFromScriptRoot``, then an implicit reference to FSharp.Core will be made\nby the following choice:\n\n1. The version of FSharp.Core.dll statically referenced by the host assembly returned by ``System.Reflection.Assembly.GetEntryAssembly()``.\n\n2. If there is no static reference to FSharp.Core in the host assembly, then\n\n   - For FSharp.Compiler.Service 1.4.0.x above (F# 4.0 series), a reference to FSharp.Core version 4.4.0.0 is added\n\nDo I need to include FSharp.Core.optdata and FSharp.Core.sigdata?\n--------------------------------------\n\nNo, unless you are doing something with very old FSharp.Core.dll.\n\nSummary\n-------\n\nIn this design note we have discussed three things:\n\n- which FSharp.Core.dll is used to run your compilation tools\n- how  to configure binding redirects for the FSharp.Core.dll used to run your compilation tools\n- which FSharp.Core.dll and/or framework assemblies are  referenced during the checking and compilations performed by your tools.\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/editor.html","title":"Editor services","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Editor services\n==================================\n\nThis tutorial demonstrates how to use the editor services provided by the F# compiler.\nThis API is used to provide auto-complete, tool-tips, parameter info help, matching of\nbrackets and other functions in F# editors including Visual Studio, Xamarin Studio and Emacs\n(see [fsharpbindings](https://github.com/fsharp/fsharpbinding) project for more information).\nSimilarly to [the tutorial on using untyped AST](untypedtree.html), we start by\ngetting the `InteractiveChecker` object.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nType checking sample source code\n--------------------------------\n\nAs in the [previous tutorial (using untyped AST)](untypedtree.html), we start by referencing\n`FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `InteractiveChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\n\nAs [previously](untypedtree.html), we use `GetProjectOptionsFromScriptRoot` to get a context\nwhere the specified input is the only file passed to the compiler (and it is treated as a\nscript file or stand-alone F# source code).\n\n*)\n// Sample input as a multi-line string\nlet input =\n  \"\"\"\n  open System\n\n  let foo() =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n      printfn \"%s\" msg.\n  \"\"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nlet projOptions, errors =\n    checker.GetProjectOptionsFromScript(file, SourceText.ofString input)\n    |> Async.RunSynchronously\n\nlet parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n(**\nTo perform type checking, we first need to parse the input using\n`ParseFile`, which gives us access to the [untyped AST](untypedtree.html). However,\nthen we need to call `CheckFileInProject` to perform the full type checking. This function\nalso requires the result of `ParseFileInProject`, so the two functions are often called\ntogether.\n*)\n// Perform parsing\n\nlet parseFileResults =\n    checker.ParseFile(file, SourceText.ofString input, parsingOptions)\n    |> Async.RunSynchronously\n(**\nBefore we look at the interesting operations provided by `TypeCheckResults`, we\nneed to run the type checker on a sample input. On F# code with errors, you would get some type checking\nresult (but it may contain incorrectly \"guessed\" results).\n*)\n\n// Perform type checking\nlet checkFileAnswer =\n    checker.CheckFileInProject(parseFileResults, file, 0, SourceText.ofString input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nAlternatively you can use `ParseAndCheckFileInProject` to check both in one step:\n*)\n\nlet parseResults2, checkFileAnswer2 =\n    checker.ParseAndCheckFileInProject(file, 0, SourceText.ofString input, projOptions)\n    |> Async.RunSynchronously\n\n(**\n\nThe function returns both the untyped parse result (which we do not use in this\ntutorial), but also a `CheckFileAnswer` value, which gives us access to all\nthe interesting functionality...\n*)\n\nlet checkFileResults =\n    match checkFileAnswer with\n    | FSharpCheckFileAnswer.Succeeded(res) -> res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n(**\n\nHere, we type check a simple function that (conditionally) prints \"Hello world\".\nOn the last line, we leave an additional dot in `msg.` so that we can get the\ncompletion list on the `msg` value (we expect to see various methods on the string\ntype there).\n\n\nUsing type checking results\n---------------------------\n\nLet's now look at some of the API that is exposed by the `TypeCheckResults` type. In general,\nthis is the type that lets you implement most of the interesting F# source code editor services.\n\n### Getting a tool tip\n\nTo get a tool tip, you can use `GetToolTipTextAlternate` method. The method takes a line number and character\noffset. Both of the numbers are zero-based. In the sample code, we want to get tooltip for the `foo`\nfunction that is defined on line 3 (line 0 is blank) and the letter `f` starts at index 7 (the tooltip\nwould work anywhere inside the identifier).\n\nIn addition, the method takes a tag of token which is typically `IDENT`, when getting tooltip for an\nidentifier (the other option lets you get tooltip with full assembly location when using `#r \"...\"`).\n\n*)\n// Get tag of the IDENT token to be used as the last argument\nopen FSharp.Compiler\nlet identToken = FSharpTokenTag.Identifier\n\n// Get tool tip at the specified location\nlet tip = checkFileResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], identToken)\nprintfn \"%A\" tip\n\n(**\n\n> **NOTE:** `GetToolTipTextAlternate` is an alternative name for the old `GetToolTipText`. The old `GetToolTipText` was\ndeprecated because it accepted zero-based line numbers.  At some point it will be removed, and  `GetToolTipTextAlternate` will be renamed back to `GetToolTipText`.\n*)\n\n(**\nAside from the location and token kind, the function also requires the current contents of the line\n(useful when the source code changes) and a `Names` value, which is a list of strings representing\nthe current long name. For example to get tooltip for the `Random` identifier in a long name\n`System.Random`, you would use location somewhere in the string `Random` and you would pass\n`[\"System\"; \"Random\"]` as the `Names` value.\n\nThe returned value is of type `ToolTipText` which contains a discriminated union `ToolTipElement`.\nThe union represents different kinds of tool tips that you can get from the compiler.\n\n### Getting auto-complete lists\n\nThe next method exposed by `TypeCheckResults` lets us perform auto-complete on a given location.\nThis can be called on any identifier or in any scope (in which case you get a list of names visible\nin the scope) or immediately after `.` to get a list of members of some object. Here, we get a\nlist of members of the string value `msg`.\n\nTo do this, we call `GetDeclarationListInfo` with the location of the `.` symbol on the last line\n(ending with `printfn \"%s\" msg.`). The offsets are one-based, so the location is `7, 23`.\nWe also need to specify a function that says that the text has not changed and the current identifier\nwhere we need to perform the completion.\n*)\n// Get declarations (autocomplete) for a location\nlet decls =\n    checkFileResults.GetDeclarationListInfo\n      (Some parseFileResults, 7, inputLines.[6], PartialLongName.Empty 23, (fun () -> []), fun _ -> false)\n    |> Async.RunSynchronously\n\n// Print the names of available items\nfor item in decls.Items do\n    printfn \" - %s\" item.Name\n\n(**\n\n> **NOTE:** `v` is an alternative name for the old `GetDeclarations`. The old `GetDeclarations` was\ndeprecated because it accepted zero-based line numbers.  At some point it will be removed, and  `GetDeclarationListInfo` will be renamed back to `GetDeclarations`.\n*)\n\n(**\nWhen you run the code, you should get a list containing the usual string methods such as\n`Substring`, `ToUpper`, `ToLower` etc. The fourth argument of `GetDeclarations`, here `([], \"msg\")`,\nspecifies the context for the auto-completion. Here, we want a completion on a complete name\n`msg`, but you could for example use `([\"System\"; \"Collections\"], \"Generic\")` to get a completion list\nfor a fully qualified namespace.\n\n### Getting parameter information\n\nThe next common feature of editors is to provide information about overloads of a method. In our\nsample code, we use `String.Concat` which has a number of overloads. We can get the list using\n`GetMethods` operation. As previously, this takes zero-indexed offset of the location that we are\ninterested in (here, right at the end of the `String.Concat` identifier) and we also need to provide\nthe identifier again (so that the compiler can provide up-to-date information when the source code\nchanges):\n\n*)\n// Get overloads of the String.Concat method\nlet methods =\n    checkFileResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"])\n    |> Async.RunSynchronously\n\n// Print concatenated parameter lists\nfor mi in methods.Methods do\n    [ for p in mi.Parameters -> p.Display ]\n    |> String.concat \", \"\n    |> printfn \"%s(%s)\" methods.MethodName\n(**\nThe code uses the `Display` property to get the annotation for each parameter. This returns information\nsuch as `arg0: obj` or `params args: obj[]` or `str0: string, str1: string`. We concatenate the parameters\nand print a type annotation with the method name.\n*)\n\n(**\n\n## Asynchronous and immediate operations\n\nYou may have noticed that `CheckFileInProject` is an asynchronous operation.\nThis indicates that type checking of F# code can take some time.\nThe F# compiler performs the work in background (automatically) and when\nwe call `CheckFileInProject` method, it returns an asynchronous operation.\n\nThere is also the `CheckFileInProjectIfReady` method. This returns immediately if the\ntype checking operation can't be started immediately, e.g. if other files in the project\nare not yet type-checked. In this case, a background worker might choose to do other\nwork in the meantime, or give up on type checking the file until the `FileTypeCheckStateIsDirty` event\nis raised.\n\n> The [fsharpbinding](https://github.com/fsharp/fsharpbinding) project has more advanced\nexample of handling the background work where all requests are sent through an F# agent.\nThis may be a more appropriate for implementing editor support.\n\n*)\n\n\n(**\nSummary\n-------\n\nThe `CheckFileAnswer` object contains other useful methods that were not covered in this tutorial. You\ncan use it to get location of a declaration for a given identifier, additional colorization information\n(the F# 3.1 colorizes computation builder identifiers & query operators) and others.\n\nUsing the FSharpChecker component in multi-project, incremental and interactive editing situations may involve\nknowledge of the [FSharpChecker operations queue](queue.html) and the [FSharpChecker caches](caches.html).\n\n\nFinally, if you are implementing an editor support for an editor that cannot directly call .NET API,\nyou can call many of the methods discussed here via a command line interface that is available in the\n[FSharp.AutoComplete](https://github.com/fsharp/fsharpbinding/tree/master/FSharp.AutoComplete) project.\n\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/queue.html","title":"Notes on the FSharpChecker operations queue","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on the FSharpChecker operations queue\n=================================================\n\nThis is a design note on the FSharpChecker component and its operations queue.  See also the notes on the [FSharpChecker caches](caches.html)\n\nFSharpChecker maintains an operations queue. Items from the FSharpChecker operations queue are processed\nsequentially and in order.\n\nThe thread processing these requests can also run a low-priority, interleaved background operation when the\nqueue is empty.  This can be used to implicitly bring the background check of a project \"up-to-date\".\nWhen the operations queue has been empty for 1 second,\nthis background work is run in small incremental fragments. This work is cooperatively time-sliced to be approximately <50ms, (see `maxTimeShareMilliseconds` in\nIncrementalBuild.fs). The project to be checked in the background is set implicitly\nby calls to ``CheckFileInProject`` and ``ParseAndCheckFileInProject``.\nTo disable implicit background checking completely, set ``checker.ImplicitlyStartBackgroundWork`` to false.\nTo change the time before background work starts, set ``checker.PauseBeforeBackgroundWork`` to the required number of milliseconds.\n\nMost calls to the FSharpChecker API enqueue an operation in the FSharpChecker compiler queue. These correspond to the\ncalls to EnqueueAndAwaitOpAsync in [service.fs](https://github.com/fsharp/FSharp.Compiler.Service/blob/master/src/fsharp/service/service.fs).\n\n* For example, calling `ParseAndCheckProject` enqueues a `ParseAndCheckProjectImpl` operation. The time taken for the\n  operation will depend on how much work is required to bring the project analysis up-to-date.\n\n* Likewise, calling any of `GetUsesOfSymbol`, `GetAllUsesOfAllSymbols`, `ParseFileInProject`,\n  `GetBackgroundParseResultsForFileInProject`, `MatchBraces`, `CheckFileInProjectIfReady`, `ParseAndCheckFileInProject`, `GetBackgroundCheckResultsForFileInProject`,\n  `ParseAndCheckProject`, `GetProjectOptionsFromScript`, `InvalidateConfiguration`, `InvaidateAll` and operations\n  on FSharpCheckResults will cause an operation to be enqueued. The length of the operation will\n  vary - many will be very fast - but they won't be processed until other operations already in the queue are complete.\n\nSome operations do not enqueue anything on the FSharpChecker operations queue - notably any accesses to the Symbol APIs.\nThese use cross-threaded access to the TAST data produced by other FSharpChecker operations.\n\nSome tools throw a lot of interactive work at the FSharpChecker operations queue.\nIf you are writing such a component, consider running your project against a debug build\nof FSharp.Compiler.Service.dll to see the Trace.WriteInformation messages indicating the length of the\noperations queue and the time to process requests.\n\nFor those writing interactive editors which use FCS, you\nshould be cautious about operations that request a check of  the entire project.\nFor example, be careful about requesting the check of an entire project\non operations like \"Highlight Symbol\" or \"Find Unused Declarations\"\n(which run automatically when the user opens a file or moves the cursor).\nas opposed to operations like \"Find All References\" (which a user explicitly triggers).\nProject checking can cause long and contention on the FSharpChecker operations queue.\n\nRequests to FCS can be cancelled by cancelling the async operation. (Some requests also\ninclude additional callbacks which can be used to indicate a cancellation condition).\nThis cancellation will be effective if the cancellation is performed before the operation\nis executed in the operations queue.\n\nSummary\n-------\n\nIn this design note, you learned that the FSharpChecker component keeps an operations queue. When using FSharpChecker\nin highly interactive situations, you should carefully consider the characteristics of the operations you are\nenqueueing.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/caches.html","title":"Notes on the FSharpChecker caches","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on the FSharpChecker caches\n=================================================\n\nThis is a design note on the FSharpChecker component and its caches.  See also the notes on the [FSharpChecker operations queue](queue.html)\n\nEach FSharpChecker object maintains a set of caches.  These are\n\n* ``scriptClosureCache`` - an MRU cache of default size ``projectCacheSize`` that caches the\n  computation of GetProjectOptionsFromScript. This computation can be lengthy as it can involve processing the transitive closure\n  of all ``#load`` directives, which in turn can mean parsing an unbounded number of script files\n\n* ``incrementalBuildersCache`` - an MRU cache of projects where a handle is being kept to their incremental checking state,\n  of default size ``projectCacheSize`` (= 3 unless explicitly set as a parameter).\n  The \"current background project\" (see the [FSharpChecker operations queue](queue.html))\n  will be one of these projects.  When analyzing large collections of projects, this cache usually occupies by far the most memory.\n  Increasing the size of this cache can dramatically decrease incremental computation of project-wide checking, or of checking\n  individual files within a project, but can very greatly increase memory usage.\n\n* ``braceMatchCache`` - an MRU cache of size ``braceMatchCacheSize`` (default = 5) keeping the results of calls to MatchBraces, keyed by filename, source and project options.\n\n* ``parseFileCache`` - an MRU cache of size ``parseFileCacheSize`` (default = 2) keeping the results of ParseFile,\n  keyed by filename, source and project options.\n\n* ``checkFileInProjectCache`` - an MRU cache of size ``incrementalTypeCheckCacheSize`` (default = 5) keeping the results of\n  ParseAndCheckFileInProject, CheckFileInProject and/or CheckFileInProjectIfReady. This is keyed by filename, file source\n  and project options.  The results held in this cache are only returned if they would reflect an accurate parse and check of the\n  file.\n\n* ``getToolTipTextCache`` - an aged lookup cache of strong size ``getToolTipTextSize`` (default = 5) computing the results of GetToolTipText.\n\n* ``ilModuleReaderCache`` - an aged lookup of weak references to \"readers\" for references .NET binaries. Because these\n  are all weak references, you can generally ignore this cache, since its entries will be automatically collected.\n  Strong references to binary readers will be kept by other FCS data structures, e.g. any project checkers, symbols or project checking results.\n\n  In more detail, the bytes for referenced .NET binaries are read into memory all at once, eagerly. Files are not left\n  open or memory-mapped when using FSharpChecker (as opposed to FsiEvaluationSession, which loads assemblies using reflection).\n  The purpose of this cache is mainly to ensure that while setting up compilation, the reads of mscorlib, FSharp.Core and so on\n  amortize cracking the DLLs.\n\n* ``frameworkTcImportsCache`` - an aged lookup of strong size 8 which caches the process of setting up type checking against a set of system\n  components (e.g. a particular version of mscorlib, FSharp.Core and other system DLLs).  These resources are automatically shared between multiple\n  project checkers which happen to reference the same set of system assemblies.\n\nProfiling the memory used by the various caches can be done by looking for the corresponding static roots in memory profiling traces.\n\nThe sizes of some of these caches can be adjusted by giving parameters to FSharpChecker.  Unless otherwise noted,\nthe cache sizes above indicate the \"strong\" size of the cache, where memory is held regardless of the memory\npressure on the system. Some of the caches can also hold \"weak\" references which can be collected at will by the GC.\n\n> Note: Because of these caches, you should generally use one global, shared FSharpChecker for everything in an IDE application.\n\n\nLow-Memory Condition\n-------\n\nVersion 1.4.0.8 added a \"maximum memory\" limit specified by the `MaxMemory` property on FSharpChecker (in MB). If an FCS project operation\nis performed (see `CheckMaxMemoryReached` in `service.fs`) and `System.GC.GetTotalMemory(false)` reports a figure greater than this, then\nthe strong sizes of all FCS caches are reduced to either 0 or 1.  This happens for the remainder of the lifetime of the FSharpChecker object.\nIn practice this will still make tools like the Visual Studio F# Power Tools usable, but some operations like renaming across multiple\nprojects may take substantially longer.\n\nBy default the maximum memory trigger is disabled, see `maxMBDefault` in `service.fs`.\n\nReducing the FCS strong cache sizes does not guarantee there will be enough memory to continue operations - even holding one project\nstrongly may exceed a process memory budget. It just means FCS may hold less memory strongly.\n\nIf you do not want the maximum memory limit to apply then set MaxMemory to System.Int32.MaxValue.\n\nSummary\n-------\n\nIn this design note, you learned that the FSharpChecker component keeps a set of caches in order to support common\nincremental analysis scenarios reasonably efficiently. They correspond roughly to the original caches and sizes\nused by the Visual F# Tools, from which the FSharpChecker component derives.\n\nIn long running, highly interactive, multi-project scenarios you should carefully\nconsider the cache sizes you are using and the tradeoffs involved between incremental multi-project checking and memory usage.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/project.html","title":"Project Analysis","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Project Analysis\n==================================\n\nThis tutorial demonstrates how to can analyze a whole project using services provided by the F# compiler.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\n*)\n\n\n(**\n\nGetting whole-project results\n-----------------------------\n\nAs in the [previous tutorial (using untyped AST)](untypedtree.html), we start by referencing\n`FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `InteractiveChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.Collections.Generic\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\nHere are our sample inputs:\n*)\n\nmodule Inputs =\n    open System.IO\n\n    let base1 = Path.GetTempFileName()\n    let fileName1 = Path.ChangeExtension(base1, \".fs\")\n    let base2 = Path.GetTempFileName()\n    let fileName2 = Path.ChangeExtension(base2, \".fs\")\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\n\ntype C() =\n    member x.P = 1\n\nlet xxx = 3 + 4\nlet fff () = xxx + xxx\n    \"\"\"\n    File.WriteAllText(fileName1, fileSource1)\n\n    let fileSource2 = \"\"\"\nmodule N\n\nopen M\n\ntype D1() =\n    member x.SomeProperty = M.xxx\n\ntype D2() =\n    member x.SomeProperty = M.fff() + D1().P\n\n// Generate a warning\nlet y2 = match 1 with 1 -> M.xxx\n    \"\"\"\n    File.WriteAllText(fileName2, fileSource2)\n\n\n(**\nWe use `GetProjectOptionsFromCommandLineArgs` to treat two files as a project:\n*)\n\nlet projectOptions =\n    let sysLib nm =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then\n            // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\\" + nm + \".dll\"\n        else\n            let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n            let (++) a b = System.IO.Path.Combine(a,b)\n            sysDir ++ nm + \".dll\"\n\n    let fsCore4300() =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then\n            // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"\n        else\n            sysLib \"FSharp.Core\"\n\n    checker.GetProjectOptionsFromCommandLineArgs\n       (Inputs.projFileName,\n        [| yield \"--simpleresolution\"\n           yield \"--noframework\"\n           yield \"--debug:full\"\n           yield \"--define:DEBUG\"\n           yield \"--optimize-\"\n           yield \"--out:\" + Inputs.dllName\n           yield \"--doc:test.xml\"\n           yield \"--warn:3\"\n           yield \"--fullpaths\"\n           yield \"--flaterrors\"\n           yield \"--target:library\"\n           yield Inputs.fileName1\n           yield Inputs.fileName2\n           let references =\n             [ sysLib \"mscorlib\"\n               sysLib \"System\"\n               sysLib \"System.Core\"\n               fsCore4300() ]\n           for r in references do\n                 yield \"-r:\" + r |])\n\n(**\nNow check the entire project (using the files saved on disk):\n*)\n\nlet wholeProjectResults = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\n(**\nNow look at the errors and warnings:\n*)\nwholeProjectResults .Errors.Length // 1\nwholeProjectResults.Errors.[0].Message.Contains(\"Incomplete pattern matches on this expression\") // yes it does\n\nwholeProjectResults.Errors.[0].StartLineAlternate // 13\nwholeProjectResults.Errors.[0].EndLineAlternate // 13\nwholeProjectResults.Errors.[0].StartColumn // 15\nwholeProjectResults.Errors.[0].EndColumn // 16\n\n(**\nNow look at the inferred signature for the project:\n*)\n[ for x in wholeProjectResults.AssemblySignature.Entities -> x.DisplayName ] // [\"N\"; \"M\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].NestedEntities -> x.DisplayName ] // [\"D1\"; \"D2\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[1].NestedEntities -> x.DisplayName ] // [\"C\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].MembersFunctionsAndValues -> x.DisplayName ] // [\"y\"; \"y2\"]\n\n(**\nYou can also get all symbols in the project:\n*)\nlet rec allSymbolsInEntities (entities: IList<FSharpEntity>) =\n    [ for e in entities do\n          yield (e :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             yield (x :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n          for x in e.FSharpFields do\n             yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities e.NestedEntities ]\n\nlet allSymbols = allSymbolsInEntities wholeProjectResults.AssemblySignature.Entities\n(**\nAfter checking the whole project, you can access the background results for individual files\nin the project. This will be fast and will not involve any additional checking.\n*)\n\nlet backgroundParseResults1, backgroundTypedParse1 =\n    checker.GetBackgroundCheckResultsForFileInProject(Inputs.fileName1, projectOptions)\n    |> Async.RunSynchronously\n\n\n(**\nYou can now resolve symbols in each file:\n*)\n\nlet xSymbolUseOpt =\n    backgroundTypedParse1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet xSymbolUse = xSymbolUseOpt.Value\n\nlet xSymbol = xSymbolUse.Symbol\n\n(**\nYou can find out more about a symbol by doing type checks on various symbol kinds:\n*)\n\nlet xSymbolAsValue =\n    match xSymbol with\n    | :? FSharpMemberOrFunctionOrValue as xSymbolAsVal -> xSymbolAsVal\n    | _ -> failwith \"we expected this to be a member, function or value\"\n\n\n(**\nFor each symbol, you can look up the references to that symbol:\n*)\nlet usesOfXSymbol =\n    wholeProjectResults.GetUsesOfSymbol(xSymbol)\n    |> Async.RunSynchronously\n\n(**\nYou can iterate all the defined symbols in the inferred signature and find where they are used:\n*)\nlet allUsesOfAllSignatureSymbols =\n    [ for s in allSymbols do\n         let uses = wholeProjectResults.GetUsesOfSymbol(s) |> Async.RunSynchronously\n         yield s.ToString(), uses ]\n\n(**\nYou can also look at all the symbols uses in the whole project (including uses of symbols with local scope)\n*)\nlet allUsesOfAllSymbols =\n    wholeProjectResults.GetAllUsesOfAllSymbols()\n    |> Async.RunSynchronously\n\n(**\nYou can also request checks of updated versions of files within the project (note that the other files\nin the project are still read from disk, unless you are using the [FileSystem API](filesystem.html)):\n\n*)\n\nlet parseResults1, checkAnswer1 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName1, 0, SourceText.ofString Inputs.fileSource1, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults1 =\n    match checkAnswer1 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"unexpected aborted\"\n\nlet parseResults2, checkAnswer2 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName2, 0, SourceText.ofString Inputs.fileSource2, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults2 =\n    match checkAnswer2 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"unexpected aborted\"\n\n(**\nAgain, you can resolve symbols and ask for references:\n*)\n\nlet xSymbolUse2Opt =\n    checkResults1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet xSymbolUse2 = xSymbolUse2Opt.Value\n\nlet xSymbol2 = xSymbolUse2.Symbol\n\nlet usesOfXSymbol2 =\n    wholeProjectResults.GetUsesOfSymbol(xSymbol2)\n    |> Async.RunSynchronously\n\n\n(**\nOr ask for all the symbols uses in the file (including uses of symbols with local scope)\n*)\nlet allUsesOfAllSymbolsInFile1 =\n    checkResults1.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n\n(**\nOr ask for all the uses of one symbol in one file:\n*)\nlet allUsesOfXSymbolInFile1 =\n    checkResults1.GetUsesOfSymbolInFile(xSymbol2)\n    |> Async.RunSynchronously\n\nlet allUsesOfXSymbolInFile2 =\n    checkResults2.GetUsesOfSymbolInFile(xSymbol2)\n    |> Async.RunSynchronously\n\n(**\n\nAnalyzing multiple projects\n-----------------------------\n\nIf you have multiple F# projects to analyze which include references from some projects to others,\nthen the simplest way to do this is to build the projects and specify the cross-project references using\na `-r:path-to-output-of-project.dll` argument in the ProjectOptions. However, this requires the build\nof each project to succeed, producing the DLL file on disk which can be referred to.\n\nIn some situations, e.g. in an IDE, you may wish to allow references to other F# projects prior to successful compilation to\na DLL. To do this, fill in the ProjectReferences entry in ProjectOptions, which recursively specifies the project\noptions for dependent projects. Each project reference still needs a corresponding `-r:path-to-output-of-project.dll`\ncommand line argument in ProjectOptions, along with an entry in ProjectReferences.\nThe first element of each tuple in the ProjectReferences entry should be the DLL name, i.e. `path-to-output-of-project.dll`.\nThis should be the same as the text used in the `-r` project reference.\n\nWhen a project reference is used, the analysis will make use of the results of incremental\nanalysis of the referenced F# project from source files, without requiring the compilation of these files to DLLs.\n\nTo efficiently analyze a set of F# projects which include cross-references, you should populate the ProjectReferences\ncorrectly and then analyze each project in turn.\n\n*)\n\n(**\n\n> **NOTE:** Project references are disabled if the assembly being referred to contains type provider components -\n  specifying the project reference will have no effect beyond forcing the analysis of the project, and the DLL will\n  still be required on disk.\n\n*)\n\n(**\nSummary\n-------\n\nAs you have seen, the `ParseAndCheckProject` lets you access results of project-wide analysis\nsuch as symbol references. To learn more about working with symbols, see [Symbols](symbols.html).\n\nUsing the FSharpChecker component in multi-project, incremental and interactive editing situations may involve\nknowledge of the [FSharpChecker operations queue](queue.html) and the [FSharpChecker caches](caches.html).\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/tokenizer.html","title":"F# Language Tokenizer","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Using the F# tokenizer\n=========================================\n\nThis tutorial demonstrates how to call the F# language tokenizer. Given F#\nsource code, the tokenizer generates a list of source code lines that contain\ninformation about tokens on each line. For each token, you can get the type\nof the token, exact location as well as color kind of the token (keyword,\nidentifier, number, operator, etc.).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nCreating the tokenizer\n---------------------\n\nTo use the tokenizer, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\n(**\nNow you can create an instance of `FSharpSourceTokenizer`. The class takes two\narguments - the first is the list of defined symbols and the second is the\nfile name of the source code. The defined symbols are required because the\ntokenizer handles `#if` directives. The file name is required only to specify\nlocations of the source code (and it does not have to exist):\n*)\nlet sourceTok = FSharpSourceTokenizer([], Some \"C:\\\\test.fsx\")\n(**\nUsing the `sourceTok` object, we can now (repeatedly) tokenize lines of\nF# source code.\n\nTokenizing F# code\n------------------\n\nThe tokenizer operates on individual lines rather than on the entire source\nfile. After getting a token, the tokenizer also returns new state (as `int64` value).\nThis can be used to tokenize F# code more efficiently. When source code changes,\nyou do not need to re-tokenize the entire file - only the parts that have changed.\n\n### Tokenizing single line\n\nTo tokenize a single line, we create a `FSharpLineTokenizer` by calling `CreateLineTokenizer`\non the `FSharpSourceTokenizer` object that we created earlier:\n*)\nlet tokenizer = sourceTok.CreateLineTokenizer(\"let answer=42\")\n(**\nNow, we can write a simple recursive function that calls `ScanToken` on the `tokenizer`\nuntil it returns `None` (indicating the end of line). When the function succeeds, it\nreturns `FSharpTokenInfo` object with all the interesting details:\n*)\n/// Tokenize a single line of F# code\nlet rec tokenizeLine (tokenizer:FSharpLineTokenizer) state =\n  match tokenizer.ScanToken(state) with\n  | Some tok, state ->\n      // Print token name\n      printf \"%s \" tok.TokenName\n      // Tokenize the rest, in the new state\n      tokenizeLine tokenizer state\n  | None, state -> state\n(**\nThe function returns the new state, which is needed if you need to tokenize multiple lines\nand an earlier line ends with a multi-line comment. As an initial state, we can use `0L`:\n*)\ntokenizeLine tokenizer FSharpTokenizerLexState.Initial\n(**\nThe result is a sequence of tokens with names LET, WHITESPACE, IDENT, EQUALS and INT32.\nThere is a number of interesting properties on `FSharpTokenInfo` including:\n\n - `CharClass` and `ColorClass` return information about the token category that\n   can be used for colorizing F# code.\n - `LeftColumn` and `RightColumn` return the location of the token inside the line.\n - `TokenName` is the name of the token (as defined in the F# lexer)\n\nNote that the tokenizer is stateful - if you want to tokenize single line multiple times,\nyou need to call `CreateLineTokenizer` again.\n\n### Tokenizing sample code\n\nTo run the tokenizer on a longer sample code or an entire file, you need to read the\nsample input as a collection of `string` values:\n*)\nlet lines = \"\"\"\n  // Hello world\n  let hello() =\n     printfn \"Hello world!\" \"\"\".Split('\\r','\\n')\n(**\nTo tokenize multi-line input, we again need a recursive function that keeps the current\nstate. The following function takes the lines as a list of strings (together with line number\nand the current state). We create a new tokenizer for each line and call `tokenizeLine`\nusing the state from the *end* of the previous line:\n*)\n/// Print token names for multiple lines of code\nlet rec tokenizeLines state count lines =\n  match lines with\n  | line::lines ->\n      // Create tokenizer & tokenize single line\n      printfn \"\\nLine %d\" count\n      let tokenizer = sourceTok.CreateLineTokenizer(line)\n      let state = tokenizeLine tokenizer state\n      // Tokenize the rest using new state\n      tokenizeLines state (count+1) lines\n  | [] -> ()\n(**\nThe function simply calls `tokenizeLine` (defined earlier) to print the names of all\nthe tokens on each line. We can call it on the previous input with `0L` as the initial\nstate and `1` as the number of the first line:\n*)\nlines\n|> List.ofSeq\n|> tokenizeLines FSharpTokenizerLexState.Initial 1\n(**\nIgnoring some unimportant details (like whitespace at the beginning of each line and\nthe first line which is just whitespace), the code generates the following output:\n\n    [lang=text]\n    Line 1\n      LINE_COMMENT LINE_COMMENT (...) LINE_COMMENT\n    Line 2\n      LET WHITESPACE IDENT LPAREN RPAREN WHITESPACE EQUALS\n    Line 3\n      IDENT WHITESPACE STRING_TEXT (...) STRING_TEXT STRING\n\nIt is worth noting that the tokenizer yields multiple `LINE_COMMENT` tokens and multiple\n`STRING_TEXT` tokens for each single comment or string (roughly, one for each word), so\nif you want to get the entire text of a comment/string, you need to concatenate the\ntokens.\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/react.html","title":"Reacting to Changes","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Reacting to Changes\n============================================\n\nThis tutorial discusses some technical aspects of how to make sure the F# compiler service is\nproviding up-to-date results especially when hosted in an IDE. See also [project wide analysis](project.html)\nfor information on project analysis.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\nThe logical results of all \"Check\" routines (``ParseAndCheckFileInProject``, ``GetBackgroundCheckResultsForFileInProject``,\n``TryGetRecentTypeCheckResultsForFile``, ``ParseAndCheckProject``) depend on results reported by the file system,\nespecially the ``IFileSystem`` implementation described in the tutorial on [project wide analysis](project.html).\nLogically speaking, these results would be different if file system changes occur.  For example,\nreferenced DLLs may change on disk, or referenced files may change.\n\nThe ``FSharpChecker`` component from FSharp.Compiler.Service does _not_ actively \"listen\"\nto changes in the file system.  However ``FSharpChecker`` _does_ repeatedly ask for\ntime stamps from the file system which it uses to decide if recomputation is needed.\nFCS doesn't listen for changes directly - for example, it creates no ``FileWatcher`` object (and the\n``IFileSystem`` API has no ability to create such objects).  This is partly for legacy reasons,\nand partly because some hosts forbid the creation of FileWatcher objects.\n\nIn most cases the repeated timestamp requests are sufficient. If you don't actively\nlisten for changes, then ``FSharpChecker`` will still do _approximately_\nthe right thing, because it is asking for time stamps repeatedly.  However, some updates on the file system\n(such as a DLL appearing after a build, or the user randomly pasting a file into a folder)\nmay not actively be noticed by ``FSharpChecker`` until some operation happens to ask for a timestamp.\nBy issuing fresh requests, you can ensure that FCS actively reassesses the state of play when\nstays up-to-date when changes are observed.\n\nIf you want to more actively listen for changes, then you should add watchers for the\nfiles specified in the ``DependencyFiles`` property of ``FSharpCheckFileResults`` and ``FSharpCheckProjectResults``.\nHere�s what you need to do:\n\n* When your client notices an CHANGE event on a DependencyFile, it should schedule a refresh call to perform the ParseAndCheckFileInProject (or other operation) again.\n  This will result in fresh FileSystem calls to compute time stamps.\n\n* When your client notices an ADD event on a DependencyFile, it should call ``checker.InvalidateConfiguration``\n  for all active projects in which the file occurs. This will result in fresh FileSystem calls to compute time\n  stamps, and fresh calls to compute whether files exist.\n\n* Generally clients don�t listen for DELETE events on files.  Although it would be logically more consistent\n  to do so, in practice it�s very irritating for a \"project clean\" to invalidate all intellisense and\n  cause lots of red squiggles.  Some source control tools also make a change by removing and adding files, which\n  is best noticed as a single change event.\n\n\n\nIf your host happens to be Visual Studio, then this is one technique you can use:\n* Listeners should be associated with a visual source file buffer\n* Use fragments like this to watch the DependencyFiles:\n\n        // Get the service\n        let vsFileWatch = fls.GetService(typeof<SVsFileChangeEx >) :?> IVsFileChangeEx\n\n        // Watch the Add and Change events\n        let fileChangeFlags =\n            uint32 (_VSFILECHANGEFLAGS.VSFILECHG_Add |||\n                    // _VSFILECHANGEFLAGS.VSFILECHG_Del ||| // don't listen for deletes - if a file (such as a 'Clean'ed project reference) is deleted, just keep using stale info\n                    _VSFILECHANGEFLAGS.VSFILECHG_Time)\n\n        // Advise on file changes...\n        let cookie = Com.ThrowOnFailure1(vsFileWatch.AdviseFileChange(file, fileChangeFlags, changeEvents))\n\n        ...\n\n        // Unadvised file changes...\n        Com.ThrowOnFailure0(vsFileWatch.UnadviseFileChange(cookie))\n\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/untypedtree.html","title":"Processing untyped AST","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Processing untyped syntax tree\n=================================================\n\nThis tutorial demonstrates how to get the untyped abstract syntax tree (AST)\nfor F# code and how to walk over the tree. This can be used for creating tools\nsuch as code formatter, basic refactoring or code navigation tools. The untyped\nsyntax tree contains information about the code structure, but does not contain\ntypes and there are some ambiguities that are resolved only later by the type\nchecker. You can also combine the untyped AST information with the API available\nfrom [editor services](editor.html).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nGetting the untyped AST\n-----------------------\n\nTo access the untyped AST, you need to create an instance of `FSharpChecker`.\nThis type represents a context for type checking and parsing and corresponds either\nto a stand-alone F# script file (e.g. opened in Visual Studio) or to a loaded project\nfile with multiple files. Once you have an instance of `FSharpChecker`, you can\nuse it to perform \"untyped parse\" which is the first step of type-checking. The\nsecond phase is \"typed parse\" and is used by [editor services](editor.html).\n\nTo use the interactive checker, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n(**\n\n### Performing untyped parse\n\nThe untyped parse operation is very fast (compared to type checking, which can\ntake notable amount of time) and so we can perform it synchronously. First, we\nneed to create `FSharpChecker` - the constructor takes an argument that\ncan be used to notify the checker about file changes (which we ignore).\n\n*)\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n(**\n\nTo get the AST, we define a function that takes file name and the source code\n(the file is only used for location information and does not have to exist).\nWe first need to get \"interactive checker options\" which represents the context.\nFor simple tasks, you can use `GetProjectOptionsFromScriptRoot` which infers\nthe context for a script file. Then we use the `ParseFile` method and\nreturn the `ParseTree` property:\n\n*)\n/// Get untyped tree for a specified input\nlet getUntypedTree (file, input) =\n  // Get compiler options for the 'project' implied by a single script file\n  let projOptions, errors =\n      checker.GetProjectOptionsFromScript(file, input)\n      |> Async.RunSynchronously\n\n  let parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n  // Run the first phase (untyped parsing) of the compiler\n  let parseFileResults =\n      checker.ParseFile(file, input, parsingOptions)\n      |> Async.RunSynchronously\n\n  match parseFileResults.ParseTree with\n  | Some tree -> tree\n  | None -> failwith \"Something went wrong during parsing!\"\n\n(**\n\nWalking over the AST\n--------------------\n\nThe abstract syntax tree is defined as a number of discriminated unions that represent\ndifferent syntactical elements (such as expressions, patterns, declarations etc.). The best\nway to understand the AST is to look at the definitions in [`ast.fs` in the source\ncode](https://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs#L464).\n\nThe relevant parts are in the following namespace:\n*)\nopen FSharp.Compiler.SyntaxTree\n(**\n\nWhen processing the AST, you will typically write a number of mutually recursive functions\nthat pattern match on the different syntactical elements. There is a number of elements\nthat need to be supported - the top-level element is module or namespace declaration,\ncontaining declarations inside a module (let bindings, types etc.). A let declaration inside\na module then contains expression, which can contain patterns.\n\n### Walking over patterns and expressions\n\nWe start by looking at functions that walk over expressions and patterns - as we walk,\nwe print information about the visited elements. For patterns, the input is of type\n`SynPat` and has a number of cases including `Wild` (for `_` pattern), `Named` (for\n`<pat> as name`) and `LongIdent` (for a `Foo.Bar` name). Note that the parsed pattern\nis occasionally more complex than what is in the source code (in particular, `Named` is\nused more often):\n*)\n/// Walk over a pattern - this is for example used in\n/// let <pat> = <expr> or in the 'match' expression\nlet rec visitPattern = function\n  | SynPat.Wild(_) ->\n      printfn \"  .. underscore pattern\"\n  | SynPat.Named(pat, name, _, _, _) ->\n      visitPattern pat\n      printfn \"  .. named as '%s'\" name.idText\n  | SynPat.LongIdent(LongIdentWithDots(ident, _), _, _, _, _, _) ->\n      let names = String.concat \".\" [ for i in ident -> i.idText ]\n      printfn \"  .. identifier: %s\" names\n  | pat -> printfn \"  .. other pattern: %A\" pat\n(**\nThe function is recursive (for nested patterns such as `(foo, _) as bar`), but it does not\ncall any of the functions defined later (because patterns cannot contain other syntactical\nelements).\n\nThe next function iterates over expressions - this is where most of the work would be and\nthere are around 20 cases to cover (type `SynExpr.` and you'll get completion with other\noptions). In the following, we only show how to handle `if .. then ..` and `let .. = ...`:\n*)\n/// Walk over an expression - if expression contains two or three\n/// sub-expressions (two if the 'else' branch is missing), let expression\n/// contains pattern and two sub-expressions\nlet rec visitExpression = function\n  | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n      // Visit all sub-expressions\n      printfn \"Conditional:\"\n      visitExpression cond\n      visitExpression trueBranch\n      falseBranchOpt |> Option.iter visitExpression\n\n  | SynExpr.LetOrUse(_, _, bindings, body, _) ->\n      // Visit bindings (there may be multiple\n      // for 'let .. = .. and .. = .. in ...'\n      printfn \"LetOrUse with the following bindings:\"\n      for binding in bindings do\n        let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                     data, pat, retInfo, init, m, sp)) = binding\n        visitPattern pat\n        visitExpression init\n      // Visit the body expression\n      printfn \"And the following body:\"\n      visitExpression body\n  | expr -> printfn \" - not supported expression: %A\" expr\n(**\nThe `visitExpression` function will be called from a function that visits all top-level\ndeclarations inside a module. In this tutorial, we ignore types and members, but that would\nbe another source of calls to `visitExpression`.\n\n### Walking over declarations\n\nAs mentioned earlier, the AST of a file contains a number of module or namespace declarations\n(top-level node) that contain declarations inside a module (let bindings or types) or inside\na namespace (just types). The following functions walks over declarations - we ignore types,\nnested modules and all other elements and look only at top-level `let` bindings (values and\nfunctions):\n*)\n/// Walk over a list of declarations in a module. This is anything\n/// that you can write as a top-level inside module (let bindings,\n/// nested modules, type declarations etc.)\nlet visitDeclarations decls =\n  for declaration in decls do\n    match declaration with\n    | SynModuleDecl.Let(isRec, bindings, range) ->\n        // Let binding as a declaration is similar to let binding\n        // as an expression (in visitExpression), but has no body\n        for binding in bindings do\n          let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                       data, pat, retInfo, body, m, sp)) = binding\n          visitPattern pat\n          visitExpression body\n    | _ -> printfn \" - not supported declaration: %A\" declaration\n(**\nThe `visitDeclarations` function will be called from a function that walks over a\nsequence of module or namespace declarations. This corresponds, for example, to a file\nwith multiple `namespace Foo` declarations:\n*)\n/// Walk over all module or namespace declarations\n/// (basically 'module Foo =' or 'namespace Foo.Bar')\n/// Note that there is one implicitly, even if the file\n/// does not explicitly define it..\nlet visitModulesAndNamespaces modulesOrNss =\n  for moduleOrNs in modulesOrNss do\n    let (SynModuleOrNamespace(lid, isRec, isMod, decls, xml, attrs, _, m)) = moduleOrNs\n    printfn \"Namespace or module: %A\" lid\n    visitDeclarations decls\n(**\nNow that we have functions that walk over the elements of the AST (starting from declaration,\ndown to expressions and patterns), we can get AST of a sample input and run the above function.\n\nPutting things together\n-----------------------\n\nAs already discussed, the `getUntypedTree` function uses `FSharpChecker` to run the first\nphase (parsing) on the AST and get back the tree. The function requires F# source code together\nwith location of the file. The location does not have to exist (it is used only for location\ninformation) and it can be in both Unix and Windows formats:\n*)\n// Sample input for the compiler service\nlet input =\n  \"\"\"\n  let foo() =\n    let msg = \"Hello world\"\n    if true then\n      printfn \"%s\" msg\n  \"\"\"\n\n// File name in Unix format\nlet file = \"/home/user/Test.fsx\"\n\n// Get the AST of sample F# code\nlet tree = getUntypedTree(file, SourceText.ofString input)\n(**\nWhen you run the code in F# interactive, you can enter `tree;;` in the interactive console and\nsee pretty printed representation of the data structure - the tree contains a lot of information,\nso this is not particularly readable, but it gives you good idea about how the tree looks.\n\nThe returned `tree` value is again a discriminated union that can be two different cases - one case\nis `ParsedInput.SigFile` which represents F# signature file (`*.fsi`) and the other one is\n`ParsedInput.ImplFile` representing regular source code (`*.fsx` or `*.fs`). The implementation\nfile contains a sequence of modules or namespaces that we can pass to the function implemented\nin the previous step:\n*)\n// Extract implementation file details\nmatch tree with\n| ParsedInput.ImplFile(implFile) ->\n    // Extract declarations and walk over them\n    let (ParsedImplFileInput(fn, script, name, _, _, modules, _)) = implFile\n    visitModulesAndNamespaces modules\n| _ -> failwith \"F# Interface file (*.fsi) not supported.\"\n(**\nSummary\n-------\nIn this tutorial, we looked at basic of working with the untyped abstract syntax tree. This is a\ncomprehensive topic, so it is not possible to explain everything in a single article. The\n[Fantomas project](https://github.com/dungpa/fantomas) is a good example of tool based on the untyped\nAST that can help you understand more. In practice, it is also useful to combine the information here\nwith some information you can obtain from the [editor services](editor.html) discussed in the next\ntutorial.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/compiler.html","title":"Hosted Compiler","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nHosted Compiler\n===============\n\nThis tutorial demonstrates how to host the F# compiler.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n*)\n\n(**\n> **NOTE:** There are several options for hosting the F# compiler. The easiest one is to use the\n`fsc.exe` process and pass arguments.\n*)\n\n(**\n\n> **NOTE:** By default [compilations using FSharp.Compiler.Service reference FSharp.Core 4.3.0.0](https://github.com/fsharp/FSharp.Compiler.Service/issues/156) (matching F# 3.0).  You can override\nthis choice by passing a reference to FSharp.Core for 4.3.1.0 or later explicitly in your command-line arguments.\n\n*)\n\n(**\n---------------------------\n\nFirst, we need to reference the libraries that contain F# interactive service:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\nNow write content to a temporary file:\n\n*)\nlet fn = Path.GetTempFileName()\nlet fn2 = Path.ChangeExtension(fn, \".fsx\")\nlet fn3 = Path.ChangeExtension(fn, \".dll\")\n\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\ntype C() =\n   member x.P = 1\n\nlet x = 3 + 4\n\"\"\")\n\n(**\nNow invoke the compiler:\n*)\n\nlet errors1, exitCode1 =\n    checker.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |])\n    |> Async.RunSynchronously\n\n(**\n\nIf errors occur you can see this in the 'exitCode' and the returned array of errors:\n\n*)\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\nlet x = 1.0 + \"\" // a type error\n\"\"\")\n\nlet errors1b, exitCode1b =\n    checker.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |])\n    |> Async.RunSynchronously\n\n(**\n\nCompiling to a dynamic assembly\n===============================\n\nYou can also compile to a dynamic assembly, which uses the F# Interactive code generator.\nThis can be useful if you are, for example, in a situation where writing to the file system\nis not really an option.\n\nYou still have to pass the \"-o\" option to name the output file, but the output file is not actually written to disk.\n\nThe 'None' option indicates that the initialization code for the assembly is not executed.\n*)\nlet errors2, exitCode2, dynAssembly2 =\n    checker.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], execute=None)\n     |> Async.RunSynchronously\n\n(*\nPassing 'Some' for the 'execute' parameter executes  the initialization code for the assembly.\n*)\nlet errors3, exitCode3, dynAssembly3 =\n    checker.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], Some(stdout,stderr))\n     |> Async.RunSynchronously\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/filesystem.html","title":"ファイルシステム仮想化","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: ファイルシステム仮想化\n==========================================\n\n`FSharp.Compiler.Service` にはファイルシステムを表すグローバル変数があります。\nこの変数を設定するこにより、ファイルシステムが利用できない状況でも\nコンパイラをホストすることができるようになります。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\nFileSystemの設定\n----------------\n\n以下の例ではディスクからの読み取りを行うような実装をファイルシステムに設定しています:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen System.Collections.Generic\nopen System.Text\nopen FSharp.Compiler.AbstractIL.Internal.Library\n\nlet defaultFileSystem = Shim.FileSystem\n\nlet fileName1 = @\"c:\\mycode\\test1.fs\" // 注意: 実際には存在しないファイルのパス\nlet fileName2 = @\"c:\\mycode\\test2.fs\" // 注意: 実際には存在しないファイルのパス\n\ntype MyFileSystem() =\n    let file1 = \"\"\"\nmodule File1\n\nlet A = 1\"\"\"\n    let file2 = \"\"\"\nmodule File2\nlet B = File1.A + File1.A\"\"\"\n    let files = dict [(fileName1, file1); (fileName2, file2)]\n\n    interface IFileSystem with\n        // 読み取りおよび書き込み用にファイルをオープンする機能を実装\n        member __.FileStreamReadShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> new MemoryStream(Encoding.UTF8.GetBytes(text)) :> Stream\n            | _ -> defaultFileSystem.FileStreamReadShim(fileName)\n\n        member __.FileStreamCreateShim(fileName) =\n            defaultFileSystem.FileStreamCreateShim(fileName)\n\n        member __.IsStableFileHeuristic(fileName) =\n            defaultFileSystem.IsStableFileHeuristic(fileName)\n\n        member __.FileStreamWriteExistingShim(fileName) =\n            defaultFileSystem.FileStreamWriteExistingShim(fileName)\n\n        member __.ReadAllBytesShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> Encoding.UTF8.GetBytes(text)\n            | _ -> defaultFileSystem.ReadAllBytesShim(fileName)\n\n        // 一時パスおよびファイルのタイムスタンプに関連する機能を実装\n        member __.GetTempPathShim() =\n            defaultFileSystem.GetTempPathShim()\n\n        member __.GetLastWriteTimeShim(fileName) =\n            defaultFileSystem.GetLastWriteTimeShim(fileName)\n\n        member __.GetFullPathShim(fileName) =\n            defaultFileSystem.GetFullPathShim(fileName)\n\n        member __.IsInvalidPathShim(fileName) =\n            defaultFileSystem.IsInvalidPathShim(fileName)\n\n        member __.IsPathRootedShim(fileName) =\n            defaultFileSystem.IsPathRootedShim(fileName)\n\n        // ファイルの存在確認および削除に関連する機能を実装\n        member __.SafeExists(fileName) =\n            files.ContainsKey(fileName) || defaultFileSystem.SafeExists(fileName)\n\n        member __.FileDelete(fileName) =\n            defaultFileSystem.FileDelete(fileName)\n\n        // アセンブリのロードに関連する機能を実装。\n        // 型プロバイダやF# Interactiveで使用される。\n        member __.AssemblyLoadFrom(fileName) =\n            defaultFileSystem.AssemblyLoadFrom fileName\n\n        member __.AssemblyLoad(assemblyName) =\n            defaultFileSystem.AssemblyLoad assemblyName\n\nlet myFileSystem = MyFileSystem()\nShim.FileSystem <- MyFileSystem()\n\n(**\n\nFileSystemによるコンパイルの実行\n--------------------------------\n\n*)\nopen FSharp.Compiler.SourceCodeServices\n\nlet checker = FSharpChecker.Create()\nlet projectOptions =\n    let allFlags =\n        [| yield \"--simpleresolution\";\n           yield \"--noframework\";\n           yield \"--debug:full\";\n           yield \"--define:DEBUG\";\n           yield \"--optimize-\";\n           yield \"--doc:test.xml\";\n           yield \"--warn:3\";\n           yield \"--fullpaths\";\n           yield \"--flaterrors\";\n           yield \"--target:library\";\n           let references =\n             [ @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\mscorlib.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.Core.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"]\n           for r in references do\n                 yield \"-r:\" + r |]\n\n    { ProjectFileName = @\"c:\\mycode\\compilation.fsproj\" // 現在のディレクトリで一意な名前を指定\n      ProjectId = None\n      SourceFiles = [| fileName1; fileName2 |]\n      OriginalLoadReferences = []\n      ExtraProjectInfo=None\n      Stamp = None\n      OtherOptions = allFlags\n      ReferencedProjects=[| |]\n      IsIncompleteTypeCheckEnvironment = false\n      UseScriptResolutionRules = true\n      LoadTime = System.DateTime.Now // 'Now' を指定して強制的に再読込させている点に注意\n      UnresolvedReferences = None }\n\nlet results = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\nresults.Errors\nresults.AssemblySignature.Entities.Count //2\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.Count //1\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"B\"\n\n(**\nまとめ\n------\nこのチュートリアルでは FSharp.Compiler.Service コンポーネントで使用される\nファイルシステムに注目して、グローバルな設定を変更する方法について紹介しました。\n\nこのチュートリアルの執筆時点では、以下に列挙したSystem.IOの操作に対しては\n仮想化されたファイルシステムAPIが用意されない予定になっています。\n将来のバージョンのコンパイラサービスではこれらのAPIが追加されるかもしれません。\n\n  - Path.Combine\n  - Path.DirectorySeparatorChar\n  - Path.GetDirectoryName\n  - Path.GetFileName\n  - Path.GetFileNameWithoutExtension\n  - Path.HasExtension\n  - Path.GetRandomFileName (アセンブリ内にコンパイル済みwin32リソースを生成する場合にのみ使用される)\n\n**注意:** `SourceCodeServices` API内の一部の操作では、\n引数にファイルの内容だけでなくファイル名を指定する必要があります。\nこれらのAPIにおいて、ファイル名はエラーの報告のためだけに使用されます。\n\n**注意:** 型プロバイダーコンポーネントは仮想化されたファイルシステムを使用しません。\n\n**注意:** コンパイラサービスは `--simpleresolution` が指定されていない場合、\nMSBuildを使ってアセンブリの解決を試みることがあります。\n`FileSystem` APIを使用する場合、通常はコンパイラへのフラグとして\n`--simpleresolution` を指定することになります。\nそれと同時に `--noframework` を指定します。\n.NETアセンブリに対するすべての参照を明示的に指定する必要があるでしょう。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/symbols.html","title":"シンボルの処理","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: シンボルの処理\n==================================\n\nこのチュートリアルでは、F#コンパイラによって提供される\nシンボルの扱い方についてのデモを紹介します。\nシンボルの参照に関する情報については [プロジェクト全体の分析](project.html)\nも参考にしてください。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、\n  最新のnugetパッケージの公開に伴って変更されることがあります。\n\nこれまでと同じく、 `FSharp.Compiler.Service.dll` への参照を追加した後、\n適切な名前空間をオープンし、 `FSharpChecker` のインスタンスを作成します:\n\n*)\n// F#コンパイラAPIへの参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n\nそして特定の入力値に対して型チェックを行います:\n\n*)\n\nlet parseAndTypeCheckSingleFile (file, input) =\n    // スタンドアロンの(スクリプト)ファイルを表すコンテキストを取得\n    let projOptions, _errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let parseFileResults, checkFileResults =\n        checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n        |> Async.RunSynchronously\n\n    // 型チェックが成功(あるいは100%に到達)するまで待機\n    match checkFileResults with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseFileResults, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet file = \"/home/user/Test.fsx\"\n\n(**\n## ファイルに対する解決済みのシグネチャ情報を取得する\n\nファイルに対する型チェックが完了すると、\n`TypeCheckResults` の `PartialAssemblySignature` プロパティを参照することにより、\nチェック中の特定のファイルを含む、推論されたプロジェクトのシグネチャに\nアクセスすることができます。\n\nモジュールや型、属性、メンバ、値、関数、共用体、レコード型、測定単位、\nおよびその他のF#言語要素に対する完全なシグネチャ情報が参照できます。\n\nただし型付き式ツリーに対する情報は(今のところ)この方法では利用できません。\n\n*)\n\nlet input2 =\n      \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n        printfn \"x = %d, y = %d\" x y\n        printfn \"%s\" msg\n\ntype C() =\n    member x.P = 1\n      \"\"\"\nlet parseFileResults, checkFileResults =\n    parseAndTypeCheckSingleFile(file, input2)\n\n(**\nこれでコードに対する部分的なアセンブリのシグネチャが取得できるようになります:\n*)\nlet partialAssemblySignature = checkFileResults.PartialAssemblySignature\n\npartialAssemblySignature.Entities.Count = 1  // エンティティは1つ\n\n(**\nそしてコードを含むモジュールに関連したエンティティを取得します:\n*)\nlet moduleEntity = partialAssemblySignature.Entities.[0]\n\nmoduleEntity.DisplayName = \"Test\"\n\n(**\nそしてコード内の型定義に関連したエンティティを取得します:\n*)\nlet classEntity = moduleEntity.NestedEntities.[0]\n\n(**\nそしてコード内で定義された関数に関連した値を取得します:\n*)\nlet fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n(**\n関数値に関するプロパティの値を確認してみましょう。\n*)\nfnVal.Attributes.Count // 1\nfnVal.CurriedParameterGroups.Count // 1\nfnVal.CurriedParameterGroups.[0].Count // 2\nfnVal.CurriedParameterGroups.[0].[0].Name // \"x\"\nfnVal.CurriedParameterGroups.[0].[1].Name // \"y\"\nfnVal.DeclarationLocation.StartLine // 3\nfnVal.DisplayName // \"foo\"\nfnVal.DeclaringEntity.Value.DisplayName // \"Test\"\nfnVal.DeclaringEntity.Value.DeclarationLocation.StartLine // 1\nfnVal.GenericParameters.Count // 0\nfnVal.InlineAnnotation // FSharpInlineAnnotation.OptionalInline\nfnVal.IsActivePattern // false\nfnVal.IsCompilerGenerated // false\nfnVal.IsDispatchSlot // false\nfnVal.IsExtensionMember // false\nfnVal.IsPropertyGetterMethod // false\nfnVal.IsImplicitConstructor // false\nfnVal.IsInstanceMember // false\nfnVal.IsMember // false\nfnVal.IsModuleValueOrMember // true\nfnVal.IsMutable // false\nfnVal.IsPropertySetterMethod // false\nfnVal.IsTypeFunction // false\n\n(**\n次に、この関数の型がファーストクラスの値として使用されているかどうかチェックします。\n(ちなみに `CurriedParameterGroups` プロパティには引数の名前など、\nより多くの情報も含まれています)\n*)\nfnVal.FullType // int * int -> unit\nfnVal.FullType.IsFunctionType // true\nfnVal.FullType.GenericArguments.[0] // int * int\nfnVal.FullType.GenericArguments.[0].IsTupleType // true\nlet argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\nargTy1.TypeDefinition.DisplayName // int\n\n(**\nというわけで `int * int -> unit` という型を表現するオブジェクトが取得できて、\nその1つめの 'int' を確認できたわけです。\nまた、以下のようにすると 'int' 型についてのより詳細な情報が取得でき、\nそれが名前付きの型であり、F#の型省略形 `type int = int32` であることがわかります:\n*)\n\nargTy1.HasTypeDefinition // true\nargTy1.TypeDefinition.IsFSharpAbbreviation // true\n\n(**\n型省略形の右辺、つまり `int32` についてもチェックしてみましょう:\n*)\n\nlet argTy1b = argTy1.TypeDefinition.AbbreviatedType\nargTy1b.TypeDefinition.Namespace // Some \"Microsoft.FSharp.Core\"\nargTy1b.TypeDefinition.CompiledName // \"int32\"\n\n(**\nそして再び型省略形 `type int32 = System.Int32` から型に関する完全な情報が取得できます:\n*)\nlet argTy1c = argTy1b.TypeDefinition.AbbreviatedType\nargTy1c.TypeDefinition.Namespace // Some \"System\"\nargTy1c.TypeDefinition.CompiledName // \"Int32\"\n\n(**\nファイルに対する型チェックの結果には、\nコンパイル時に使用されたプロジェクト(あるいはスクリプト)のオプションに関する\n`ProjectContext` と呼ばれる情報も含まれています:\n*)\nlet projectContext = checkFileResults.ProjectContext\n\nfor assembly in projectContext.GetReferencedAssemblies() do\n    match assembly.FileName with\n    | None -> printfn \"コンパイル時にファイルの存在しないアセンブリを参照しました\"\n    | Some s -> printfn \"コンパイル時にアセンブリ '%s' を参照しました\" s\n\n(**\n**注意:**\n\n  - 不完全なコードが存在する場合、一部あるいはすべての属性が意図したとおりには\n    並ばないことがあります。\n  - (実際には非常によくあることですが)一部のアセンブリが見つからない場合、\n    外部アセンブリに関連する値やメンバ、エンティティにおける 'IsUnresolved' が\n    trueになることがあります。\n    IsUnresolvedによる例外に対処できるよう、堅牢なコードにしておくべきです。\n\n*)\n\n(**\n\n## プロジェクト全体に対するシンボル情報を取得する\n\nプロジェクト全体をチェックする場合、チェッカーを作成した後に `parseAndCheckScript`\nを呼び出します。\n今回の場合は単に1つのスクリプトだけが含まれたプロジェクトをチェックします。\n異なる \"projOptions\" を指定すると、巨大なプロジェクトに対する設定を\n構成することもできます。\n*)\nlet parseAndCheckScript (file, input) =\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let projResults =\n        checker.ParseAndCheckProject(projOptions)\n        |> Async.RunSynchronously\n\n    projResults\n\n(**\nそして特定の入力に対してこの関数を呼び出します:\n*)\n\nlet tmpFile = Path.ChangeExtension(System.IO.Path.GetTempFileName() , \"fs\")\nFile.WriteAllText(tmpFile, input2)\n\nlet projectResults = parseAndCheckScript(tmpFile, input2)\n\n\n(**\n結果は以下の通りです:\n*)\n\nlet assemblySig = projectResults.AssemblySignature\n\nassemblySig.Entities.Count = 1  // エンティティは1つ\nassemblySig.Entities.[0].Namespace  // null\nassemblySig.Entities.[0].DisplayName // \"Tmp28D0\"\nassemblySig.Entities.[0].MembersFunctionsAndValues.Count // 1\nassemblySig.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"foo\"\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/interactive.html","title":"F# Interactiveの組み込み","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nインタラクティブサービス: F# Interactiveの組み込み\n==================================================\n\nこのチュートリアルでは、独自のアプリケーションに\nF# Interactiveを組み込む方法について紹介します。\nF# Interactiveは対話式のスクリプティング環境で、\nF#コードを高度に最適化されたILコードへとコンパイルしつつ、\nそれを即座に実行することができます。\nF# Interactiveサービスを使用すると、独自のアプリケーションに\nF#の評価機能を追加できます。\n\n> **注意:** F# Interactiveは様々な方法で組み込むことができます。\n  最も簡単な方法は `fsi.exe` プロセスとの間で標準入出力経由でやりとりする方法です。\n  このチュートリアルではF# Interactiveの機能を.NET APIで\n  直接呼び出す方法について紹介します。\n  ただし入力用のコントロールを備えていない場合、別プロセスでF# Interactiveを\n  起動するのはよい方法だといえます。\n  理由の1つとしては `StackOverflowException` を処理する方法がないため、\n  出来の悪いスクリプトによってはホストプロセスが停止させられてしまう\n  場合があるからです。\n  **.NET APIを通じてF# Interactiveを呼び出すとしても、 `--shadowcopyreferences`\n  オプションは無視されることを覚えておきましょう。**\n  詳細な議論については、[このスレッド](https://github.com/fsharp/FSharp.Compiler.Service/issues/292)\n  に目を通してみてください。\n  **注意:** もし`FSharp.Core.dll` が見つからないというエラーが出て `FsiEvaluationSession.Create`\n  に失敗した場合、 `FSharp.Core.sigdata` と `FSharp.Core.optdata` というファイルを追加してください。\n  詳しい内容は[こちら](https://fsharp.github.io/FSharp.Compiler.Service/ja/corelib.html)\n  にあります。\n\nしかしそれでもF# InteractiveサービスにはF# Interactiveを実行ファイルに埋め込んで\n実行出来る(そしてアプリケーションの各機能とやりとり出来る)、あるいは\n機能限定されたF#コード(たとえば独自のDSLによって生成されたコード)だけを\n実行させることが出来るという便利さがあります。\n\nF# Interactiveの開始\n--------------------\n\nまずF# Interactiveサービスを含むライブラリへの参照を追加します:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Interactive.Shell\n\n(**\nF# Interactiveとやりとりするには、入出力を表すストリームを作成する必要があります。\nこれらのストリームを使用することで、\nいくつかのF#コードに対する評価結果を後から出力することができます:\n*)\nopen System\nopen System.IO\nopen System.Text\n\n// 入出力のストリームを初期化\nlet sbOut = new StringBuilder()\nlet sbErr = new StringBuilder()\nlet inStream = new StringReader(\"\")\nlet outStream = new StringWriter(sbOut)\nlet errStream = new StringWriter(sbErr)\n\n// コマンドライン引数を組み立てて、FSIセッションを開始する\nlet argv = [| \"C:\\\\fsi.exe\" |]\nlet allArgs = Array.append argv [|\"--noninteractive\"|]\n\nlet fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\nlet fsiSession = FsiEvaluationSession.Create(fsiConfig, allArgs, inStream, outStream, errStream)\n\n(**\nコードの評価および実行\n----------------------\n\nF# Interactiveサービスにはコードを評価するためのメソッドがいくつか用意されています。\n最初の1つは `EvalExpression` で、式を評価してその結果を返します。\n結果には戻り値が( `obj` として)含まれる他、値に対して静的に推論された型も含まれます:\n*)\n/// 式を評価して結果を返す\nlet evalExpression text =\n  match fsiSession.EvalExpression(text) with\n  | Some value -> printfn \"%A\" value.ReflectionValue\n  | None -> printfn \"結果が得られませんでした！\"\n\n(**\nこれは引数に文字列を取り、それをF#コードとして評価(つまり実行)します。\n*)\nevalExpression \"42+1\" // '43' を表示する\n\n(**\nこれは以下のように強く型付けされた方法で使うことができます:\n*)\n\n/// 式を評価して、強く型付けされた結果を返す\nlet evalExpressionTyped<'T> (text) =\n    match fsiSession.EvalExpression(text) with\n    | Some value -> value.ReflectionValue |> unbox<'T>\n    | None -> failwith \"結果が得られませんでした！\"\n\nevalExpressionTyped<int> \"42+1\"  // '43' になる\n\n\n(**\n`EvalInteraction` メソッドは画面出力機能や宣言、\nF#の式としては不正なものの、F# Interactiveコンソールには入力できるようなものなど、\n副作用を伴う命令を評価する場合に使用できます。\nたとえば `#time \"on\"` (あるいはその他のディレクティブ)や `open System` 、\nその他の宣言やトップレベルステートメントなどが該当します。\n指定するコードの終端に `;;` を入力する必要はありません。\n実行したいコードだけを入力します:\n*)\nfsiSession.EvalInteraction \"printfn \\\"bye\\\"\"\n\n\n(**\n`EvalScript` メソッドを使用すると、完全な .fsx スクリプトを評価することができます。\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 10 + 10\")\nfsiSession.EvalScript \"sample.fsx\"\n\n(**\n例外処理\n--------\n\nコードに型チェックの警告やエラーがあった場合、または評価して例外で失敗した場合、\n`EvalExpression` 、 `EvalInteraction` そして `EvalScript` ではあまりうまく処理されません。\nこれらのケースでは、 `EvalExpressionNonThrowing` 、 `EvalInteractionNonThrowing`\nそして `EvalScriptNonThrowing` を使うことが出来ます。\nこれらは結果と `FSharpErrorInfo` 値の配列の組を返します。\nこれらはエラーと警告を表します。結果の部分は実際の結果と例外のいずれかを表す\n`Choice<_,_>` です。\n\n`EvalExpression` および `EvalExpressionNonThrowing` の結果部分は\nオプションの `FSharpValue` 値です。\nその値が存在しない場合、式が .NET オブジェクトとして表現できる具体的な結果を\n持っていなかったということを指し示しています。\nこの状況は実際には入力されたどんな通常の式に対しても発生すべきではなく、\nライブラリ内で使われるプリミティブ値に対してのみ発生すべきです。\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 'a' + 10.0\")\nlet result, warnings = fsiSession.EvalScriptNonThrowing \"sample.fsx\"\n\n// 結果を表示する\nmatch result with\n| Choice1Of2 () -> printfn \"チェックと実行はOKでした\"\n| Choice2Of2 exn -> printfn \"実行例外: %s\" exn.Message\n\n\n(**\nは次のようになります:\n\n    実行例外: Operation could not be completed due to earlier error\n*)\n\n// エラーと警告を表示する\nfor w in warnings do\n   printfn \"警告 %s 場所 %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n\n(**\nは次のようになります:\n\n    警告 The type 'float' does not match the type 'char' 場所 1,19\n    警告 The type 'float' does not match the type 'char' 場所 1,17\n\n式に対しては:\n*)\n\n\nlet evalExpressionTyped2<'T> text =\n   let res, warnings = fsiSession.EvalExpressionNonThrowing(text)\n   for w in warnings do\n       printfn \"警告 %s 場所 %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n   match res with\n   | Choice1Of2 (Some value) -> value.ReflectionValue |> unbox<'T>\n   | Choice1Of2 None -> failwith \"null または結果がありません\"\n   | Choice2Of2 (exn:exn) -> failwith (sprintf \"例外 %s\" exn.Message)\n\nevalExpressionTyped2<int> \"42+1\"  // '43' になる\n\n\n(**\n並列実行\n--------\n\nデフォルトでは `EvalExpression` に渡したコードは即時実行されます。\n並列に実行するために、タスクを開始する計算を投入します:\n*)\n\nopen System.Threading.Tasks\n\nlet sampleLongRunningExpr =\n    \"\"\"\nasync {\n    // 実行したいコード\n    do System.Threading.Thread.Sleep 5000\n    return 10\n}\n  |> Async.StartAsTask\"\"\"\n\nlet task1 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\nlet task2 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\n\n(**\n両方の計算がいま開始しました。結果を取得することが出来ます:\n*)\n\n\ntask1.Result // 完了後に結果が出てくる (最大5秒)\ntask2.Result // 完了後に結果が出てくる (最大5秒)\n\n(**\n評価コンテキスト内での型チェック\n--------------------------------\n\nF# Interactiveの一連のスクリプティングセッション中で\nコードの型チェックを実行したいような状況を考えてみましょう。\nたとえばまず宣言を評価します:\n*)\n\nfsiSession.EvalInteraction \"let xxx = 1 + 1\"\n\n(**\n\n次に部分的に完全な `xxx + xx` というコードの型チェックを実行したいとします:\n*)\n\nlet parseResults, checkResults, checkProjectResults =\n    fsiSession.ParseAndCheckInteraction(\"xxx + xx\") |> Async.RunSynchronously\n\n(**\n`parseResults` と `checkResults` はそれぞれ [エディタ](editor.html)\nのページで説明している `ParseFileResults` と `CheckFileResults` 型です。\nたとえば以下のようなコードでエラーを確認出来ます:\n*)\ncheckResults.Errors.Length // 1\n\n(**\nコードはF# Interactiveセッション内において、その時点までに実行された\n有効な宣言からなる論理的な型コンテキストと結びつく形でチェックされます。\n\nまた、宣言リスト情報やツールチップテキスト、シンボルの解決といった処理を\n要求することもできます:\n\n*)\nopen FSharp.Compiler\n\n// ツールチップを取得する\ncheckResults.GetToolTipText(1, 2, \"xxx + xx\", [\"xxx\"], FSharpTokenTag.IDENT)\n\ncheckResults.GetSymbolUseAtLocation(1, 2, \"xxx + xx\", [\"xxx\"]) // シンボル xxx\n\n(**\n'fsi'オブジェクト\n-----------------\n\nスクリプトのコードが'fsi'オブジェクトにアクセスできるようにしたい場合、\nこのオブジェクトの実装を明示的に渡さなければなりません。\n通常、FSharp.Compiler.Interactive.Settings.dll由来の1つが使われます。\n*)\n\nlet fsiConfig2 = FsiEvaluationSession.GetDefaultConfiguration(fsi)\n\n(**\n収集可能なコード生成\n--------------------\n\nFsiEvaluationSessionを使用してコードを評価すると、\n.NET の動的アセンブリを生成し、他のリソースを使用します。\n`collectible=true` を渡すことで、生成されたコードを収集可能に出来ます。\nしかしながら、例えば `EvalExpression` から返される `FsiValue` のような型を必要とする未解放のオブジェクト参照が無く、\nかつ `FsiEvaluationSession` を破棄したに違いない場合に限ってコードが収集されます。\n[収集可能なアセンブリに対する制限](https://msdn.microsoft.com/ja-jp/library/dd554932%28v=vs.110%29.aspx#Anchor_1)\nも参照してください。\n\n以下の例は200個の評価セッションを生成しています。 `collectible=true` と `use session = ...`\nの両方を使っていることに気をつけてください。\n\n収集可能なコードが正しく動いた場合、全体としてのリソース使用量は\n評価が進んでも線形には増加しないでしょう。\n*)\n\nlet collectionTest() =\n\n    for i in 1 .. 200 do\n        let defaultArgs = [|\"fsi.exe\";\"--noninteractive\";\"--nologo\";\"--gui-\"|]\n        use inStream = new StringReader(\"\")\n        use outStream = new StringWriter()\n        use errStream = new StringWriter()\n\n        let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\n        use session = FsiEvaluationSession.Create(fsiConfig, defaultArgs, inStream, outStream, errStream, collectible=true)\n\n        session.EvalInteraction (sprintf \"type D = { v : int }\")\n        let v = session.EvalExpression (sprintf \"{ v = 42 * %d }\" i)\n        printfn \"その %d, 結果 = %A\" i v.Value.ReflectionValue\n\n// collectionTest()  <-- このようにテストを実行する"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/corelib.html","title":"FSharp.Core.dll についてのメモ","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/net461\"\n(**\nコンパイラサービス: FSharp.Core.dll についてのメモ\n==================================================\n\nあなたのアプリケーションとともに FSharp.Core を配布する\n-------------------------------------------------------\n\nFSharp.Compiler.Service.dll を利用するアプリケーションまたはプラグイン・コンポーネントをビルドする際、普通はアプリの一部として FSharp.Core.dll のコピーも含めることになるでしょう。\n\n例えば、 ``HostedCompiler.exe`` をビルドする場合、普通はあなたの ``HostedCompiler.exe`` と同じフォルダに FSharp.Core.dll (例えば 4.3.1.0)を配置します。\n\n動的コンパイルや動的実行を行う場合、FSharp.Core.optdata と FSharp.Core.sigdata も含める必要があるかもしれませんが、これらについては下記の指針をご覧ください。\n\nあなたのアプリケーションにリダイレクトをバインドする\n----------------------------------------------------\n\nFSharp.Compiler.Service.dll コンポーネントは FSharp.Core 4.3.0.0 に依存しています。通例、あなたのアプリケーションはこれより後のバージョンの FSharp.Core をターゲットにしており、FSharp.Core 4.3.0.0 をあなたのアプリケーションで用いる FSharp.Core.dll の最終バージョンにちゃんと転送させるように[バインド リダイレクト](https://msdn.microsoft.com/ja-jp/library/7wd6ex19(v=vs.110).aspx)が必要になるでしょう。バインド リダイレクト ファイルは通常ビルドツールによって自動的に生成されます。そうでない場合、下記のようなファイル(あなたのツールが ``HostedCompiler.exe`` という名前で、バインド リダイレクト ファイルが ``HostedCompiler.exe.config`` という名前の場合)を使うことが出来ます。\n\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <configuration>\n        <runtime>\n          <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n            <dependentAssembly>\n              <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\"/>\n              <bindingRedirect oldVersion=\"2.0.0.0-4.3.0.0\" newVersion=\"4.3.1.0\"/>\n            </dependentAssembly>\n            <dependentAssembly>\n              <assemblyIdentity name=\"System.Collections.Immutable\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n              <bindingRedirect oldVersion=\"1.0.0.0-1.2.0.0\" newVersion=\"1.2.1.0\" />\n            </dependentAssembly>\n          </assemblyBinding>\n        </runtime>\n    </configuration>\n\nどの FSharp.Core と .NET フレームワークがコンパイル時に参照される？\n--------------------------------------\n\nFSharp.Combiler.Service コンポーネントは多かれ少なかれ、F#コードを コンパイルするために使われるに過ぎません。特に、コマンドライン引数(あなたのツールを実行するために使われる FSharp.Core や .NET フレームワークとは違います)に明示的に FSharp.Core および/またはフレームワークのアセンブリを参照することが出来ます。\n\n特定の FSharp.Core および .NET フレームワーク アセンブリ、またはそのいずれかをターゲットにする場合、 ``--noframework`` 引数と適切なコマンドライン引数を使います:\n\n    [<Literal>]\n    let fsharpCorePath =\n        @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.1.0\\FSharp.Core.dll\"\n    let errors2, exitCode2 =\n      scs.Compile(\n        [| \"fsc.exe\"; \"--noframework\";\n           \"-r\"; fsharpCorePath;\n           \"-r\"; @\"C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorlib.dll\";\n           \"-o\"; fn3;\n           \"-a\"; fn2 |])\n\nこれらのアセンブリが配置されている場所を指定する必要があります。クロスプラットフォームに対応した方法でDLL を配置して、それらをコマンドライン引数に変換する最も簡単な方法は、[F# プロジェクトファイルをクラックする](https://fsharp.github.io/FSharp.Compiler.Service/ja/project.html)ことです。\n自分で SDK のパスを処理する代わりに、[FSharp.Compiler.Service.dll 用のテスト](https://github.com/fsharp/FSharp.Compiler.Service/blob/8a943dd3b545648690cb3bed652a469bdb6dd869/tests/service/Common.fs#L54)で使用しているようなヘルパー関数も用意されています。\n\n\nスクリプトを処理しているか ``GetCheckOptionsFromScriptRoot`` を使っている場合\n-------------------------------------------------------------------------\n\nもし SDK 配置先にある FSharp.Core.dll を明示的に参照 *していない* 場合、または ``FsiEvaluationSession`` や ``GetCheckOptionsFromScriptRoot`` を使用してスクリプトを処理している場合、以下のいずれかの方法により、暗黙的にFSharp.Core が参照されます:\n\n1. ``System.Reflection.Assembly.GetEntryAssembly()`` によって返されるホストアセンブリから静的に参照されたFSharp.Core.dll のバージョン\n\n2. ホストアセンブリに FSharp.Core への静的な参照がない場合、\n\n   - FSharp.Compiler.Service 0.x シリーズでは、FSharp.Core バージョン 4.3.0.0 への参照が付与されます\n\n   - FSharp.Compiler.Service 1.3.1.x (F# 3.1 シリーズ)では、FSharp.Core バージョン 4.3.1.0 への参照が付与されます\n\n   - FSharp.Compiler.Service 1.4.0.x (F# 4.0 シリーズ)では、FSharp.Core バージョン 4.4.0.0 への参照が付与されます\n\nFSharp.Core.optdata と FSharp.Core.sigdata を含める必要はありますか？\n--------------------------------------\n\nもしあなたのコンパイル引数が SDK 配置先にある FSharp.Core.dll を明示的に参照している場合、FSharp.Core.sigdata と FSharp.Core.optdata はその DLL と同じフォルダになければいけません(これらのファイルがインストールされていない場合、F# SDKの インストールに問題があります)。もしコンパイル引数で常に明示的に参照していたなら、FSharp.Core.optdata と FSharp.Core.sigdata はあなたのアプリケーションの一部として含める必要は *ありません* 。\n\nもしあなたが暗黙的な参照(例えば、上記のスクリプト処理など)に頼っているのなら、これはあなたのツールがアプリケーションの一部として FSharp.Core.dll を参照しているかもしれない、ということです。この場合、FSharp.Core.optdata および FSharp.Core.sigdata が FSharp.Core.dll と同じフォルダに見つからないというエラーが発生するかもしれません。 **もしあなたがアプリケーションに含めている FSharp.Core.dll を暗黙的に参照したいのであれば、FSharp.Core.sigdata と FSharp.Core.optdata もアプリケーションに追加する2つのファイルとして追加しましょう。** ``CombileToDynamicAssembly`` を使用する場合、この問題によって[アセンブリ解決中のスタックオーバーフロー](https://github.com/fsharp/FSharp.Compiler.Service/issues/258)も引き起こされるでしょう。\n\n動的コンパイルと動的コード実行を行うツール(例: ``HostedExecution.exe``)はしばしば FSharp.Core.dll を暗黙的に参照するようになっています。\nこれはつまり通常 FSharp.Core.optdata と FSharp.Core.sigdata を含んでいるということです。\n\n要約\n-------\n\nこのデザインノートでは3つのポイントを検討しました:\n\n- どの FSharp.Core.dll があなたのコンパイルツールを実行するのに使われるか\n- あなたのコンパイルツールを実行するのに使われる FSharp.Core.dll へのバインド リダイレクトを設定する方法\n- あなたのツールによって実行されるチェック時およびコンパイル時にどの FSharp.Core.dll および/またはフレームワークのアセンブリが参照されるか\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/editor.html","title":"エディタサービス","content":"\n(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: エディタサービス\n====================================\n\nこのチュートリアルはF#コンパイラによって公開されるエディタサービスの\n使用方法についてのデモです。\nこのAPIにより、Visual StudioやXamarin Studio、EmacsなどのF#エディタ内において、\n自動補完機能やツールチップ表示、引数情報のヘルプ表示、括弧の補完などの機能を\n実装することができます\n(詳細については [fsharpbindings](https://github.com/fsharp/fsharpbinding) のプロジェクトを参照してください)。\n[型無しASTを使用するチュートリアル](untypedtree.html) と同じく、\n今回も `FSharpChecker` オブジェクトを作成するところから始めます。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、最新バージョンのnugetパッケージの\n公開に伴って変更されることがあります。\n\nサンプルソースコードの型チェック\n--------------------------------\n\n[前回の(型無しASTを使った)チュートリアル](untypedtree.html) と同じく、\n`FSharp.Compiler.Service.dll` への参照を追加した後に特定の名前空間をオープンし、\n`FSharpChecker` のインスタンスを作成します:\n\n*)\n// F#コンパイラAPIを参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n\n[前回](untypedtree.html) 同様、\nコンパイラに渡されるファイルとしては特定の入力値だけであるという\nコンテキストを想定するため、 `GetCheckOptionsFromScriptRoot` を使います\n(この入力値はコンパイラによってスクリプトファイル、\nあるいはスタンドアロンのF#ソースコードとみなされます)。\n\n*)\n// サンプルの入力となる複数行文字列\nlet input =\n    \"\"\"\nopen System\n\nlet foo() =\nlet msg = String.Concat(\"Hello\",\" \",\"world\")\nif true then\nprintfn \"%s\" msg.\n\"\"\"\n// 入力値の分割とファイル名の定義\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nlet projOptions, _errors1 = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n\nlet parsingOptions, _errors2 = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n(**\n\n型チェックを実行するには、まず `ParseFile` を使って\n入力値をパースする必要があります。\nこのメソッドを使うと [型無しAST](untypedtree.html) にアクセスできるようになります。\nしかし今回は完全な型チェックを実行するため、続けて `CheckFileInProject`\nを呼び出す必要があります。\nこのメソッドは `ParseFile` の結果も必要とするため、\nたいていの場合にはこれら2つのメソッドをセットで呼び出すことになります。\n\n*)\n// パースを実行\nlet parseFileResults =\n    checker.ParseFile(file, input, parsingOptions)\n    |> Async.RunSynchronously\n(**\n`TypeCheckResults` に備えられた興味深い機能の紹介に入る前に、\nサンプル入力に対して型チェッカーを実行する必要があります。\nF#コードにエラーがあった場合も何らかの型チェックの結果が返されます\n(ただし間違って「推測された」結果が含まれることがあります)。\n*)\n\n// 型チェックを実行\nlet checkFileAnswer =\n    checker.CheckFileInProject(parseFileResults, file, 0, input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nあるいは `ParseAndCheckFileInProject` を使用すれば1つの操作で両方のチェックを行うことができます：\n*)\n\nlet parseResults2, checkFileAnswer2 =\n    checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nこの返り値は `CheckFileAnswer` 型で、この型に機能的に興味深いものが揃えられています...\n*)\n\nlet checkFileResults =\n    match checkFileAnswer with\n    | FSharpCheckFileAnswer.Succeeded(res) -> res\n    | res -> failwithf \"パースが完了していません... (%A)\" res\n\n(**\n\n今回は単に(状況に応じて)「Hello world」と表示するだけの\n単純な関数の型をチェックしています。\n最終行では値 `msg` に対する補完リストを表示することができるように、\n`msg.` というようにドットを追加している点に注意してください\n(今回の場合は文字列型に対する様々なメソッドが期待されます)。\n\n\n型チェックの結果を使用する\n--------------------------\n\nでは `TypeCheckResults` 型で公開されているAPIをいくつか見ていきましょう。\n一般的に、F#ソースコードエディタサービスの実装に必要な機能は\nほとんどこの型に備えられています。\n\n### ツールチップの取得\n\nツールチップを取得するには `GetToolTipTextAlternate` メソッドを使用します。\nこのメソッドには行数と文字オフセットを指定します。\nいずれも0から始まる数値です。\nサンプルコードでは3行目(0行目は空白行)、インデックス7にある文字 `f` から始まる関数\n`foo` のツールチップを取得しています\n(ツールチップは識別子の中であれば任意の位置で機能します)。\n\nまたこのメソッドにはトークンタグを指定する必要もあります。\nトークンタグは一般的には `IDENT` を指定して、識別子に対する\nツールチップが取得できるようにします\n(あるいは `#r \"...\"` を使用している場合にはアセンブリの完全パスを表示させるように\nすることもできるでしょう)。\n\n*)\n// 最後の引数に指定する、IDENTトークンのタグを取得\nopen FSharp.Compiler\n\n// 特定の位置におけるツールチップを取得\nlet tip = checkFileResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier)\nprintfn \"%A\" tip\n\n(**\n\n> **注意：** `GetToolTipTextAlternate` は古い関数 `GetToolTipText` に代わるものです。\n`GetToolTipText` は0から始まる行番号を受け取るようになっていたため、非推奨になりました。\n\nこの関数には位置とトークンの種類の他にも、\n(ソースコードの変更時に役立つように)特定行の現在の内容と、\n現時点における完全修飾された `名前` を表す文字列のリストを指定する必要があります。\nたとえば完全修飾名 `System.Random` という名前を持った識別子 `Random` に対する\nツールチップを取得する場合、 `Random` という文字列が現れる場所の他に、\n`[\"System\"; \"Random\"]` という値を指定する必要があります。\n\n返り値の型は `ToolTipText` で、この型には `ToolTipElement` という\n判別共用体が含まれます。\nこの共用体は、コンパイラによって返されたツールチップの種類に応じて異なります。\n\n### 自動補完リストの取得\n\n次に紹介する `TypeCheckResults` のメソッドを使用すると、\n特定の位置における自動補完機能を実装できます。\nこの機能は任意の識別子上、\nあるいは(特定のスコープ内で利用可能な名前の一覧を取得する場合には)任意のスコープ、\nあるいは特定のオブジェクトにおけるメンバーリストを取得する場合には\n`.` の直後で呼び出すことができます。\n今回は文字列の値 `msg` に対するメンバーリストを取得することにします。\n\nそのためには最終行( `printfn \"%s\" msg.` で終わっている行)にある\nシンボル `.` の位置を指定して `GetDeclarationListInfo` を呼び出します。\nオフセットは1から始まるため、位置は `7, 23` になります。\nまた、テキストが変更されていないことを表す関数と、\n現時点において補完する必要がある識別子を指定する必要もあります。\n*)\n// 特定の位置における宣言(自動補完)を取得する\nlet decls =\n    checkFileResults.GetDeclarationListInfo\n      (Some parseFileResults, 7, inputLines.[6], PartialLongName.Empty 23, (fun _ -> []), fun _ -> false)\n      |> Async.RunSynchronously\n\n// 利用可能な項目を表示\nfor item in decls.Items do\n    printfn \" - %s\" item.Name\n(**\n\n> **注意：** `GetDeclarationListInfo` は古い関数 `GetDeclarations` に代わるものです。\n`GetDeclarations` は0から始まる行番号を受け取るようになっていたため、非推奨になりました。\nまた、将来的には現在の `GetDeclarations` が削除され、 `GetDeclarationListInfo` が\n`GetDeclarations` になる予定です。\n\nコードを実行してみると、 `Substring` や `ToUpper` 、 `ToLower` といった\n文字列に対するいつものメソッドのリストが取得できていることでしょう。\n`GetDeclarations` の5,6番目の引数( `[]` および `\"msg\"` )には\n自動補完用のコンテキストを指定します。\n今回の場合は完全名 `msg` に対する補完を行いましたが、\nたとえば `[\"System\"; \"Collections\"]` と `\"Generic\"` というように\n完全修飾された名前空間を指定して補完リストを取得することもできます。\n\n### 引数の情報を取得する\n\n次に一般的なエディタの機能としては、メソッドのオーバーロードに\n関する情報を提供するというものでしょう。\nサンプルコード中では多数のオーバーロードを持った `String.Concat` を使っています。\nこのオーバーロード一覧は `GetMethods` で取得できます。\n先ほどと同じく、このメソッドには対象とする項目の位置を0基準のオフセットで指定し\n(今回は `String.Concat` 識別子の右側の終端)、\n識別子もやはり指定します\n(これにより、コンパイラはソースコードが変更された場合でも最新の情報に追従できます):\n\n*)\n//String.Concatメソッドのオーバーロードを取得する\nlet methods =\n    checkFileResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n\n// 連結された引数リストを表示\nfor mi in methods.Methods do\n    [ for p in mi.Parameters -> p.Display ]\n    |> String.concat \", \"\n    |> printfn \"%s(%s)\" methods.MethodName\n(**\nここでは `Display` プロパティを使用することで各引数に対する\nアノテーションを取得しています。\nこのプロパティは `arg0: obj` あるいは `params args: obj[]` 、\n`str0: string, str1: string` といった情報を返します。\nこれらの引数を連結した後、メソッド名とメソッドの型情報とともに表示させています。\n*)\n\n(**\n\n## 非同期操作と即時操作\n\n`CheckFileInProject` が非同期操作であることを気にされる人もいるかもしれません。\nこれはつまり、F#コードの型チェックにはある程度時間がかかることを示唆しています。\nF#コンパイラは型チェックを(自動的に)バックグラウンドで処理を進めているため、\n`CheckFileInProject` メソッドを呼び出すと非同期操作が返されることになります。\n\nまた、 `CheckFileInProjectIfReady` というメソッドもあります。\nこのメソッドは、型チェックの操作が即座に開始できない場合、\nつまりプロジェクト内の他のファイルがまだ型チェックされていない場合には\n処理が即座に返されます。\nこの場合、バックグラウンドワーカーは一定期間他の作業を進めるか、\n`FileTypeCheckStateIsDirty` イベントが発生するまでは\nファイルに対する型チェックを諦めるか、どちらか選択することになります。\n\n> [fsharpbinding](https://github.com/fsharp/fsharpbinding) プロジェクトには\n1つのF#エージェント経由ですべてのリクエストをバックグラウンドワークとして\n処理するような、より複雑な具体例も含まれています。\nエディタの機能を実装する方法としてはこちらのほうが適切です。\n\n*)\n\n\n(**\nまとめ\n------\n\n`CheckFileAnswer` にはチュートリアルで紹介していないような便利なメソッドが\n多数揃えられています。\nこれらを使用すれば特定の識別子に対する宣言の位置を取得したり、\n付加的な色情報を取得したりすることができます\n(F# 3.1では式ビルダーの識別子やクエリ演算子も着色表示されます)。\n\n最後に、直接.NET APIを呼び出すことができないようなエディタに対するサポート機能を\n実装する場合、ここで紹介した様々な機能を\n[FSharp.AutoComplete](https://github.com/fsharp/fsharpbinding/tree/master/FSharp.AutoComplete)\nプロジェクトのコマンドラインインターフェイス経由で呼び出すこともできます。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/project.html","title":"プロジェクトの分析","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: プロジェクトの分析\n======================================\n\nこのチュートリアルではF#コンパイラによって提供されるサービスを使用して\nプロジェクト全体を分析する方法について紹介します。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、\n  最新のnugetパッケージの公開に伴って変更されることがあります。\n\n\nプロジェクト全体の結果を取得する\n--------------------------------\n\n[以前の(型無しASTを使った)チュートリアル](untypedtree.html) と同じく、\nまずは `FSharp.Compiler.Service.dll` への参照追加と、適切な名前空間のオープン、\n`FSharpChecker` インスタンスの作成を行います:\n\n*)\n// F#コンパイラAPIへの参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.Collections.Generic\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n今回のサンプル入力は以下の通りです:\n*)\n\nmodule Inputs =\n    open System.IO\n\n    let base1 = Path.GetTempFileName()\n    let fileName1 = Path.ChangeExtension(base1, \".fs\")\n    let base2 = Path.GetTempFileName()\n    let fileName2 = Path.ChangeExtension(base2, \".fs\")\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\n\ntype C() =\n    member x.P = 1\n\nlet xxx = 3 + 4\nlet fff () = xxx + xxx\n    \"\"\"\n    File.WriteAllText(fileName1, fileSource1)\n\n    let fileSource2 = \"\"\"\nmodule N\n\nopen M\n\ntype D1() =\n    member x.SomeProperty = M.xxx\n\ntype D2() =\n    member x.SomeProperty = M.fff()\n\n// 警告を発生させる\nlet y2 = match 1 with 1 -> M.xxx\n    \"\"\"\n    File.WriteAllText(fileName2, fileSource2)\n\n\n(**\n`GetProjectOptionsFromCommandLineArgs` を使用して、\n2つのファイルを1つのプロジェクトとして扱えるようにします:\n*)\n\nlet projectOptions =\n    checker.GetProjectOptionsFromCommandLineArgs\n       (Inputs.projFileName,\n        [| yield \"--simpleresolution\"\n           yield \"--noframework\"\n           yield \"--debug:full\"\n           yield \"--define:DEBUG\"\n           yield \"--optimize-\"\n           yield \"--out:\" + Inputs.dllName\n           yield \"--doc:test.xml\"\n           yield \"--warn:3\"\n           yield \"--fullpaths\"\n           yield \"--flaterrors\"\n           yield \"--target:library\"\n           yield Inputs.fileName1\n           yield Inputs.fileName2\n           let references =\n             [ @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\mscorlib.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.Core.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"]\n           for r in references do\n                 yield \"-r:\" + r |])\n\n(**\nそして(ディスク上に保存されたファイルを使用して)\nプロジェクト全体をチェックします:\n*)\n\nlet wholeProjectResults = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\n(**\n発生したエラーと警告は以下のようにしてチェックできます:\n*)\nwholeProjectResults.Errors.Length // 1\nwholeProjectResults.Errors.[0].Message.Contains(\"Incomplete pattern matches on this expression\") // true\n\nwholeProjectResults.Errors.[0].StartLineAlternate // 13\nwholeProjectResults.Errors.[0].EndLineAlternate // 13\nwholeProjectResults.Errors.[0].StartColumn // 15\nwholeProjectResults.Errors.[0].EndColumn // 16\n\n(**\n推測されたプロジェクトのシグネチャをチェックします:\n*)\n[ for x in wholeProjectResults.AssemblySignature.Entities -> x.DisplayName ] // [\"N\"; \"M\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].NestedEntities -> x.DisplayName ] // [\"D1\"; \"D2\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[1].NestedEntities -> x.DisplayName ] // [\"C\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].MembersFunctionsAndValues -> x.DisplayName ] // [\"y2\"]\n\n(**\nプロジェクト内の全シンボルを取得することもできます:\n*)\nlet rec allSymbolsInEntities (entities: IList<FSharpEntity>) =\n    [ for e in entities do\n          yield (e :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             yield (x :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n          for x in e.FSharpFields do\n             yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities e.NestedEntities ]\n\nlet allSymbols = allSymbolsInEntities wholeProjectResults.AssemblySignature.Entities\n(**\nプロジェクト全体のチェックが完了した後は、\nプロジェクト内の各ファイルに対する個別の結果を取得することもできます。\nこの処理は即座に完了し、改めてチェックが実行されることもありません。\n*)\n\nlet backgroundParseResults1, backgroundTypedParse1 =\n    checker.GetBackgroundCheckResultsForFileInProject(Inputs.fileName1, projectOptions)\n    |> Async.RunSynchronously\n\n\n(**\nそしてそれぞれのファイル内にあるシンボルを解決できます:\n*)\n\nlet xSymbol =\n    backgroundTypedParse1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\n(**\nそれぞれのシンボルに対して、シンボルへの参照を検索することもできます:\n*)\nlet usesOfXSymbol = wholeProjectResults.GetUsesOfSymbol(xSymbol.Value.Symbol)\n\n(**\n推測されたシグネチャ内にあるすべての定義済みシンボルに対して、\nそれらがどこで使用されているのかを探し出すこともできます:\n*)\nlet allUsesOfAllSignatureSymbols =\n    [ for s in allSymbols do\n         yield s.ToString(), wholeProjectResults.GetUsesOfSymbol(s) ]\n\n(**\n(ローカルスコープで使用されているものも含めて)\nプロジェクト全体で使用されているすべてのシンボルを確認することもできます：\n*)\nlet allUsesOfAllSymbols = wholeProjectResults.GetAllUsesOfAllSymbols()\n\n(**\nまた、プロジェクト内のファイルに対して、更新後のバージョンに対して\nチェックを実行するようにリクエストすることもできます\n(なお [FileSystem API](filesystem.html) を使用していない場合には、\nプロジェクト内のその他のファイルがまだディスクから\n読み取り中であることに注意してください):\n\n*)\nlet parseResults1, checkAnswer1 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName1, 0, Inputs.fileSource1, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults1 =\n    match checkAnswer1 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"想定外の終了状態です\"\n\nlet parseResults2, checkAnswer2 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName2, 0, Inputs.fileSource2, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults2 =\n    match checkAnswer2 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"想定外の終了状態です\"\n\n(**\nそして再びシンボルを解決したり、参照を検索したりすることができます:\n*)\n\nlet xSymbol2 =\n    checkResults1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet usesOfXSymbol2 = wholeProjectResults.GetUsesOfSymbol(xSymbol2.Value.Symbol)\n\n(**\nあるいは(ローカルスコープで使用されているシンボルも含めて)\nファイル中で使用されているすべてのシンボルを検索することもできます：\n*)\nlet allUsesOfAllSymbolsInFile1 = checkResults1.GetAllUsesOfAllSymbolsInFile()\n\n(**\nあるいは特定のファイル中で使用されているシンボルを検索することもできます：\n*)\nlet allUsesOfXSymbolInFile1 = checkResults1.GetUsesOfSymbolInFile(xSymbol2.Value.Symbol)\n\nlet allUsesOfXSymbolInFile2 = checkResults2.GetUsesOfSymbolInFile(xSymbol2.Value.Symbol)\n\n(**\n\n複数プロジェクトの分析\n----------------------\n\n複数のプロジェクトにまたがった参照があるような、\n複数のF# プロジェクトを分析したい場合、\nそれらのプロジェクトを一旦ビルドして、\nProjectOptionsで `-r:プロジェクト-出力-までの-パス.dll` 引数を指定して\nプロジェクトの相互参照を設定すると一番簡単です。\nしかしこの場合、それぞれのプロジェクトが正しくビルド出来、\nDLLファイルが参照可能なディスク上に生成されなければいけません。\n\nたとえばIDEを操作している場合など、状況によっては\nDLLのコンパイルが通るようになる前に\nプロジェクトを参照したいことがあるでしょう。\nこの場合はProjectOptionsのReferencedProjectsを設定します。\nこの値には依存するプロジェクトのオプションを再帰的に指定します。\nそれぞれのプロジェクト参照にはやはり、\nReferencedProjectsのエントリそれぞれに対応する\n`-r:プロジェクト-出力-までの-パス.dll` というコマンドライン引数を\nProjectOptionsに設定する必要があります。\n\nプロジェクト参照が設定されると、ソースファイルからのF#プロジェクト分析処理が\nインクリメンタル分析の結果を使用して行われるようになります。\nその際にはソースファイルファイルをDLLへとコンパイルする必要はありません。\n\n相互参照を含むようなF#プロジェクトを効率よく分析するには、\nReferencedProjectsを正しく設定した後、\nそれぞれのプロジェクトを順番通りに分析していくとよいでしょう。\n\n> **注意：** プロジェクトの参照機能は試作段階です。\n  プロジェクトの参照を使用すると、依存先のプロジェクトがまだ分析中で、\n  要求したサービスがまだ利用できないことがあるため、\n  コンパイラサービスの性能が低下することがあります。\n\n> **注意：** アセンブリが型プロバイダーのコンポーネントを含む場合、\n  プロジェクト参照機能は利用できません。\n  プロジェクトの分析処理を強制しない限りはプロジェクト参照を設定しても\n  効果がありません。\n  また、分析を強制する場合にはディスク上にDLLが存在しなければいけません。\n\n*)\n\n(**\nまとめ\n------\n\nこれまで説明してきた通り、 `ParseAndCheckProject` を使用すると\nシンボルの参照などのようなプロジェクト全体の解析結果にアクセスできるようになります。\nシンボルに対する処理の詳細については [シンボル](symbols.html) のページを参照してください。\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/tokenizer.html","title":"F#トークナイザを使用する","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス：F#トークナイザを使用する\n============================================\n\nこのチュートリアルではF#言語トークナイザの呼び出し方を紹介します。\nF#のソースコードに対して、トークナイザは\nコードの各行にあるトークンに関する情報を含んだソースコード行のリストを生成します。\n各トークンに対してはトークンの種類や位置を取得したり、\nトークンの種類(キーワード、識別子、数値、演算子など)に応じた\n色を取得したりすることができます。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\nトークナイザの作成\n------------------\n\nトークナイザを使用するには、 `FSharp.Compiler.Service.dll` への参照を追加した後に\n`SourceCodeServices` 名前空間をオープンします：\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\n(**\nすると `FSharpSourceTokenizer` のインスタンスを作成できるようになります。\nこのクラスには2つの引数を指定します。\n最初の引数には定義済みのシンボルのリスト、\n2番目の引数にはソースコードのファイル名を指定します。\n定義済みのシンボルのリストを指定するのは、\nトークナイザが `#if` ディレクティブを処理する必要があるからです。\nファイル名はソースコードの位置を特定する場合にのみ指定する必要があります\n(存在しないファイル名でも指定できます):\n*)\nlet sourceTok = FSharpSourceTokenizer([], \"C:\\\\test.fsx\")\n(**\n`sourceTok` オブジェクトを使用することでF#ソースコードの各行を\n(繰り返し)トークン化することができます。\n\nF#コードのトークン化\n--------------------\n\nトークナイザはソースファイル全体ではなく、行単位で処理を行います。\nトークンを取得した後、トークナイザは新しいステートを( `int64` 値として)返します。\nこの値を使うとF#コードをより効率的にトークン化できます。\nつまり、ソースコードが変更された場合もファイル全体を\n再度トークン化する必要はありません。\n変更された部分だけをトークン化すればよいのです。\n\n### 1行をトークン化する\n\n1行をトークン化するには、先ほど作成した `FSharpSourceTokenizer` オブジェクトに対して\n`CreateLineTokenizer` を呼び、 `FSharpLineTokenizer` を作成します:\n*)\nlet tokenizer = sourceTok.CreateLineTokenizer(\"let answer=42\")\n(**\nそして `tokenizer` の `ScanToken` を繰り返し `None` を返すまで\n(つまり最終行に到達するまで)繰り返し呼び出すような単純な再帰関数を用意します。\nこの関数が成功すると、必要な詳細情報をすべて含んだ `FSharpTokenInfo` オブジェクトが\n返されます:\n*)\n/// F#コード1行をトークン化します\nlet rec tokenizeLine (tokenizer:FSharpLineTokenizer) state =\n  match tokenizer.ScanToken(state) with\n  | Some tok, state ->\n      // トークン名を表示\n      printf \"%s \" tok.TokenName\n      // 新しい状態で残りをトークン化\n      tokenizeLine tokenizer state\n  | None, state -> state\n(**\nこの関数は、複数行コードや複数行コメント内の前方の行をトークン化する場合に\n必要となるような新しい状態を返します。\n初期値としては `0L` を指定します:\n*)\ntokenizeLine tokenizer FSharpTokenizerLexState.Initial\n(**\nこの結果は LET WHITESPACE IDENT EQUALS INT32 という\nトークン名のシーケンスになります。\n`FSharpTokenInfo` にはたとえば以下のような興味深いプロパティが多数あります:\n\n - `CharClass` および `ColorClass` はF#コードを色づけする場合に使用できるような、\n   トークンのカテゴリに関する情報を返します。\n - `LeftColumn` および `RightColumn` は行内におけるトークンの位置を返します。\n - `TokenName` は(F# レキサ内で定義された)トークンの名前を返します。\n\nなおトークナイザはステートフルであることに注意してください。\nつまり、1行を複数回トークン化したい場合にはその都度 `CreateLineTokenizer` を\n呼び出す必要があります。\n\n### サンプルコードのトークン化\n\nトークナイザをもっと長いサンプルコードやファイル全体に対して実行する場合、\nサンプル入力を `string` のコレクションとして読み取る必要があります:\n*)\nlet lines = \"\"\"\n  // Hello world\n  let hello() =\n     printfn \"Hello world!\" \"\"\".Split('\\r','\\n')\n(**\n複数行の入力値をトークン化する場合も、現在の状態を保持するような\n再帰関数が必要になります。\n以下の関数はソースコード行を文字列のリストとして受け取ります\n(また、行番号および現在の状態も受け取ります)。\n各行に対して新しいトークナイザを作成して、\n直前の行における **最後** の状態を使って `tokenizeLine` を呼び出します:\n*)\n/// 複数行のコードに対してトークンの名前を表示します\nlet rec tokenizeLines state count lines =\n  match lines with\n  | line::lines ->\n      // トークナイザを作成して1行をトークン化\n      printfn \"\\nLine %d\" count\n      let tokenizer = sourceTok.CreateLineTokenizer(line)\n      let state = tokenizeLine tokenizer state\n      // 新しい状態を使って残りをトークン化\n      tokenizeLines state (count+1) lines\n  | [] -> ()\n(**\nここでは単に(先ほど定義した) `tokenizeLine` を呼び出して、\n各行にあるすべてのトークンの名前を表示しています。\nこの関数は先と同じく、初期状態の値 `0L` と、1行目を表す `1` を\n指定して呼び出すことができます:\n*)\nlines\n|> List.ofSeq\n|> tokenizeLines FSharpTokenizerLexState.Initial 1\n(**\n重要ではない部分(各行の先頭にある空白文字や、1行目のように空白文字しかない行)\nを除けば、このコードを実行すると以下のような出力になります:\n\n    [lang=text]\n    Line 1\n      LINE_COMMENT LINE_COMMENT (...) LINE_COMMENT\n    Line 2\n      LET WHITESPACE IDENT LPAREN RPAREN WHITESPACE EQUALS\n    Line 3\n      IDENT WHITESPACE STRING_TEXT (...) STRING_TEXT STRING\n\n注目すべきは、単一行コメントや文字列に対して、\nトークナイザが複数回(大まかにいって単語単位で) `LINE_COMMENT` や\n`STRING_TEXT` を返しているところです。\nしたがって、コメントや文字列全体をテキストとして取得したい場合には\nそれぞれのトークンを連結する必要があります。\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/untypedtree.html","title":"型無し構文木の処理","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス：型無し構文木の処理\n======================================\n\nこのチュートリアルではF#コードに対する型無し抽象構文木\n(untyped abstract syntax tree: untyped AST)\nを取得する方法、および木全体を走査する方法を紹介します。\nこの処理を行うことによって、コードフォーマットツールや\n基本的なリファクタリングツール、コードナビゲーションツールなどを作成できます。\n型無し構文木にはコードの構造に関する情報が含まれていますが、\n型情報が含まれていないだけでなく、後で型チェッカーを通すまでは\n解決されないような曖昧さも残されています。\nまた、 [エディタサービス](editor.html) として提供されているAPIと\n型無しASTの情報を組み合わせることもできます。\n\n> **注釈:** 以下で使用しているAPIは試験的なもので、将来的に変更される場合があります。\n  つまりFSharp.Compiler.Service.dll には既存のものと重複する機能が多数あるため、\n  将来的にはもっときちんとした形に変更されます。\n  そのため、これらのサービスを使用するAPIには破壊的変更が加えられる可能性があります。\n\n\n型無しASTの取得\n---------------\n\n\n型無しASTにアクセスするには、 `FSharpChecker` のインスタンスを作成します。\nこれは型チェックおよびパース用のコンテキストを表す型で、、\nスタンドアロンのF#スクリプトファイル(たとえばVisual Studioで開いたファイル)、\nあるいは複数ファイルで構成されたロード済みのプロジェクトファイルの\nいずれかと結びつきます。\nこのインスタンスを作成すると、型チェックの最初のステップである\n「型無しパース」を実行できます。\n次のフェーズは「型有りパース」で、これは [エディタサービス](editor.html) で\n使用されるものです。\n\nインタラクティブチェッカーを使用するには、\n`FSharp.Compiler.Service.dll` への参照を追加した後、\n`SourceCodeServices` 名前空間をオープンします：\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen FSharp.Compiler.SourceCodeServices\n(**\n\n### 型無しパースの実行\n\n型無しパース処理は(それなりの時間がかかる型チェック処理と比較すると)\nかなり高速なため、同期的に実行できます。\nまず `FSharpChecker` を作成します。\n\n*)\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n(**\n\nASTを取得するために、ファイル名とソースコードを受け取る関数を用意します\n(ファイル名は位置情報のためだけに使用されるもので、存在しなくても構いません)。\nまず、コンテキストを表す「インタラクティブチェッカーオプション」を\n用意する必要があります。\n単純な処理に対しては、 `GetCheckOptionsFromScriptRoot` を使えば\nスクリプトファイルのコンテキストを推測させることができます。\nそして `UntypedParse` メソッドを呼び出した後、\n`ParseTree` プロパティの値を返します:\n\n*)\n/// 特定の入力に対する型無し構文木を取得する\nlet getUntypedTree (file, input) =\n  // 1つのスクリプトファイルから推測される「プロジェクト」用の\n  // コンパイラオプションを取得する\n  let projOptions, errors =\n      checker.GetProjectOptionsFromScript(file, input)\n      |> Async.RunSynchronously\n\n  let parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projectOptions)\n\n  // コンパイラの第1フェーズを実行する\n  let untypedRes =\n      checker.ParseFile(file, input, parsingOptions)\n      |> Async.RunSynchronously\n\n  match untypedRes.ParseTree with\n  | Some tree -> tree\n  | None -> failwith \"パース中に何らかの問題が発生しました!\"\n\n(**\n`FSharpChecker` の詳細については\n[ APIドキュメント](../reference/microsoft-fsharp-compiler-sourcecodeservices-FSharpChecker.html)\nの他に、F# ソースコードのインラインコメントも参考になるでしょう\n( [`service.fsi` のソースコードを参照](https://github.com/fsharp/fsharp/blob/fsharp_31/src/fsharp/service/service.fsi) )。\n\nASTの走査\n---------\n\n抽象構文木は(式やパターン、宣言など)それぞれ異なる文法的要素を表現する、\n多数の判別共用体として定義されています。\nASTを理解するには\n[`ast.fs`内にあるソースコード](https://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs#L464)\nの定義を確認する方法が一番よいでしょう。\n\nASTに関連する要素は以下の名前空間に含まれています:\n*)\nopen FSharp.Compiler.Ast\n(**\n\nASTを処理する場合、異なる文法的要素に対するパターンマッチを行うような\n相互再帰関数を多数用意することになります。\nサポートすべき要素は非常に多種多様です。\nたとえばトップレベル要素としてはモジュールや名前空間の宣言、\nモジュール内における(letバインディングや型などの)宣言などがあります。\nモジュール内のlet宣言には式が含まれ、さらにこの式に\nパターンが含まれていることもあります。\n\n### パターンと式を走査する\n\nまずは式とパターンを走査する関数から始めます。\nこの関数は要素を走査しつつ、要素に関する情報を画面に表示します。\nパターンの場合、入力は `SynPat` 型であり、この型には `Wild` ( `_` パターンを表す)や\n`Named` ( `<pat> という名前` のパターン)、\n`LongIdent` ( `Foo.Bar` 形式の名前)など、多数のケースがあります。\nなお、基本的にパース後のパターンは元のソースコードの見た目よりも複雑になります\n(具体的には `Named` がかなり多数現れます):\n*)\n/// パターンの走査\n/// これは let <pat> = <expr> あるいは 'match' 式に対する例です\nlet rec visitPattern = function\n  | SynPat.Wild(_) ->\n      printfn \"  .. アンダースコアパターン\"\n  | SynPat.Named(pat, name, _, _, _) ->\n      visitPattern pat\n      printfn \"  .. 名前 '%s' のパターン\" name.idText\n  | SynPat.LongIdent(LongIdentWithDots(ident, _), _, _, _, _, _) ->\n      let names = String.concat \".\" [ for i in ident -> i.idText ]\n      printfn \"  .. 識別子: %s\" names\n  | pat -> printfn \"  .. その他のパターン: %A\" pat\n(**\nこの関数は (`bar という名前の (foo, _)` のような、\nネストされたパターンに対応するために) 再帰関数になっていますが、\n以降で定義するいずれの関数も呼び出しません\n(パターンはその他の文法的な要素を含むことができないからです)。\n\n次の関数は式全体を走査するものです。\nこれは処理の大部分が行われる関数で、\n20以上のケースをカバーすることになるでしょう\n( `SynExpr` と入力するとその他のオプションが確認できます)。\n以下のコードでは `if .. then ..` と `let .. = ...` という式を\n処理する方法だけを紹介しています:\n*)\n/// 式を走査する。\n/// 式に2つあるいは3つの部分式が含まれていた場合('else'の分岐がない場合は2つ)、\n/// let式にはパターンおよび2つの部分式が含まれる\nlet rec visitExpression = function\n  | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n      // すべての部分式を走査\n      printfn \"条件部:\"\n      visitExpression cond\n      visitExpression trueBranch\n      falseBranchOpt |> Option.iter visitExpression\n\n  | SynExpr.LetOrUse(_, _, bindings, body, _) ->\n      // バインディングを走査\n      // ('let .. = .. and .. = .. in ...' に対しては複数回走査されることがある)\n      printfn \"以下のバインディングを含むLetOrUse:\"\n      for binding in bindings do\n        let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                     data, pat, retInfo, init, m, sp)) = binding\n        visitPattern pat\n        visitExpression init\n      // 本体の式を走査\n      printfn \"本体は以下:\"\n      visitExpression body\n  | expr -> printfn \" - サポート対象外の式: %A\" expr\n(**\n`visitExpression` 関数はモジュール内のすべてのトップレベル宣言を走査するような\n関数から呼ばれることになります。\n今回のチュートリアルでは型やメンバーを無視していますが、\nこれらを走査する場合も `visitExpression` を呼び出すことになるでしょう。\n\n### 宣言を走査する\n\n既に説明したように、1つのファイルに対するASTには多数のモジュールや\n名前空間の宣言が(トップレベルノードとして)含まれ、\nモジュール内にも(letバインディングや型の)宣言が、\n名前空間にも(こちらは単に型だけの)宣言が含まれます。\n以下の関数はそれぞれの宣言を走査します。\nただし今回は型やネストされたモジュール、その他の要素については無視して、\nトップレベルの(値および関数に対する) `let` バインディングだけを対象にしています:\n*)\n/// モジュール内の宣言リストを走査する。\n/// モジュール内のトップレベルに記述できるすべての要素\n/// (letバインディングやネストされたモジュール、型の宣言など)が対象になる。\nlet visitDeclarations decls =\n  for declaration in decls do\n    match declaration with\n    | SynModuleDecl.Let(isRec, bindings, range) ->\n        // 宣言としてのletバインディングは\n        // (visitExpressionで処理したような)式としてのletバインディングと\n        // 似ているが、本体を持たない\n        for binding in bindings do\n          let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                       data, pat, retInfo, body, m, sp)) = binding\n          visitPattern pat\n          visitExpression body\n    | _ -> printfn \" - サポート対象外の宣言: %A\" declaration\n(**\n`visitDeclarations` 関数はモジュールや名前空間の宣言のシーケンスを走査する\n関数から呼ばれることになります。\nこのシーケンスはたとえば複数の `namespace Foo` 宣言を含むようなファイルに対応します:\n*)\n/// すべてのモジュールや名前空間の宣言を走査する\n/// (基本的には 'module Foo =' または 'namespace Foo.Bar' というコード)\n/// なおファイル中で明示的に定義されていない場合であっても\n/// 暗黙的にモジュールまたは名前空間の宣言が存在することに注意。\nlet visitModulesAndNamespaces modulesOrNss =\n  for moduleOrNs in modulesOrNss do\n    let (SynModuleOrNamespace(lid, isRec, isMod, decls, xml, attrs, _, m)) = moduleOrNs\n    printfn \"名前空間またはモジュール: %A\" lid\n    visitDeclarations decls\n(**\n以上でASTの要素を(宣言から始まって式やパターンに至るまで)走査するための\n関数がそろったので、サンプル入力からASTを取得した後、\n上記の関数を実行することができるようになりました。\n\nすべてを組み合わせる\n--------------------\n\n既に説明したように、 `getUntypedTree` 関数では `FSharpChecker` を使って\nASTに対する第1フェーズ(パース)を行ってツリーを返しています。\nこの関数にはF#のソースコードとともに、ファイルのパスを指定する必要があります。\n(単に位置情報として利用されるだけなので)\n指定先のパスにファイルが存在している必要はなく、\nUnixとWindowsどちらの形式でも指定できます:\n*)\n// コンパイラサービスへのサンプル入力\nlet input = \"\"\"\n  let foo() =\n    let msg = \"Hello world\"\n    if true then\n      printfn \"%s\" msg \"\"\"\n// Unix形式のファイル名\nlet file = \"/home/user/Test.fsx\"\n\n// サンプルF#コードに対するASTを取得\nlet tree = getUntypedTree(file, input)\n(**\nこのコードをF# Interactiveで実行した場合、コンソールに `tree;;` と入力すると、\nデータ構造に対する文字列表現が表示されることが確認できます。\nツリーには大量の情報が含まれているため、あまり読みやすいものではありませんが、\n木が動作する様子を想像することはできるでしょう。\n\n`tree` の返値はやはり判別共用体で、2つのケースに分かれます。\n1つはF#のシグネチャファイル( `*.fsi` )を表す `ParsedInput.SigFile` で、\nもう1つは通常のソースコード( `*.fsx` または `*.fs` )を表す\n`ParsedInput.ImplFile` です。\n上記の手順で作成した関数に渡すことができるモジュールや名前空間のシーケンスは\n実装ファイルに含まれています:\n*)\n// 実装ファイルの詳細をチェックする\nmatch tree with\n| ParsedInput.ImplFile(implFile) ->\n    // 宣言を展開してそれぞれを走査する\n    let (ParsedImplFileInput(fn, script, name, _, _, modules, _)) = implFile\n    visitModulesAndNamespaces modules\n| _ -> failwith \"F# インターフェイスファイル (*.fsi) は未サポートです。\"\n(**\nまとめ\n------\nこのチュートリアルでは型無し抽象構文木に対する基本的な走査方法を紹介しました。\nこのトピックは包括的なものであるため、1つの記事ですべてを説明することは不可能です。\nさらに深く理解するためには、型無しASTを活用するツールのよい例として\n[Fantomas project](https://github.com/dungpa/fantomas) を参考にするとよいでしょう。\n実際には今回参照したような情報と、次のチュートリアルで説明する\n[エディタサービス](editor.html) から得られる情報とを\n組み合わせて利用することになるでしょう。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/compiler.html","title":"コンパイラの組み込み","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラの組み込み\n====================\n\nこのチュートリアルではF#コンパイラをホストする方法を紹介します。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\n> **注意:** F#コンパイラをホストする方法はいくつかあります。\n  一番簡単な方法は `fsc.exe` のプロセスを使って引数を渡す方法です。\n\n---------------------------\n\nまず、F# Interactiveサービスを含むライブラリへの参照を追加します:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen System.IO\n\nlet scs = FSharpChecker.Create()\n\n(**\n次に、一時ファイルへコンテンツを書き込みます:\n\n*)\nlet fn = Path.GetTempFileName()\nlet fn2 = Path.ChangeExtension(fn, \".fs\")\nlet fn3 = Path.ChangeExtension(fn, \".dll\")\n\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\ntype C() =\n   member x.P = 1\n\nlet x = 3 + 4\n\"\"\")\n\n(**\nそしてコンパイラを呼び出します:\n*)\n\nlet errors1, exitCode1 = scs.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |]) |> Async.RunSynchronously\n\n(**\n\nエラーが発生した場合は「終了コード」とエラーの配列から原因を特定できます:\n\n*)\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\nlet x = 1.0 + \"\" // a type error\n\"\"\")\n\nlet errors1b, exitCode1b = scs.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |]) |> Async.RunSynchronously\n\nif exitCode1b <> 0 then\n    errors1b\n    |> Array.iter (printfn \"%A\")\n\n(**\n\n動的アセンブリへのコンパイル\n============================\n\nコードを動的アセンブリとしてコンパイルすることもできます。\n動的アセンブリはF# Interactiveコードジェネレータでも使用されています。\n\nこの機能はたとえばファイルシステムが必ずしも利用できないような状況で役に立ちます。\n\n出力ファイルの名前を指定する \"-o\" オプションを指定することは可能ですが、\n実際には出力ファイルがディスク上に書き込まれることはありません。\n\n'execute' 引数に 'None' を指定するとアセンブリ用の初期化コードが実行されません。\n*)\nlet errors2, exitCode2, dynAssembly2 =\n    scs.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], execute=None) |> Async.RunSynchronously\n\n(**\n'Some' を指定するとアセンブリ用の初期化コードが実行されます。\n*)\nlet errors3, exitCode3, dynAssembly3 =\n    scs.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], Some(stdout,stderr)) |> Async.RunSynchronously\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/devnotes.html","title":"Developer Notes","content":"\nDeveloper notes\n===============\n\nModified clone of F# compiler exposing additional functionality for editing clients and embedding F# compiler\nand F# interactive as services.\n\n## Components\n\nThere is one main component, `FSharp.Compiler.Service.dll`.\nThe main aim is to have a stable and documented fork of the main compiler that allows various\ntools to share this common code.\nThis component allows embedding F# Interactive as a service and contains a number of\nmodifications to the source code of `fsi.exe` that adds `EvalExpression` and `EvalInteraction` functions.\n\nThis repo should be _identical_ to 'fsharp' except:\n\n  - Changes for building `FSharp.Compiler.Service.dll`, notably\n    - Change the assembly name\n    - Only build `FSharp.Compiler.Service.dll`\n    - No bootstrap or proto compiler is used - an installed F# compiler is assumed\n\n  - Build script using FAKE that builds everything, produces NuGet package and\n    generates documentation, files for publishing NuGet packages etc.\n    (following [F# project scaffold](https://github.com/fsprojects/FSharp.ProjectScaffold))\n\n  - Changes to compiler source code to expose new functionality; Changes to the\n    F# Interactive service to implement the evaluation functions.\n\n  - Additions to compiler source code which improve the API for the use of F# editing clients\n\n  - Additions to compiler source code which add new functionality to the compiler service API\n\nIf language or compiler additions are committed to `fsharp/fsharp`, they should be merged into\nthis repo and a new NuGet package released.\n\n## Building and NuGet\n\nThe build process follows the standard recommended by [F# project scaffold](https://github.com/fsprojects/FSharp.ProjectScaffold)\nIf you want to build the project yourself then you can follow these instructions:\n\n    [lang=text]\n    git clone https://github.com/fsharp/FSharp.Compiler.Service\n    cd FSharp.Compiler.Service\n\nNow follow build everything by running `build.cmd` (Windows) or `build.sh` (Linux + Mac OS).\nThe output will be located in the `bin` directory. If you also wish to build the documentation\nand NuGet package, run `build Release` (this also attempts to publish the documentation to\nGitHub, which only works if you have access to the GitHub repository).\n\n## Release checklist\n\nRelease checklist to publish a new version on nuget.org\n\n1. Update `RELEASE_NOTES.md`\n2. Check the version numbers are correct across the source (some files duplicate them)\n3. Commit and add the necessary tag to the repo\n4. Publish the nupkgs for `FSharp.Compiler.Service` once it appears in AppVeyor artifacts\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/index.html","title":"F# Compiler Services","content":"\nF# Compiler Services\n====================\n\nThe F# compiler services package is a component derived from the F# compiler source code that\nexposes additional functionality for implementing F# language bindings, additional\ntools based on the compiler or refactoring tools. The package also includes F#\ninteractive service that can be used for embedding F# scripting into your applications.\n\n<div class=\"row\">\n  <div class=\"span1\"></div>\n  <div class=\"span6\">\n    <div class=\"well well-small\" id=\"nuget\">\n      The F# Compiler Services package can be <a href=\"https://nuget.org/packages/FSharp.Compiler.Service\">installed from NuGet</a>:\n      <pre>PM> Install-Package FSharp.Compiler.Service</pre>\n    </div>\n  </div>\n  <div class=\"span1\"></div>\n</div>\n\nAvailable services\n------------------\n\nThe project currently exposes the following services that are tested & documented on this page.\nThe libraries contain additional public API that can be used, but is not documented here.\n\n* [**F# Language tokenizer**](tokenizer.html) - turns any F# source code into a stream of tokens.\n  Useful for implementing source code colorization and basic tools. Correctly handle nested\n  comments, strings etc.\n\n* [**Processing untyped AST**](untypedtree.html) - allows accessing the untyped abstract syntax tree (AST).\n  This represents parsed F# syntax without type information and can be used to implement code formatting\n  and various simple processing tasks.\n\n* [**Using editor (IDE) services**](editor.html) - expose functionality for auto-completion, tool-tips,\n  parameter information etc. These functions are useful for implementing F# support for editors\n  and for getting some type information for F# code.\n\n* [**Working with signatures, types, and resolved symbols**](symbols.html) - many services related to type checking\n  return resolved symbols, representing inferred types, and the signatures of whole assemblies.\n\n* [**Working with resolved expressions**](typedtree.html) - services related to working with\n  type-checked expressions and declarations, where names have been resolved to symbols.\n\n* [**Working with projects and project-wide analysis**](project.html) - you can request a check of\n  an entire project, and ask for the results of whole-project analyses such as find-all-references.\n\n* [**Hosting F# interactive**](interactive.html) - allows calling F# interactive as a .NET library\n  from your .NET code. You can use this API to embed F# as a scripting language in your projects.\n\n* [**Hosting the F# compiler**](compiler.html) - allows you to embed calls to the F# compiler.\n\n* [**File system API**](filesystem.html) - the `FSharp.Compiler.Service` component has a global variable\n  representing the file system. By setting this variable you can host the compiler in situations where a file system\n  is not available.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\nProjects using the F# Compiler Services\n------------------\n\nSome of the projects using the F# Compiler Services are:\n\n* [**The Visual F# Power Tools**](https://fsprojects.github.io/VisualFSharpPowerTools/)\n* [**The Xamarin and MonoDevelop Tools for F#**](https://github.com/mono/monodevelop/tree/master/main/external/fsharpbinding)\n* [**The Emacs Plugin for F#**](https://github.com/fsharp/emacs-fsharp-mode)\n* [**The Vim Plugin for F#**](https://github.com/fsharp/vim-fsharp)\n* [**F# language support for JetBrains Rider**](https://github.com/JetBrains/fsharp-support/)\n* [**iFSharp**](https://github.com/BayardRock/IfSharp)  - iPython-style notebook engine for F#\n* [**CloudSharper**](https://cloudsharper.com/) - Online web and mobile programming with big data and charting\n* [**Tsunami**](http://tsunami.io) - Tsunami enhances applications and workflows with the power of Type Safe Scripting\n* [**FQuake3**](https://github.com/TIHan/FQuake3/)  - integrates F# as an interactive game scripting engine\n* [**FCell**](http://fcell.io) - Deliver the power of .NET from within Microsoft Excel\n* [**FSharpLint**](https://fsprojects.github.io/FSharpLint/) - Lint tool for F#\n* [**FsReveal**](https://fsprojects.github.io/FsReveal/) - FsReveal parses markdown and F# script file and generate reveal.js slides\n* [**Elucidate**](https://github.com/rookboom/Elucidate) - Visual Studio extension for rich inlined comments using MarkDown\n* [**Fable**](https://fable-compiler.github.io/) - F# to JavaScript Compiler\n* [**FSharp.Formatting**](http://tpetricek.github.io/FSharp.Formatting/) - F# tools for generating documentation (Markdown processor and F# code formatter)\n* [**FAKE**](https://fsharp.github.io/FAKE/) - \"FAKE - F# Make\" is a cross platform build automation system\n* [**FsLab Journal**](https://visualstudiogallery.msdn.microsoft.com/45373b36-2a4c-4b6a-b427-93c7a8effddb) - Template that makes it easy to do interactive data analysis using F# Interactive and produce nice HTML reports of your work\n* [**FarNet.FSharpFar**](https://github.com/nightroman/FarNet/tree/master/FSharpFar) - F# scripting and interactive services in Far Manager\n\nContributing and copyright\n--------------------------\n\nThis project is a fork of the [fsharp/fsharp](https://github.com/fsharp/fsharp) which has been\nmodified to expose additional internals useful for creating editors and F# tools and also for\nembedding F# interactive.\n\nThe F# source code is copyright by Microsoft Corporation and contributors, the extensions have been\nimplemented by Dave Thomas, Anh-Dung Phan, Tomas Petricek and other contributors.\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/devnotes.html","title":"開発者用メモ","content":"\n\n開発者用メモ\n============\n\nF#コンパイラの修正版クローンではクライアントの編集機能やF#コンパイラの埋め込み、\nF# Interactiveをサービスとして動作させるための機能が追加されています。\n\n## コンポーネント\n\nまず `FSharp.Compiler.Service.dll` というコンポーネントがあります。\nこのコンポーネントにはリファクタリングやその他の編集ツールが完全なF# ASTやパーサ機能を利用できるように\n可視性を変更するというマイナーな変更だけが加えられています。\n主な狙いとしては、メインコンパイラの安定版かつドキュメントが備えられたフォークを用意することにより、\nこのコンポーネントにある共通コードを様々なツールで共有できるようにすることです。\n\n2つ目のコンポーネントはF# Interactiveをサービスとして組み込めるようにするためのもので、\n`fsi.exe` のソースコードに多数の変更が加えられており、\n`EvalExpression` や `EvalInteraction` といった関数が追加されています。\n\nこのレポジトリは以下の点を除けば 'fsharp' と **同一** です:\n\n  - `FSharp.Compiler.Service.dll` のビルド、特に以下の点に関する変更:\n    - アセンブリ名の変更\n    - `FSharp.Compiler.Service.dll` のみビルドされる\n    - ブートストラッパーやプロトコンパイラを使用しない。\n      F#コンパイラがインストール済みであることを想定。\n\n  - FAKEを使用するビルドスクリプト。\n    すべてのコードのビルドとNuGetパッケージ、ドキュメントの生成、\n    NuGetパッケージの配布に必要なファイルの生成などがFAKEによって行われる。\n    ([F# プロジェクト スキャフォールド](https://github.com/fsprojects/FSharp.ProjectScaffold) に準拠)\n\n  - 新機能追加のためにコンパイラのソースコードを変更。\n    また、評価用関数を実装するためにF# Interactiveサービスに対する変更を追加。\n\n  - F#編集用クライアントで使用されるAPIを改善するためにコンパイラのソースコードを変更。\n\n  - コンパイラサービスAPIに新機能を追加するためにコンパイラのソースコードを変更。\n\n`fsharp/fsharp` のレポジトリに言語あるいはコンパイラが追加コミットされた場合、\nそれらはこのレポジトリにもマージされるべきで、同時に新しいNuGetパッケージもリリースする必要があります。\n\n## ビルドとNuGet\n\nビルドの手順は [F# プロジェクト スキャフォールド](https://github.com/fsprojects/FSharp.ProjectScaffold)\nで推奨されているものに準じます。\nプロジェクトを独自にビルドする場合、以下の手順に従ってください:\n\n    [lang=text]\n    git clone https://github.com/fsharp/FSharp.Compiler.Service\n    cd FSharp.Compiler.Service\n\n次に、(Windowsであれば) `build.cmd` または(LinuxやMac OSであれば) `build.sh` を実行してすべてをビルドします。\nファイルは `bin` ディレクトリ内に出力されます。\nドキュメントやNuGetパッケージもビルドしたい場合には `build Release` を実行します\n(このコマンドはGitHub上のドキュメントを更新しようとしますが、GitHubのレポジトリに適切な権限を持っている場合にのみ有効です)。\n\n## クライアント\n\nこのコンポーネントは以下のようなツールで使用されています:\n\n * [Fantomas](https://github.com/dungpa/fantomas) - F# コードフォーマットツール\n * [Fsharp-Refactor](https://github.com/Lewix/fsharp-refactor) - F#用リファクタリングツール\n * [FSharpbinding](https://github.com/fsharp/fsharpbinding) - Xamarin Studio バインディング\n * [F# Snippets web site](http://fssnip.net/) - F# 版のpastebin\n * [F# ACE Code Editor](https://github.com/BayardRock/FSharpWebIntellisense/) - Web上のF#編集ツール\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/index.html","title":"F# コンパイラサービス","content":"\nF# コンパイラサービス\n=====================\n\nF# コンパイラサービスパッケージはF# コンパイラのソースコードから派生したコンポーネントです。\nこのソースコードにはF# 言語バインディングを実装するための機能や、\nコンパイラやリファクタリングツールを元にしたツールを作成するための機能が追加されています。\nまた、パッケージには自身のアプリケーションにF# スクリプトを埋め込む際に利用できるような\nF# インタラクティブサービスも含まれています。\n\n<div class=\"row\">\n  <div class=\"span1\"></div>\n  <div class=\"span6\">\n    <div class=\"well well-small\" id=\"nuget\">\n      F# コンパイラサービスパッケージは <a href=\"https://nuget.org/packages/FSharp.Compiler.Service\">NuGet経由でインストールできます</a>:\n      <pre>PM> Install-Package FSharp.Compiler.Service</pre>\n    </div>\n  </div>\n  <div class=\"span1\"></div>\n</div>\n\n利用可能なサービス\n------------------\n\nプロジェクトには現在以下のサービスがあり、いずれもテストされ、\nこのページから参照可能なドキュメントがあります。\nライブラリには他にも使用可能な公開APIがありますが、\nここではドキュメント化されていません。\n\n * [** F# 言語トークナイザ **](tokenizer.html) - F#ソースコードをトークンのストリームへと変換します。\n   この機能はソースコードを色つき表示したり、基本的なツールを作成するような場合に有効です。\n   ネストされたコメントや文字列なども適切に処理できます。\n\n * [** 型無しASTの処理 **](untypedtree.html) - この機能を使うことで型無し抽象構文木(AST: abstract syntax tree)にアクセスできます。\n   型無しASTとは型情報を含まない解析済みのF#の文法を表すもので、\n   コードフォーマットやその他様々な単純処理に利用できます。\n\n * [** エディタ (IDE) サービスの使用 **](editor.html) - 自動補完やツールチップ、\n   引数の情報などを表示するための機能があります。\n   この機能を使うと、F#サポート機能をエディタに追加したり、F#コードから\n   何らかの型情報を取得したりすることができるようになります。\n\n * [** シグネチャや型、解決済みのシンボルの処理 **](symbols.html) -\n   解決済みのシンボルや推測された型の表現、アセンブリ全体のシグネチャなどを\n   型のチェック時に返すような多数のサービスがあります。\n\n * [** 複数プロジェクトやプロジェクト全体の処理 **](project.html) -\n   すべてのプロジェクトに対するチェックを実行することにより、\n   プロジェクト全体の解析結果を使って\\[すべての参照の検索\\] のような\n   機能を実現できます。\n\n * [** F# Interactive のホスティング **](interactive.html) - 自身の.NETコードから\n   F# Interactiveを.NETライブラリとして呼び出すことができるようになります。\n   このAPIを使用すると、自身のプロジェクト内でF#をスクリプト言語として\n   埋め込むことができるようになります。\n\n * [** F#コンパイラのホスティング **](compiler.html) - F# コンパイラを\n   呼び出すコードを組み込むことができます。\n\n * [** ファイルシステムAPI **](filesystem.html) - `FSharp.Compiler.Service` コンポーネントには\n   ファイルシステムを表すグローバル変数が定義されています。\n   この変数を設定することによって、ファイルシステムが使用できない状況であっても\n   コンパイラをホストすることができるようになります。\n\n> **注釈:** FSharp.Compiler.Service.dll には既存のものと重複する機能が多数あるため、\n  将来的にはもっときちんとした形に変更されます。\n  そのため、これらのサービスを使用するAPIには破壊的変更が加えられる可能性があります。\n\n貢献および著作権について\n------------------------\n\nこのプロジェクトは [fsharp/fsharp](https://github.com/fsharp/fsharp) からフォークしたもので、\nそこへさらにエディタやF#用ツール、F# Interactiveの組み込みに必要となる機能を\n追加したものです。\n\nF# ソースコードの著作権はMicrosoft Corporationおよび貢献者に、\n拡張機能の著作権は Dave Thomas, Anh-Dung Phan, Tomas Petricek および\nその他の貢献者にあります。\nソースコードは [MIT ライセンス](https://github.com/fsharp/FSharp.Compiler.Service/blob/master/LICENSE) の元に公開されています。\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/typedtree.html","title":"Processing typed expression tree","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Processing typed expression tree\n=================================================\n\nThis tutorial demonstrates how to get the checked, typed expressions tree (TAST)\nfor F# code and how to walk over the tree.\n\nThis can be used for creating tools such as source code analyzers and refactoring tools.\nYou can also combine the information with the API available\nfrom [symbols](symbols.html).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nGetting checked expressions\n-----------------------\n\nTo access the type-checked, resolved expressions, you need to create an instance of `InteractiveChecker`.\n\nTo use the interactive checker, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n(**\n\n### Checking code\n\nWe first parse and check some code as in the [symbols](symbols.html) tutorial.\nOne difference is that we set keepAssemblyContents to true.\n\n*)\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create(keepAssemblyContents=true)\n\nlet parseAndCheckSingleFile (input) =\n    let file = Path.ChangeExtension(System.IO.Path.GetTempFileName(), \"fsx\")\n    File.WriteAllText(file, input)\n    // Get context representing a stand-alone (script) file\n    let projOptions, _errors =\n        checker.GetProjectOptionsFromScript(file, SourceText.ofString input)\n        |> Async.RunSynchronously\n\n    let fprojOptions = projOptions\n\n    checker.ParseAndCheckProject (fprojOptions)\n    |> Async.RunSynchronously\n\n(**\n## Getting the expressions\n\nAfter type checking a file, you can access the declarations and contents of the assembly, including expressions:\n\n*)\n\nlet input2 =\n      \"\"\"\nmodule MyLibrary\n\nopen System\n\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\", \" \", \"world\")\n    if msg.Length > 10 then\n        10\n    else\n        20\n\ntype MyClass() =\n    member x.MyMethod() = 1\n      \"\"\"\nlet checkProjectResults =\n    parseAndCheckSingleFile(input2)\n\ncheckProjectResults.Errors // should be empty\n\n\n(**\n\nChecked assemblies are made up of a series of checked implementation files.  The \"file\" granularity\nmatters in F# because initialization actions are triggered at the granularity of files.\nIn this case there is only one implementation file in the project:\n\n*)\n\nlet checkedFile = checkProjectResults.AssemblyContents.ImplementationFiles.[0]\n\n(**\n\nChecked assemblies are made up of a series of checked implementation files.  The \"file\" granularity\nmatters in F# because initialization actions are triggered at the granularity of files.\nIn this case there is only one implementation file in the project:\n\n*)\n\nlet rec printDecl prefix d =\n    match d with\n    | FSharpImplementationFileDeclaration.Entity (e, subDecls) ->\n        printfn \"%sEntity %s was declared and contains %d sub-declarations\" prefix e.CompiledName subDecls.Length\n        for subDecl in subDecls do\n            printDecl (prefix+\"    \") subDecl\n    | FSharpImplementationFileDeclaration.MemberOrFunctionOrValue(v, vs, e) ->\n        printfn \"%sMember or value %s was declared\" prefix  v.CompiledName\n    | FSharpImplementationFileDeclaration.InitAction(e) ->\n        printfn \"%sA top-level expression was declared\" prefix\n\n\nfor d in checkedFile.Declarations do\n   printDecl \"\" d\n\n// Entity MyLibrary was declared and contains 4 sub-declarations\n//     Member or value foo was declared\n//     Entity MyClass was declared and contains 0 sub-declarations\n//     Member or value .ctor was declared\n//     Member or value MyMethod was declared\n\n(**\n\nAs can be seen, the only declaration in the implementation file is that of the module MyLibrary, which\ncontains fours sub-declarations.\n\n> As an aside, one peculiarity here is that the member declarations (e.g. the \"MyMethod\" member) are returned as part of the containing module entity, not as part of their class.\n\n> Note that the class constructor is returned as a separate declaration. The class type definition has been \"split\" into a constructor and the other declarations.\n\n*)\n\nlet myLibraryEntity, myLibraryDecls =\n   match checkedFile.Declarations.[0] with\n   | FSharpImplementationFileDeclaration.Entity (e, subDecls) -> (e, subDecls)\n   | _ -> failwith \"unexpected\"\n\n\n(**\n\nWhat about the expressions, for example the body of function \"foo\"? Let's find it:\n*)\n\nlet (fooSymbol, fooArgs, fooExpression) =\n    match myLibraryDecls.[0] with\n    | FSharpImplementationFileDeclaration.MemberOrFunctionOrValue(v, vs, e) -> (v, vs, e)\n    | _ -> failwith \"unexpected\"\n\n\n(** Here 'fooSymbol' is a symbol associated with the declaration of 'foo',\n'fooArgs' represents the formal arguments to the 'foo' function, and 'fooExpression'\nis an expression for the implementation of the 'foo' function.\n\nOnce you have an expression, you can work with it much like an F# quotation.  For example,\nyou can find its declaration range and its type:\n\n*)\n\nfooExpression.Type  // shows that the return type of the body expression is 'int'\nfooExpression.Range  // shows the declaration range of the expression implementing 'foo'\n\n(**\n\n### Walking over expressions\n\n\nExpressions are analyzed using active patterns, much like F# quotations.\nHere is a generic expression visitor:\n\n*)\n\nlet rec visitExpr f (e:FSharpExpr) =\n    f e\n    match e with\n    | BasicPatterns.AddressOf(lvalueExpr) ->\n        visitExpr f lvalueExpr\n    | BasicPatterns.AddressSet(lvalueExpr, rvalueExpr) ->\n        visitExpr f lvalueExpr; visitExpr f rvalueExpr\n    | BasicPatterns.Application(funcExpr, typeArgs, argExprs) ->\n        visitExpr f funcExpr; visitExprs f argExprs\n    | BasicPatterns.Call(objExprOpt, memberOrFunc, typeArgs1, typeArgs2, argExprs) ->\n        visitObjArg f objExprOpt; visitExprs f argExprs\n    | BasicPatterns.Coerce(targetType, inpExpr) ->\n        visitExpr f inpExpr\n    | BasicPatterns.FastIntegerForLoop(startExpr, limitExpr, consumeExpr, isUp) ->\n        visitExpr f startExpr; visitExpr f limitExpr; visitExpr f consumeExpr\n    | BasicPatterns.ILAsm(asmCode, typeArgs, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.ILFieldGet (objExprOpt, fieldType, fieldName) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.ILFieldSet (objExprOpt, fieldType, fieldName, valueExpr) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.IfThenElse (guardExpr, thenExpr, elseExpr) ->\n        visitExpr f guardExpr; visitExpr f thenExpr; visitExpr f elseExpr\n    | BasicPatterns.Lambda(lambdaVar, bodyExpr) ->\n        visitExpr f bodyExpr\n    | BasicPatterns.Let((bindingVar, bindingExpr), bodyExpr) ->\n        visitExpr f bindingExpr; visitExpr f bodyExpr\n    | BasicPatterns.LetRec(recursiveBindings, bodyExpr) ->\n        List.iter (snd >> visitExpr f) recursiveBindings; visitExpr f bodyExpr\n    | BasicPatterns.NewArray(arrayType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewDelegate(delegateType, delegateBodyExpr) ->\n        visitExpr f delegateBodyExpr\n    | BasicPatterns.NewObject(objType, typeArgs, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewRecord(recordType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewAnonRecord(recordType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewTuple(tupleType, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.NewUnionCase(unionType, unionCase, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.Quote(quotedExpr) ->\n        visitExpr f quotedExpr\n    | BasicPatterns.FSharpFieldGet(objExprOpt, recordOrClassType, fieldInfo) ->\n        visitObjArg f objExprOpt\n    | BasicPatterns.AnonRecordGet(objExpr, recordOrClassType, fieldInfo) ->\n        visitExpr f objExpr\n    | BasicPatterns.FSharpFieldSet(objExprOpt, recordOrClassType, fieldInfo, argExpr) ->\n        visitObjArg f objExprOpt; visitExpr f argExpr\n    | BasicPatterns.Sequential(firstExpr, secondExpr) ->\n        visitExpr f firstExpr; visitExpr f secondExpr\n    | BasicPatterns.TryFinally(bodyExpr, finalizeExpr) ->\n        visitExpr f bodyExpr; visitExpr f finalizeExpr\n    | BasicPatterns.TryWith(bodyExpr, _, _, catchVar, catchExpr) ->\n        visitExpr f bodyExpr; visitExpr f catchExpr\n    | BasicPatterns.TupleGet(tupleType, tupleElemIndex, tupleExpr) ->\n        visitExpr f tupleExpr\n    | BasicPatterns.DecisionTree(decisionExpr, decisionTargets) ->\n        visitExpr f decisionExpr; List.iter (snd >> visitExpr f) decisionTargets\n    | BasicPatterns.DecisionTreeSuccess (decisionTargetIdx, decisionTargetExprs) ->\n        visitExprs f decisionTargetExprs\n    | BasicPatterns.TypeLambda(genericParam, bodyExpr) ->\n        visitExpr f bodyExpr\n    | BasicPatterns.TypeTest(ty, inpExpr) ->\n        visitExpr f inpExpr\n    | BasicPatterns.UnionCaseSet(unionExpr, unionType, unionCase, unionCaseField, valueExpr) ->\n        visitExpr f unionExpr; visitExpr f valueExpr\n    | BasicPatterns.UnionCaseGet(unionExpr, unionType, unionCase, unionCaseField) ->\n        visitExpr f unionExpr\n    | BasicPatterns.UnionCaseTest(unionExpr, unionType, unionCase) ->\n        visitExpr f unionExpr\n    | BasicPatterns.UnionCaseTag(unionExpr, unionType) ->\n        visitExpr f unionExpr\n    | BasicPatterns.ObjectExpr(objType, baseCallExpr, overrides, interfaceImplementations) ->\n        visitExpr f baseCallExpr\n        List.iter (visitObjMember f) overrides\n        List.iter (snd >> List.iter (visitObjMember f)) interfaceImplementations\n    | BasicPatterns.TraitCall(sourceTypes, traitName, typeArgs, typeInstantiation, argTypes, argExprs) ->\n        visitExprs f argExprs\n    | BasicPatterns.ValueSet(valToSet, valueExpr) ->\n        visitExpr f valueExpr\n    | BasicPatterns.WhileLoop(guardExpr, bodyExpr) ->\n        visitExpr f guardExpr; visitExpr f bodyExpr\n    | BasicPatterns.BaseValue baseType -> ()\n    | BasicPatterns.DefaultValue defaultType -> ()\n    | BasicPatterns.ThisValue thisType -> ()\n    | BasicPatterns.Const(constValueObj, constType) -> ()\n    | BasicPatterns.Value(valueToGet) -> ()\n    | _ -> failwith (sprintf \"unrecognized %+A\" e)\n\nand visitExprs f exprs =\n    List.iter (visitExpr f) exprs\n\nand visitObjArg f objOpt =\n    Option.iter (visitExpr f) objOpt\n\nand visitObjMember f memb =\n    visitExpr f memb.Body\n\n(**\nLet's use this expresssion walker:\n\n*)\nfooExpression |> visitExpr (fun e -> printfn \"Visiting %A\" e)\n\n// Prints:\n//\n// Visiting Let...\n// Visiting Call...\n// Visiting Const (\"Hello\", ...)\n// Visiting Const (\" \", ...)\n// Visiting Const (\"world\", ...)\n// Visiting IfThenElse...\n// Visiting Call...\n// Visiting Call...\n// Visiting Value ...\n// Visiting Const ...\n// Visiting Const ...\n// Visiting Const ...\n\n(**\nNote that\n\n* The visitExpr function is recursive (for nested expressions).\n\n* Pattern matching is removed from the tree, into a form called 'decision trees'.\n\nSummary\n-------\nIn this tutorial, we looked at basic of working with checked declarations and expressions.\n\nIn practice, it is also useful to combine the information here\nwith some information you can obtain from the [symbols](symbols.html)\ntutorial.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/filesystem.html","title":"Virtualized File System","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Virtualized File System\n==========================================\n\nThe `FSharp.Compiler.Service` component has a global variable\nrepresenting the file system. By setting this variable you can host the compiler in situations where a file system\nis not available.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\n\nSetting the FileSystem\n----------------------\n\nIn the example below, we set the file system to an implementation which reads from disk\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen System.Collections.Generic\nopen System.Text\nopen FSharp.Compiler.AbstractIL.Internal.Library\n\nlet defaultFileSystem = Shim.FileSystem\n\nlet fileName1 = @\"c:\\mycode\\test1.fs\" // note, the path doesn't exist\nlet fileName2 = @\"c:\\mycode\\test2.fs\" // note, the path doesn't exist\n\ntype MyFileSystem() =\n    let file1 = \"\"\"\nmodule File1\n\nlet A = 1\"\"\"\n    let file2 = \"\"\"\nmodule File2\nlet B = File1.A + File1.A\"\"\"\n    let files = dict [(fileName1, file1); (fileName2, file2)]\n\n    interface IFileSystem with\n        // Implement the service to open files for reading and writing\n        member __.FileStreamReadShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> new MemoryStream(Encoding.UTF8.GetBytes(text)) :> Stream\n            | _ -> defaultFileSystem.FileStreamReadShim(fileName)\n\n        member __.FileStreamCreateShim(fileName) =\n            defaultFileSystem.FileStreamCreateShim(fileName)\n\n        member __.FileStreamWriteExistingShim(fileName) =\n            defaultFileSystem.FileStreamWriteExistingShim(fileName)\n\n        member __.ReadAllBytesShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> Encoding.UTF8.GetBytes(text)\n            | _ -> defaultFileSystem.ReadAllBytesShim(fileName)\n\n        // Implement the service related to temporary paths and file time stamps\n        member __.GetTempPathShim() =\n            defaultFileSystem.GetTempPathShim()\n\n        member __.GetLastWriteTimeShim(fileName) =\n            defaultFileSystem.GetLastWriteTimeShim(fileName)\n\n        member __.GetFullPathShim(fileName) =\n            defaultFileSystem.GetFullPathShim(fileName)\n\n        member __.IsInvalidPathShim(fileName) =\n            defaultFileSystem.IsInvalidPathShim(fileName)\n\n        member __.IsPathRootedShim(fileName) =\n            defaultFileSystem.IsPathRootedShim(fileName)\n\n        member __.IsStableFileHeuristic(fileName) =\n            defaultFileSystem.IsStableFileHeuristic(fileName)\n\n        // Implement the service related to file existence and deletion\n        member __.SafeExists(fileName) =\n            files.ContainsKey(fileName) || defaultFileSystem.SafeExists(fileName)\n\n        member __.FileDelete(fileName) =\n            defaultFileSystem.FileDelete(fileName)\n\n        // Implement the service related to assembly loading, used to load type providers\n        // and for F# interactive.\n        member __.AssemblyLoadFrom(fileName) =\n            defaultFileSystem.AssemblyLoadFrom fileName\n\n        member __.AssemblyLoad(assemblyName) =\n            defaultFileSystem.AssemblyLoad assemblyName\n\nlet myFileSystem = MyFileSystem()\nShim.FileSystem <- MyFileSystem()\n\n(**\n\nDoing a compilation with the FileSystem\n---------------------------------------\n\n*)\nopen FSharp.Compiler.SourceCodeServices\n\nlet checker = FSharpChecker.Create()\n\nlet projectOptions =\n    let sysLib nm =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\\" + nm + \".dll\"\n        else\n            let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n            let (++) a b = System.IO.Path.Combine(a,b)\n            sysDir ++ nm + \".dll\"\n\n    let fsCore4300() =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"\n        else\n            sysLib \"FSharp.Core\"\n\n    let allFlags =\n        [| yield \"--simpleresolution\";\n           yield \"--noframework\";\n           yield \"--debug:full\";\n           yield \"--define:DEBUG\";\n           yield \"--optimize-\";\n           yield \"--doc:test.xml\";\n           yield \"--warn:3\";\n           yield \"--fullpaths\";\n           yield \"--flaterrors\";\n           yield \"--target:library\";\n           let references =\n             [ sysLib \"mscorlib\"\n               sysLib \"System\"\n               sysLib \"System.Core\"\n               fsCore4300() ]\n           for r in references do\n                 yield \"-r:\" + r |]\n\n    { ProjectFileName = @\"c:\\mycode\\compilation.fsproj\" // Make a name that is unique in this directory.\n      ProjectId = None\n      SourceFiles = [| fileName1; fileName2 |]\n      OriginalLoadReferences = []\n      ExtraProjectInfo=None\n      Stamp = None\n      OtherOptions = allFlags\n      ReferencedProjects = [| |]\n      IsIncompleteTypeCheckEnvironment = false\n      UseScriptResolutionRules = true\n      LoadTime = System.DateTime.Now // Note using 'Now' forces reloading\n      UnresolvedReferences = None }\n\nlet results = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\nresults.Errors\nresults.AssemblySignature.Entities.Count //2\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.Count //1\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"B\"\n\n(**\nSummary\n-------\nIn this tutorial, we've seen how to globally customize the view of the file system used by the FSharp.Compiler.Service\ncomponent.\n\nAt the time of writing, the following System.IO operations are not considered part of the virtualized file system API.\nFuture iterations on the compiler service implementation may add these to the API.\n\n  - Path.Combine\n  - Path.DirectorySeparatorChar\n  - Path.GetDirectoryName\n  - Path.GetFileName\n  - Path.GetFileNameWithoutExtension\n  - Path.HasExtension\n  - Path.GetRandomFileName (used only in generation compiled win32 resources in assemblies)\n\n**NOTE:** Several operations in the `SourceCodeServices` API accept the contents of a file to parse\nor check as a parameter, in addition to a file name. In these cases, the file name is only used for\nerror reporting.\n\n**NOTE:** Type provider components do not use the virtualized file system.\n\n**NOTE:** The compiler service may use MSBuild for assembly resolutions unless `--simpleresolution` is\nprovided. When using the `FileSystem` API you will normally want to specify `--simpleresolution` as one\nof your compiler flags. Also specify `--noframework`.  You will need to supply explicit resolutions of all\nreferenced .NET assemblies.\n\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/symbols.html","title":"Working with symbols","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Working with symbols\n============================================\n\nThis tutorial demonstrates how to work with symbols provided by the F# compiler. See also [project wide analysis](project.html)\nfor information on symbol references.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\nAs usual we start by referencing `FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `FSharpChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\n\nWe now perform type checking on the specified input:\n\n*)\n\nlet parseAndTypeCheckSingleFile (file, input) =\n    // Get context representing a stand-alone (script) file\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let parseFileResults, checkFileResults =\n        checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n        |> Async.RunSynchronously\n\n    // Wait until type checking succeeds (or 100 attempts)\n    match checkFileResults with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseFileResults, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet file = \"/home/user/Test.fsx\"\n\n(**\n## Getting resolved signature information about the file\n\nAfter type checking a file, you can access the inferred signature of a project up to and including the\nchecking of the given file through the `PartialAssemblySignature` property of the `TypeCheckResults`.\n\nThe full signature information is available for modules, types, attributes, members, values, functions,\nunion cases, record types, units of measure and other F# language constructs.\n\nThe typed expression trees are also available, see [typed tree tutorial](typedtree.html).\n\n*)\n\nlet input2 =\n      \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n        printfn \"x = %d, y = %d\" x y\n        printfn \"%s\" msg\n\ntype C() =\n    member x.P = 1\n      \"\"\"\nlet parseFileResults, checkFileResults =\n    parseAndTypeCheckSingleFile(file, SourceText.ofString input2)\n\n(**\nNow get the partial assembly signature for the code:\n*)\nlet partialAssemblySignature = checkFileResults.PartialAssemblySignature\n\npartialAssemblySignature.Entities.Count = 1  // one entity\n\n\n(**\nNow get the entity that corresponds to the module containing the code:\n*)\nlet moduleEntity = partialAssemblySignature.Entities.[0]\n\nmoduleEntity.DisplayName = \"Test\"\n\n(**\nNow get the entity that corresponds to the type definition in the code:\n*)\nlet classEntity = moduleEntity.NestedEntities.[0]\n\n(**\nNow get the value that corresponds to the function defined in the code:\n*)\nlet fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n(**\nNow look around at the properties describing the function value. All of the following evaluate to `true`:\n*)\nfnVal.Attributes.Count = 1\nfnVal.CurriedParameterGroups.Count // 1\nfnVal.CurriedParameterGroups.[0].Count // 2\nfnVal.CurriedParameterGroups.[0].[0].Name // \"x\"\nfnVal.CurriedParameterGroups.[0].[1].Name // \"y\"\nfnVal.DeclarationLocation.StartLine // 3\nfnVal.DisplayName // \"foo\"\nfnVal.DeclaringEntity.Value.DisplayName // \"Test\"\nfnVal.DeclaringEntity.Value.DeclarationLocation.StartLine // 1\nfnVal.GenericParameters.Count // 0\nfnVal.InlineAnnotation // FSharpInlineAnnotation.OptionalInline\nfnVal.IsActivePattern // false\nfnVal.IsCompilerGenerated // false\nfnVal.IsDispatchSlot // false\nfnVal.IsExtensionMember // false\nfnVal.IsPropertyGetterMethod // false\nfnVal.IsImplicitConstructor // false\nfnVal.IsInstanceMember // false\nfnVal.IsMember // false\nfnVal.IsModuleValueOrMember // true\nfnVal.IsMutable // false\nfnVal.IsPropertySetterMethod // false\nfnVal.IsTypeFunction // false\n\n(**\nNow look at the type of the function if used as a first class value. (Aside: the `CurriedParameterGroups` property contains\nmore information like the names of the arguments.)\n*)\nfnVal.FullType // int * int -> unit\nfnVal.FullType.IsFunctionType // int * int -> unit\nfnVal.FullType.GenericArguments.[0] // int * int\nfnVal.FullType.GenericArguments.[0].IsTupleType // int * int\nlet argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\nargTy1.TypeDefinition.DisplayName // int\n\n(**\nOK, so we got an object representation of the type `int * int -> unit`, and we have seen the first 'int'. We can find out more about the\ntype 'int' as follows, determining that it is a named type, which is an F# type abbreviation, `type int = int32`:\n*)\n\nargTy1.HasTypeDefinition\nargTy1.TypeDefinition.IsFSharpAbbreviation // \"int\"\n\n(**\nWe can now look at the right-hand-side of the type abbreviation, which is the type `int32`:\n*)\n\nlet argTy1b = argTy1.TypeDefinition.AbbreviatedType\nargTy1b.TypeDefinition.Namespace // Some \"Microsoft.FSharp.Core\"\nargTy1b.TypeDefinition.CompiledName // \"int32\"\n\n(**\nAgain we can now look through the type abbreviation `type int32 = System.Int32` to get the\nfull information about the type:\n*)\nlet argTy1c = argTy1b.TypeDefinition.AbbreviatedType\nargTy1c.TypeDefinition.Namespace // Some \"SystemCore\"\nargTy1c.TypeDefinition.CompiledName // \"Int32\"\n\n(**\nThe type checking results for a file also contain information extracted from the project (or script) options\nused in the compilation, called the `ProjectContext`:\n*)\nlet projectContext = checkFileResults.ProjectContext\n\nfor assembly in projectContext.GetReferencedAssemblies() do\n    match assembly.FileName with\n    | None -> printfn \"compilation referenced an assembly without a file\"\n    | Some s -> printfn \"compilation references assembly '%s'\" s\n\n\n(**\n**Notes:**\n\n  - If incomplete code is present, some or all of the attributes may not be quite as expected.\n  - If some assembly references are missing (which is actually very, very common), then 'IsUnresolved'  may\n    be true on values, members and/or entities related to external assemblies.  You should be sure to make your\n    code robust against IsUnresolved exceptions.\n\n*)\n\n(**\n\n## Getting symbolic information about whole projects\n\nTo check whole projects, create a checker, then call `parseAndCheckScript`. In this case, we just check\nthe project for a single script. By specifying a different \"projOptions\" you can create\na specification of a larger project.\n*)\nlet parseAndCheckScript (file, input) =\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    checker.ParseAndCheckProject(projOptions) |> Async.RunSynchronously\n\n(**\nNow do it for a particular input:\n*)\n\nlet tmpFile = Path.ChangeExtension(System.IO.Path.GetTempFileName() , \"fs\")\nFile.WriteAllText(tmpFile, input2)\n\nlet projectResults = parseAndCheckScript(tmpFile, SourceText.ofString input2)\n\n\n(**\nNow look at the results:\n*)\n\nlet assemblySig = projectResults.AssemblySignature\n\nassemblySig.Entities.Count = 1  // one entity\nassemblySig.Entities.[0].Namespace  // one entity\nassemblySig.Entities.[0].DisplayName // \"Tmp28D0\"\nassemblySig.Entities.[0].MembersFunctionsAndValues.Count // 1\nassemblySig.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"foo\"\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/interactive.html","title":"Embedding F# Interactive","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nInteractive Service: Embedding F# Interactive\n=============================================\n\nThis tutorial demonstrates how to embed F# interactive in your application. F# interactive\nis an interactive scripting environment that compiles F# code into highly efficient IL code\nand executes it on the fly. The F# interactive service allows you to embed F# evaluation in\nyour application.\n\n> **NOTE:** There is a number of options for embedding F# Interactive. The easiest one is to use the\n`fsi.exe` process and communicate with it using standard input and standard output. In this\ntutorial, we look at calling F# Interactive directly through .NET API. However, if you have\nno control over the input, it is a good idea to run F# interactive in a separate process.\nOne reason is that there is no way to handle `StackOverflowException` and so a poorly written\nscript can terminate the host process. **Remember that while calling F# Interactive through .NET API,\n` --shadowcopyreferences` option will be ignored**. For detailed discussion, please take a look at\n[this thread](https://github.com/fsharp/FSharp.Compiler.Service/issues/292).\n> **NOTE:** If `FsiEvaluationSession.Create` fails with an error saying that `FSharp.Core.dll` cannot be found,\nadd the `FSharp.Core.sigdata` and `FSharp.Core.optdata` files. More info [here](https://fsharp.github.io/FSharp.Compiler.Service/corelib.html).\n\nHowever, the F# interactive service is still useful, because you might want to wrap it in your\nown executable that is then executed (and communicates with the rest of your application), or\nif you only need to execute limited subset of F# code (e.g. generated by your own DSL).\n\nStarting the F# interactive\n---------------------------\n\nFirst, we need to reference the libraries that contain F# interactive service:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Interactive.Shell\n\n(**\nTo communicate with F# interactive, we need to create streams that represent input and\noutput. We will use those later to read the output printed as a result of evaluating some\nF# code that prints:\n*)\nopen System\nopen System.IO\nopen System.Text\n\n// Initialize output and input streams\nlet sbOut = new StringBuilder()\nlet sbErr = new StringBuilder()\nlet inStream = new StringReader(\"\")\nlet outStream = new StringWriter(sbOut)\nlet errStream = new StringWriter(sbErr)\n\n// Build command line arguments & start FSI session\nlet argv = [| \"C:\\\\fsi.exe\" |]\nlet allArgs = Array.append argv [|\"--noninteractive\"|]\n\nlet fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\nlet fsiSession = FsiEvaluationSession.Create(fsiConfig, allArgs, inStream, outStream, errStream)\n\n\n\n(**\nEvaluating and executing code\n-----------------------------\n\nThe F# interactive service exposes several methods that can be used for evaluation. The first\nis `EvalExpression` which evaluates an expression and returns its result. The result contains\nthe returned value (as `obj`) and the statically inferred type of the value:\n*)\n/// Evaluate expression & return the result\nlet evalExpression text =\n  match fsiSession.EvalExpression(text) with\n  | Some value -> printfn \"%A\" value.ReflectionValue\n  | None -> printfn \"Got no result!\"\n\n(**\nThis takes a string as an argument and evaluates (i.e. executes) it as F# code.\n*)\nevalExpression \"42+1\" // prints '43'\n\n(**\nThis can be used in a strongly typed way as follows:\n*)\n\n/// Evaluate expression & return the result, strongly typed\nlet evalExpressionTyped<'T> (text) =\n    match fsiSession.EvalExpression(text) with\n    | Some value -> value.ReflectionValue |> unbox<'T>\n    | None -> failwith \"Got no result!\"\n\nevalExpressionTyped<int> \"42+1\"  // gives '43'\n\n\n(**\nThe `EvalInteraction` method can be used to evaluate side-effectful operations\nsuch as printing, declarations, or other interactions that are not valid F# expressions, but can be entered in\nthe F# Interactive console. Such commands include `#time \"on\"` (and other directives), `open System`\nall declarations and other top-level statements. The code\ndoes not require `;;` at the end. Just enter the code that you want to execute:\n*)\nfsiSession.EvalInteraction \"printfn \\\"bye\\\"\"\n\n\n(**\nThe `EvalScript` method allows to evaluate a complete .fsx script.\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 10 + 10\")\nfsiSession.EvalScript \"sample.fsx\"\n\n(**\nCatching errors\n------------------\n\n``EvalExpression``, ``EvalInteraction`` and ``EvalScript`` are awkward if the\ncode has type checking warnings or errors, or if evaluation fails with an exception.\nIn these cases you can use ``EvalExpressionNonThrowing``, ``EvalInteractionNonThrowing``\nand ``EvalScriptNonThrowing``. These return a tuple of a result and an array of ``FSharpErrorInfo`` values.\nThese represent the errors and warnings. The result part is a ``Choice<_,_>`` between an actual\nresult and an exception.\n\nThe result part of ``EvalExpression`` and ``EvalExpressionNonThrowing`` is an optional ``FSharpValue``.\nIf that value is not present then it just indicates that the expression didn't have a tangible\nresult that could be represented as a .NET object.  This situation shouldn't actually\noccur for any normal input expressions, and only for primitives used in libraries.\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 'a' + 10.0\")\nlet result, warnings = fsiSession.EvalScriptNonThrowing \"sample.fsx\"\n\n// show the result\nmatch result with\n| Choice1Of2 () -> printfn \"checked and executed ok\"\n| Choice2Of2 exn -> printfn \"execution exception: %s\" exn.Message\n\n\n(**\nGives:\n\n    execution exception: Operation could not be completed due to earlier error\n*)\n\n// show the errors and warnings\nfor w in warnings do\n   printfn \"Warning %s at %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n\n(**\nGives:\n\n    Warning The type 'float' does not match the type 'char' at 1,19\n    Warning The type 'float' does not match the type 'char' at 1,17\n\nFor expressions:\n*)\n\n\nlet evalExpressionTyped2<'T> text =\n   let res, warnings = fsiSession.EvalExpressionNonThrowing(text)\n   for w in warnings do\n       printfn \"Warning %s at %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n   match res with\n   | Choice1Of2 (Some value) -> value.ReflectionValue |> unbox<'T>\n   | Choice1Of2 None -> failwith \"null or no result\"\n   | Choice2Of2 (exn:exn) -> failwith (sprintf \"exception %s\" exn.Message)\n\nevalExpressionTyped2<int> \"42+1\"  // gives '43'\n\n\n(**\nExecuting in parallel\n------------------\n\nBy default the code passed to ``EvalExpression`` is executed immediately. To execute in parallel, submit a computation that starts a task:\n*)\n\nopen System.Threading.Tasks\n\nlet sampleLongRunningExpr =\n    \"\"\"\nasync {\n    // The code of what you want to run\n    do System.Threading.Thread.Sleep 5000\n    return 10\n}\n  |> Async.StartAsTask\"\"\"\n\nlet task1 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\nlet task2 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\n\n(**\nBoth computations have now started.  You can now fetch the results:\n*)\n\n\ntask1.Result // gives the result after completion (up to 5 seconds)\ntask2.Result // gives the result after completion (up to 5 seconds)\n\n(**\nType checking in the evaluation context\n------------------\n\nLet's assume you have a situation where you would like to typecheck code\nin the context of the F# Interactive scripting session. For example, you first\nevaluation a declaration:\n*)\n\nfsiSession.EvalInteraction \"let xxx = 1 + 1\"\n\n(**\n\nNow you want to typecheck the partially complete code `xxx + xx`\n*)\n\nlet parseResults, checkResults, checkProjectResults =\n    fsiSession.ParseAndCheckInteraction(\"xxx + xx\")\n    |> Async.RunSynchronously\n\n(**\nThe `parseResults` and `checkResults` have types `ParseFileResults` and `CheckFileResults`\nexplained in [Editor](editor.html). You can, for example, look at the type errors in the code:\n*)\ncheckResults.Errors.Length // 1\n\n(**\nThe code is checked with respect to the logical type context available in the F# interactive session\nbased on the declarations executed so far.\n\nYou can also request declaration list information, tooltip text and symbol resolution:\n*)\nopen FSharp.Compiler\n\n// get a tooltip\ncheckResults.GetToolTipText(1, 2, \"xxx + xx\", [\"xxx\"], FSharpTokenTag.IDENT)\n\ncheckResults.GetSymbolUseAtLocation(1, 2, \"xxx + xx\", [\"xxx\"]) // symbol xxx\n\n(**\nThe 'fsi' object\n------------------\n\nIf you want your scripting code to be able to access the 'fsi' object, you should pass in an implementation of this object explicitly.\nNormally the one from FSharp.Compiler.Interactive.Settings.dll is used.\n*)\n\nlet fsiConfig2 = FsiEvaluationSession.GetDefaultConfiguration(fsiSession)\n\n(**\nCollectible code generation\n------------------\n\nEvaluating code in using FsiEvaluationSession generates a .NET dynamic assembly and uses other resources.\nYou can make generated code collectible by passing `collectible=true`.  However code will only\nbe collected if there are no outstanding object references involving types, for example\n`FsiValue` objects returned by `EvalExpression`, and you must have disposed the `FsiEvaluationSession`.\nSee also [Restrictions on Collectible Assemblies](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/dd554932(v=vs.100)#restrictions).\n\nThe example below shows the creation of 200 evaluation sessions. Note that `collectible=true` and\n`use session = ...` are both used.\n\nIf collectible code is working correctly,\noverall resource usage will not increase linearly as the evaluation progresses.\n*)\n\nlet collectionTest() =\n\n    for i in 1 .. 200 do\n        let defaultArgs = [|\"fsi.exe\";\"--noninteractive\";\"--nologo\";\"--gui-\"|]\n        use inStream = new StringReader(\"\")\n        use outStream = new StringWriter()\n        use errStream = new StringWriter()\n\n        let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\n        use session = FsiEvaluationSession.Create(fsiConfig, defaultArgs, inStream, outStream, errStream, collectible=true)\n\n        session.EvalInteraction (sprintf \"type D = { v : int }\")\n        let v = session.EvalExpression (sprintf \"{ v = 42 * %d }\" i)\n        printfn \"iteration %d, result = %A\" i v.Value.ReflectionValue\n\n// collectionTest()  <-- run the test like this\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/corelib.html","title":"Notes on FSharp.Core.dll","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on FSharp.Core.dll\n=================================================\n\nShipping an FSharp.Core with your application\n---------------------------------------------\n\nWhen building applications or plug-in components which use FSharp.Compiler.Service.dll, you will normally also\ninclude a copy of FSharp.Core.dll as part of your application.\n\nFor example, if you build a ``HostedCompiler.exe``, you will normally place an FSharp.Core.dll (say 4.3.1.0) alongside\nyour ``HostedCompiler.exe``.\n\nBinding redirects for your application\n--------------------------------------\n\nThe FSharp.Compiler.Service.dll component depends on FSharp.Core 4.4.0.0.  Normally your application will target\na later version of FSharp.Core, and you may need a [binding redirect](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/redirect-assembly-versions) to ensure\nthat other versions of FSharp.Core forward to the final version of FSharp.Core.dll your application uses.\nBinding redirect files are normally generated automatically by build tools. If not, you can use one like this\n(if your tool is called ``HostedCompiler.exe``, the binding redirect file is called ``HostedCompiler.exe.config``)\n\nSome other dependencies may also need to be reconciled and forwarded.\n\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <configuration>\n        <runtime>\n          <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n            <dependentAssembly>\n              <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\"/>\n              <bindingRedirect oldVersion=\"2.0.0.0-4.4.0.0\" newVersion=\"4.4.1.0\"/>\n            </dependentAssembly>\n            <dependentAssembly>\n              <assemblyIdentity name=\"System.Collections.Immutable\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n              <bindingRedirect oldVersion=\"1.0.0.0-1.2.0.0\" newVersion=\"1.2.1.0\" />\n            </dependentAssembly>\n          </assemblyBinding>\n        </runtime>\n    </configuration>\n\nWhich FSharp.Core and .NET Framework gets referenced in compilation?\n--------------------------------------\n\nThe FSharp.Compiler.Service component can be used to do more or less any sort of F# compilation.\nIn particular you can reference an explicit FSharp.Core and/or framework\nassemblies in the command line arguments (different to the FSharp.Core and a .NET Framework being used to run your tool).\n\nTo target a specific FSharp.Core and/or .NET Framework assemblies, use the ``--noframework`` argument\nand the appropriate command-line arguments:\n\n    [<Literal>]\n    let fsharpCorePath =\n        @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.1.0\\FSharp.Core.dll\"\n    let errors2, exitCode2 =\n      scs.Compile(\n        [| \"fsc.exe\"; \"--noframework\";\n           \"-r\"; fsharpCorePath;\n           \"-r\"; @\"C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorlib.dll\";\n           \"-o\"; fn3;\n           \"-a\"; fn2 |])\n\nYou will need to determine the location of these assemblies.  The easiest way to locate these DLLs in a cross-platform way and\nconvert them to command-line arguments is to [crack an F# project file](https://fsharp.github.io/FSharp.Compiler.Service/project.html).\nAlternatively you can compute SDK paths yourself, and some helpers to do this are in [the tests for FSharp.Compiler.Service.dll](https://github.com/fsharp/FSharp.Compiler.Service/blob/8a943dd3b545648690cb3bed652a469bdb6dd869/tests/service/Common.fs#L54).\n\n\nWhat about if I am processing a script or using ``GetCheckOptionsFromScriptRoot``\n-------------------------------------------------------------------------\n\nIf you do _not_ explicitly reference an FSharp.Core.dll from an SDK location, or if you are processing a script\nusing ``FsiEvaluationSession`` or ``GetCheckOptionsFromScriptRoot``, then an implicit reference to FSharp.Core will be made\nby the following choice:\n\n1. The version of FSharp.Core.dll statically referenced by the host assembly returned by ``System.Reflection.Assembly.GetEntryAssembly()``.\n\n2. If there is no static reference to FSharp.Core in the host assembly, then\n\n   - For FSharp.Compiler.Service 1.4.0.x above (F# 4.0 series), a reference to FSharp.Core version 4.4.0.0 is added\n\nDo I need to include FSharp.Core.optdata and FSharp.Core.sigdata?\n--------------------------------------\n\nNo, unless you are doing something with very old FSharp.Core.dll.\n\nSummary\n-------\n\nIn this design note we have discussed three things:\n\n- which FSharp.Core.dll is used to run your compilation tools\n- how  to configure binding redirects for the FSharp.Core.dll used to run your compilation tools\n- which FSharp.Core.dll and/or framework assemblies are  referenced during the checking and compilations performed by your tools.\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/editor.html","title":"Editor services","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Editor services\n==================================\n\nThis tutorial demonstrates how to use the editor services provided by the F# compiler.\nThis API is used to provide auto-complete, tool-tips, parameter info help, matching of\nbrackets and other functions in F# editors including Visual Studio, Xamarin Studio and Emacs\n(see [fsharpbindings](https://github.com/fsharp/fsharpbinding) project for more information).\nSimilarly to [the tutorial on using untyped AST](untypedtree.html), we start by\ngetting the `InteractiveChecker` object.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nType checking sample source code\n--------------------------------\n\nAs in the [previous tutorial (using untyped AST)](untypedtree.html), we start by referencing\n`FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `InteractiveChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\n\nAs [previously](untypedtree.html), we use `GetProjectOptionsFromScriptRoot` to get a context\nwhere the specified input is the only file passed to the compiler (and it is treated as a\nscript file or stand-alone F# source code).\n\n*)\n// Sample input as a multi-line string\nlet input =\n  \"\"\"\n  open System\n\n  let foo() =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n      printfn \"%s\" msg.\n  \"\"\"\n// Split the input & define file name\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nlet projOptions, errors =\n    checker.GetProjectOptionsFromScript(file, SourceText.ofString input)\n    |> Async.RunSynchronously\n\nlet parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n(**\nTo perform type checking, we first need to parse the input using\n`ParseFile`, which gives us access to the [untyped AST](untypedtree.html). However,\nthen we need to call `CheckFileInProject` to perform the full type checking. This function\nalso requires the result of `ParseFileInProject`, so the two functions are often called\ntogether.\n*)\n// Perform parsing\n\nlet parseFileResults =\n    checker.ParseFile(file, SourceText.ofString input, parsingOptions)\n    |> Async.RunSynchronously\n(**\nBefore we look at the interesting operations provided by `TypeCheckResults`, we\nneed to run the type checker on a sample input. On F# code with errors, you would get some type checking\nresult (but it may contain incorrectly \"guessed\" results).\n*)\n\n// Perform type checking\nlet checkFileAnswer =\n    checker.CheckFileInProject(parseFileResults, file, 0, SourceText.ofString input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nAlternatively you can use `ParseAndCheckFileInProject` to check both in one step:\n*)\n\nlet parseResults2, checkFileAnswer2 =\n    checker.ParseAndCheckFileInProject(file, 0, SourceText.ofString input, projOptions)\n    |> Async.RunSynchronously\n\n(**\n\nThe function returns both the untyped parse result (which we do not use in this\ntutorial), but also a `CheckFileAnswer` value, which gives us access to all\nthe interesting functionality...\n*)\n\nlet checkFileResults =\n    match checkFileAnswer with\n    | FSharpCheckFileAnswer.Succeeded(res) -> res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\n(**\n\nHere, we type check a simple function that (conditionally) prints \"Hello world\".\nOn the last line, we leave an additional dot in `msg.` so that we can get the\ncompletion list on the `msg` value (we expect to see various methods on the string\ntype there).\n\n\nUsing type checking results\n---------------------------\n\nLet's now look at some of the API that is exposed by the `TypeCheckResults` type. In general,\nthis is the type that lets you implement most of the interesting F# source code editor services.\n\n### Getting a tool tip\n\nTo get a tool tip, you can use `GetToolTipTextAlternate` method. The method takes a line number and character\noffset. Both of the numbers are zero-based. In the sample code, we want to get tooltip for the `foo`\nfunction that is defined on line 3 (line 0 is blank) and the letter `f` starts at index 7 (the tooltip\nwould work anywhere inside the identifier).\n\nIn addition, the method takes a tag of token which is typically `IDENT`, when getting tooltip for an\nidentifier (the other option lets you get tooltip with full assembly location when using `#r \"...\"`).\n\n*)\n// Get tag of the IDENT token to be used as the last argument\nopen FSharp.Compiler\nlet identToken = FSharpTokenTag.Identifier\n\n// Get tool tip at the specified location\nlet tip = checkFileResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], identToken)\nprintfn \"%A\" tip\n\n(**\n\n> **NOTE:** `GetToolTipTextAlternate` is an alternative name for the old `GetToolTipText`. The old `GetToolTipText` was\ndeprecated because it accepted zero-based line numbers.  At some point it will be removed, and  `GetToolTipTextAlternate` will be renamed back to `GetToolTipText`.\n*)\n\n(**\nAside from the location and token kind, the function also requires the current contents of the line\n(useful when the source code changes) and a `Names` value, which is a list of strings representing\nthe current long name. For example to get tooltip for the `Random` identifier in a long name\n`System.Random`, you would use location somewhere in the string `Random` and you would pass\n`[\"System\"; \"Random\"]` as the `Names` value.\n\nThe returned value is of type `ToolTipText` which contains a discriminated union `ToolTipElement`.\nThe union represents different kinds of tool tips that you can get from the compiler.\n\n### Getting auto-complete lists\n\nThe next method exposed by `TypeCheckResults` lets us perform auto-complete on a given location.\nThis can be called on any identifier or in any scope (in which case you get a list of names visible\nin the scope) or immediately after `.` to get a list of members of some object. Here, we get a\nlist of members of the string value `msg`.\n\nTo do this, we call `GetDeclarationListInfo` with the location of the `.` symbol on the last line\n(ending with `printfn \"%s\" msg.`). The offsets are one-based, so the location is `7, 23`.\nWe also need to specify a function that says that the text has not changed and the current identifier\nwhere we need to perform the completion.\n*)\n// Get declarations (autocomplete) for a location\nlet decls =\n    checkFileResults.GetDeclarationListInfo\n      (Some parseFileResults, 7, inputLines.[6], PartialLongName.Empty 23, (fun () -> []), fun _ -> false)\n    |> Async.RunSynchronously\n\n// Print the names of available items\nfor item in decls.Items do\n    printfn \" - %s\" item.Name\n\n(**\n\n> **NOTE:** `v` is an alternative name for the old `GetDeclarations`. The old `GetDeclarations` was\ndeprecated because it accepted zero-based line numbers.  At some point it will be removed, and  `GetDeclarationListInfo` will be renamed back to `GetDeclarations`.\n*)\n\n(**\nWhen you run the code, you should get a list containing the usual string methods such as\n`Substring`, `ToUpper`, `ToLower` etc. The fourth argument of `GetDeclarations`, here `([], \"msg\")`,\nspecifies the context for the auto-completion. Here, we want a completion on a complete name\n`msg`, but you could for example use `([\"System\"; \"Collections\"], \"Generic\")` to get a completion list\nfor a fully qualified namespace.\n\n### Getting parameter information\n\nThe next common feature of editors is to provide information about overloads of a method. In our\nsample code, we use `String.Concat` which has a number of overloads. We can get the list using\n`GetMethods` operation. As previously, this takes zero-indexed offset of the location that we are\ninterested in (here, right at the end of the `String.Concat` identifier) and we also need to provide\nthe identifier again (so that the compiler can provide up-to-date information when the source code\nchanges):\n\n*)\n// Get overloads of the String.Concat method\nlet methods =\n    checkFileResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"])\n    |> Async.RunSynchronously\n\n// Print concatenated parameter lists\nfor mi in methods.Methods do\n    [ for p in mi.Parameters -> p.Display ]\n    |> String.concat \", \"\n    |> printfn \"%s(%s)\" methods.MethodName\n(**\nThe code uses the `Display` property to get the annotation for each parameter. This returns information\nsuch as `arg0: obj` or `params args: obj[]` or `str0: string, str1: string`. We concatenate the parameters\nand print a type annotation with the method name.\n*)\n\n(**\n\n## Asynchronous and immediate operations\n\nYou may have noticed that `CheckFileInProject` is an asynchronous operation.\nThis indicates that type checking of F# code can take some time.\nThe F# compiler performs the work in background (automatically) and when\nwe call `CheckFileInProject` method, it returns an asynchronous operation.\n\nThere is also the `CheckFileInProjectIfReady` method. This returns immediately if the\ntype checking operation can't be started immediately, e.g. if other files in the project\nare not yet type-checked. In this case, a background worker might choose to do other\nwork in the meantime, or give up on type checking the file until the `FileTypeCheckStateIsDirty` event\nis raised.\n\n> The [fsharpbinding](https://github.com/fsharp/fsharpbinding) project has more advanced\nexample of handling the background work where all requests are sent through an F# agent.\nThis may be a more appropriate for implementing editor support.\n\n*)\n\n\n(**\nSummary\n-------\n\nThe `CheckFileAnswer` object contains other useful methods that were not covered in this tutorial. You\ncan use it to get location of a declaration for a given identifier, additional colorization information\n(the F# 3.1 colorizes computation builder identifiers & query operators) and others.\n\nUsing the FSharpChecker component in multi-project, incremental and interactive editing situations may involve\nknowledge of the [FSharpChecker operations queue](queue.html) and the [FSharpChecker caches](caches.html).\n\n\nFinally, if you are implementing an editor support for an editor that cannot directly call .NET API,\nyou can call many of the methods discussed here via a command line interface that is available in the\n[FSharp.AutoComplete](https://github.com/fsharp/fsharpbinding/tree/master/FSharp.AutoComplete) project.\n\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/queue.html","title":"Notes on the FSharpChecker operations queue","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on the FSharpChecker operations queue\n=================================================\n\nThis is a design note on the FSharpChecker component and its operations queue.  See also the notes on the [FSharpChecker caches](caches.html)\n\nFSharpChecker maintains an operations queue. Items from the FSharpChecker operations queue are processed\nsequentially and in order.\n\nThe thread processing these requests can also run a low-priority, interleaved background operation when the\nqueue is empty.  This can be used to implicitly bring the background check of a project \"up-to-date\".\nWhen the operations queue has been empty for 1 second,\nthis background work is run in small incremental fragments. This work is cooperatively time-sliced to be approximately <50ms, (see `maxTimeShareMilliseconds` in\nIncrementalBuild.fs). The project to be checked in the background is set implicitly\nby calls to ``CheckFileInProject`` and ``ParseAndCheckFileInProject``.\nTo disable implicit background checking completely, set ``checker.ImplicitlyStartBackgroundWork`` to false.\nTo change the time before background work starts, set ``checker.PauseBeforeBackgroundWork`` to the required number of milliseconds.\n\nMost calls to the FSharpChecker API enqueue an operation in the FSharpChecker compiler queue. These correspond to the\ncalls to EnqueueAndAwaitOpAsync in [service.fs](https://github.com/fsharp/FSharp.Compiler.Service/blob/master/src/fsharp/service/service.fs).\n\n* For example, calling `ParseAndCheckProject` enqueues a `ParseAndCheckProjectImpl` operation. The time taken for the\n  operation will depend on how much work is required to bring the project analysis up-to-date.\n\n* Likewise, calling any of `GetUsesOfSymbol`, `GetAllUsesOfAllSymbols`, `ParseFileInProject`,\n  `GetBackgroundParseResultsForFileInProject`, `MatchBraces`, `CheckFileInProjectIfReady`, `ParseAndCheckFileInProject`, `GetBackgroundCheckResultsForFileInProject`,\n  `ParseAndCheckProject`, `GetProjectOptionsFromScript`, `InvalidateConfiguration`, `InvaidateAll` and operations\n  on FSharpCheckResults will cause an operation to be enqueued. The length of the operation will\n  vary - many will be very fast - but they won't be processed until other operations already in the queue are complete.\n\nSome operations do not enqueue anything on the FSharpChecker operations queue - notably any accesses to the Symbol APIs.\nThese use cross-threaded access to the TAST data produced by other FSharpChecker operations.\n\nSome tools throw a lot of interactive work at the FSharpChecker operations queue.\nIf you are writing such a component, consider running your project against a debug build\nof FSharp.Compiler.Service.dll to see the Trace.WriteInformation messages indicating the length of the\noperations queue and the time to process requests.\n\nFor those writing interactive editors which use FCS, you\nshould be cautious about operations that request a check of  the entire project.\nFor example, be careful about requesting the check of an entire project\non operations like \"Highlight Symbol\" or \"Find Unused Declarations\"\n(which run automatically when the user opens a file or moves the cursor).\nas opposed to operations like \"Find All References\" (which a user explicitly triggers).\nProject checking can cause long and contention on the FSharpChecker operations queue.\n\nRequests to FCS can be cancelled by cancelling the async operation. (Some requests also\ninclude additional callbacks which can be used to indicate a cancellation condition).\nThis cancellation will be effective if the cancellation is performed before the operation\nis executed in the operations queue.\n\nSummary\n-------\n\nIn this design note, you learned that the FSharpChecker component keeps an operations queue. When using FSharpChecker\nin highly interactive situations, you should carefully consider the characteristics of the operations you are\nenqueueing.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/caches.html","title":"Notes on the FSharpChecker caches","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Notes on the FSharpChecker caches\n=================================================\n\nThis is a design note on the FSharpChecker component and its caches.  See also the notes on the [FSharpChecker operations queue](queue.html)\n\nEach FSharpChecker object maintains a set of caches.  These are\n\n* ``scriptClosureCache`` - an MRU cache of default size ``projectCacheSize`` that caches the\n  computation of GetProjectOptionsFromScript. This computation can be lengthy as it can involve processing the transitive closure\n  of all ``#load`` directives, which in turn can mean parsing an unbounded number of script files\n\n* ``incrementalBuildersCache`` - an MRU cache of projects where a handle is being kept to their incremental checking state,\n  of default size ``projectCacheSize`` (= 3 unless explicitly set as a parameter).\n  The \"current background project\" (see the [FSharpChecker operations queue](queue.html))\n  will be one of these projects.  When analyzing large collections of projects, this cache usually occupies by far the most memory.\n  Increasing the size of this cache can dramatically decrease incremental computation of project-wide checking, or of checking\n  individual files within a project, but can very greatly increase memory usage.\n\n* ``braceMatchCache`` - an MRU cache of size ``braceMatchCacheSize`` (default = 5) keeping the results of calls to MatchBraces, keyed by filename, source and project options.\n\n* ``parseFileCache`` - an MRU cache of size ``parseFileCacheSize`` (default = 2) keeping the results of ParseFile,\n  keyed by filename, source and project options.\n\n* ``checkFileInProjectCache`` - an MRU cache of size ``incrementalTypeCheckCacheSize`` (default = 5) keeping the results of\n  ParseAndCheckFileInProject, CheckFileInProject and/or CheckFileInProjectIfReady. This is keyed by filename, file source\n  and project options.  The results held in this cache are only returned if they would reflect an accurate parse and check of the\n  file.\n\n* ``getToolTipTextCache`` - an aged lookup cache of strong size ``getToolTipTextSize`` (default = 5) computing the results of GetToolTipText.\n\n* ``ilModuleReaderCache`` - an aged lookup of weak references to \"readers\" for references .NET binaries. Because these\n  are all weak references, you can generally ignore this cache, since its entries will be automatically collected.\n  Strong references to binary readers will be kept by other FCS data structures, e.g. any project checkers, symbols or project checking results.\n\n  In more detail, the bytes for referenced .NET binaries are read into memory all at once, eagerly. Files are not left\n  open or memory-mapped when using FSharpChecker (as opposed to FsiEvaluationSession, which loads assemblies using reflection).\n  The purpose of this cache is mainly to ensure that while setting up compilation, the reads of mscorlib, FSharp.Core and so on\n  amortize cracking the DLLs.\n\n* ``frameworkTcImportsCache`` - an aged lookup of strong size 8 which caches the process of setting up type checking against a set of system\n  components (e.g. a particular version of mscorlib, FSharp.Core and other system DLLs).  These resources are automatically shared between multiple\n  project checkers which happen to reference the same set of system assemblies.\n\nProfiling the memory used by the various caches can be done by looking for the corresponding static roots in memory profiling traces.\n\nThe sizes of some of these caches can be adjusted by giving parameters to FSharpChecker.  Unless otherwise noted,\nthe cache sizes above indicate the \"strong\" size of the cache, where memory is held regardless of the memory\npressure on the system. Some of the caches can also hold \"weak\" references which can be collected at will by the GC.\n\n> Note: Because of these caches, you should generally use one global, shared FSharpChecker for everything in an IDE application.\n\n\nLow-Memory Condition\n-------\n\nVersion 1.4.0.8 added a \"maximum memory\" limit specified by the `MaxMemory` property on FSharpChecker (in MB). If an FCS project operation\nis performed (see `CheckMaxMemoryReached` in `service.fs`) and `System.GC.GetTotalMemory(false)` reports a figure greater than this, then\nthe strong sizes of all FCS caches are reduced to either 0 or 1.  This happens for the remainder of the lifetime of the FSharpChecker object.\nIn practice this will still make tools like the Visual Studio F# Power Tools usable, but some operations like renaming across multiple\nprojects may take substantially longer.\n\nBy default the maximum memory trigger is disabled, see `maxMBDefault` in `service.fs`.\n\nReducing the FCS strong cache sizes does not guarantee there will be enough memory to continue operations - even holding one project\nstrongly may exceed a process memory budget. It just means FCS may hold less memory strongly.\n\nIf you do not want the maximum memory limit to apply then set MaxMemory to System.Int32.MaxValue.\n\nSummary\n-------\n\nIn this design note, you learned that the FSharpChecker component keeps a set of caches in order to support common\nincremental analysis scenarios reasonably efficiently. They correspond roughly to the original caches and sizes\nused by the Visual F# Tools, from which the FSharpChecker component derives.\n\nIn long running, highly interactive, multi-project scenarios you should carefully\nconsider the cache sizes you are using and the tradeoffs involved between incremental multi-project checking and memory usage.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/project.html","title":"Project Analysis","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Project Analysis\n==================================\n\nThis tutorial demonstrates how to can analyze a whole project using services provided by the F# compiler.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\n*)\n\n\n(**\n\nGetting whole-project results\n-----------------------------\n\nAs in the [previous tutorial (using untyped AST)](untypedtree.html), we start by referencing\n`FSharp.Compiler.Service.dll`, opening the relevant namespace and creating an instance\nof `InteractiveChecker`:\n\n*)\n// Reference F# compiler API\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.Collections.Generic\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\nHere are our sample inputs:\n*)\n\nmodule Inputs =\n    open System.IO\n\n    let base1 = Path.GetTempFileName()\n    let fileName1 = Path.ChangeExtension(base1, \".fs\")\n    let base2 = Path.GetTempFileName()\n    let fileName2 = Path.ChangeExtension(base2, \".fs\")\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\n\ntype C() =\n    member x.P = 1\n\nlet xxx = 3 + 4\nlet fff () = xxx + xxx\n    \"\"\"\n    File.WriteAllText(fileName1, fileSource1)\n\n    let fileSource2 = \"\"\"\nmodule N\n\nopen M\n\ntype D1() =\n    member x.SomeProperty = M.xxx\n\ntype D2() =\n    member x.SomeProperty = M.fff() + D1().P\n\n// Generate a warning\nlet y2 = match 1 with 1 -> M.xxx\n    \"\"\"\n    File.WriteAllText(fileName2, fileSource2)\n\n\n(**\nWe use `GetProjectOptionsFromCommandLineArgs` to treat two files as a project:\n*)\n\nlet projectOptions =\n    let sysLib nm =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then\n            // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\\" + nm + \".dll\"\n        else\n            let sysDir = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n            let (++) a b = System.IO.Path.Combine(a,b)\n            sysDir ++ nm + \".dll\"\n\n    let fsCore4300() =\n        if System.Environment.OSVersion.Platform = System.PlatformID.Win32NT then\n            // file references only valid on Windows\n            System.Environment.GetFolderPath(System.Environment.SpecialFolder.ProgramFilesX86) +\n            @\"\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"\n        else\n            sysLib \"FSharp.Core\"\n\n    checker.GetProjectOptionsFromCommandLineArgs\n       (Inputs.projFileName,\n        [| yield \"--simpleresolution\"\n           yield \"--noframework\"\n           yield \"--debug:full\"\n           yield \"--define:DEBUG\"\n           yield \"--optimize-\"\n           yield \"--out:\" + Inputs.dllName\n           yield \"--doc:test.xml\"\n           yield \"--warn:3\"\n           yield \"--fullpaths\"\n           yield \"--flaterrors\"\n           yield \"--target:library\"\n           yield Inputs.fileName1\n           yield Inputs.fileName2\n           let references =\n             [ sysLib \"mscorlib\"\n               sysLib \"System\"\n               sysLib \"System.Core\"\n               fsCore4300() ]\n           for r in references do\n                 yield \"-r:\" + r |])\n\n(**\nNow check the entire project (using the files saved on disk):\n*)\n\nlet wholeProjectResults = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\n(**\nNow look at the errors and warnings:\n*)\nwholeProjectResults .Errors.Length // 1\nwholeProjectResults.Errors.[0].Message.Contains(\"Incomplete pattern matches on this expression\") // yes it does\n\nwholeProjectResults.Errors.[0].StartLineAlternate // 13\nwholeProjectResults.Errors.[0].EndLineAlternate // 13\nwholeProjectResults.Errors.[0].StartColumn // 15\nwholeProjectResults.Errors.[0].EndColumn // 16\n\n(**\nNow look at the inferred signature for the project:\n*)\n[ for x in wholeProjectResults.AssemblySignature.Entities -> x.DisplayName ] // [\"N\"; \"M\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].NestedEntities -> x.DisplayName ] // [\"D1\"; \"D2\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[1].NestedEntities -> x.DisplayName ] // [\"C\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].MembersFunctionsAndValues -> x.DisplayName ] // [\"y\"; \"y2\"]\n\n(**\nYou can also get all symbols in the project:\n*)\nlet rec allSymbolsInEntities (entities: IList<FSharpEntity>) =\n    [ for e in entities do\n          yield (e :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             yield (x :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n          for x in e.FSharpFields do\n             yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities e.NestedEntities ]\n\nlet allSymbols = allSymbolsInEntities wholeProjectResults.AssemblySignature.Entities\n(**\nAfter checking the whole project, you can access the background results for individual files\nin the project. This will be fast and will not involve any additional checking.\n*)\n\nlet backgroundParseResults1, backgroundTypedParse1 =\n    checker.GetBackgroundCheckResultsForFileInProject(Inputs.fileName1, projectOptions)\n    |> Async.RunSynchronously\n\n\n(**\nYou can now resolve symbols in each file:\n*)\n\nlet xSymbolUseOpt =\n    backgroundTypedParse1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet xSymbolUse = xSymbolUseOpt.Value\n\nlet xSymbol = xSymbolUse.Symbol\n\n(**\nYou can find out more about a symbol by doing type checks on various symbol kinds:\n*)\n\nlet xSymbolAsValue =\n    match xSymbol with\n    | :? FSharpMemberOrFunctionOrValue as xSymbolAsVal -> xSymbolAsVal\n    | _ -> failwith \"we expected this to be a member, function or value\"\n\n\n(**\nFor each symbol, you can look up the references to that symbol:\n*)\nlet usesOfXSymbol =\n    wholeProjectResults.GetUsesOfSymbol(xSymbol)\n    |> Async.RunSynchronously\n\n(**\nYou can iterate all the defined symbols in the inferred signature and find where they are used:\n*)\nlet allUsesOfAllSignatureSymbols =\n    [ for s in allSymbols do\n         let uses = wholeProjectResults.GetUsesOfSymbol(s) |> Async.RunSynchronously\n         yield s.ToString(), uses ]\n\n(**\nYou can also look at all the symbols uses in the whole project (including uses of symbols with local scope)\n*)\nlet allUsesOfAllSymbols =\n    wholeProjectResults.GetAllUsesOfAllSymbols()\n    |> Async.RunSynchronously\n\n(**\nYou can also request checks of updated versions of files within the project (note that the other files\nin the project are still read from disk, unless you are using the [FileSystem API](filesystem.html)):\n\n*)\n\nlet parseResults1, checkAnswer1 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName1, 0, SourceText.ofString Inputs.fileSource1, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults1 =\n    match checkAnswer1 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"unexpected aborted\"\n\nlet parseResults2, checkAnswer2 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName2, 0, SourceText.ofString Inputs.fileSource2, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults2 =\n    match checkAnswer2 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"unexpected aborted\"\n\n(**\nAgain, you can resolve symbols and ask for references:\n*)\n\nlet xSymbolUse2Opt =\n    checkResults1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet xSymbolUse2 = xSymbolUse2Opt.Value\n\nlet xSymbol2 = xSymbolUse2.Symbol\n\nlet usesOfXSymbol2 =\n    wholeProjectResults.GetUsesOfSymbol(xSymbol2)\n    |> Async.RunSynchronously\n\n\n(**\nOr ask for all the symbols uses in the file (including uses of symbols with local scope)\n*)\nlet allUsesOfAllSymbolsInFile1 =\n    checkResults1.GetAllUsesOfAllSymbolsInFile()\n    |> Async.RunSynchronously\n\n(**\nOr ask for all the uses of one symbol in one file:\n*)\nlet allUsesOfXSymbolInFile1 =\n    checkResults1.GetUsesOfSymbolInFile(xSymbol2)\n    |> Async.RunSynchronously\n\nlet allUsesOfXSymbolInFile2 =\n    checkResults2.GetUsesOfSymbolInFile(xSymbol2)\n    |> Async.RunSynchronously\n\n(**\n\nAnalyzing multiple projects\n-----------------------------\n\nIf you have multiple F# projects to analyze which include references from some projects to others,\nthen the simplest way to do this is to build the projects and specify the cross-project references using\na `-r:path-to-output-of-project.dll` argument in the ProjectOptions. However, this requires the build\nof each project to succeed, producing the DLL file on disk which can be referred to.\n\nIn some situations, e.g. in an IDE, you may wish to allow references to other F# projects prior to successful compilation to\na DLL. To do this, fill in the ProjectReferences entry in ProjectOptions, which recursively specifies the project\noptions for dependent projects. Each project reference still needs a corresponding `-r:path-to-output-of-project.dll`\ncommand line argument in ProjectOptions, along with an entry in ProjectReferences.\nThe first element of each tuple in the ProjectReferences entry should be the DLL name, i.e. `path-to-output-of-project.dll`.\nThis should be the same as the text used in the `-r` project reference.\n\nWhen a project reference is used, the analysis will make use of the results of incremental\nanalysis of the referenced F# project from source files, without requiring the compilation of these files to DLLs.\n\nTo efficiently analyze a set of F# projects which include cross-references, you should populate the ProjectReferences\ncorrectly and then analyze each project in turn.\n\n*)\n\n(**\n\n> **NOTE:** Project references are disabled if the assembly being referred to contains type provider components -\n  specifying the project reference will have no effect beyond forcing the analysis of the project, and the DLL will\n  still be required on disk.\n\n*)\n\n(**\nSummary\n-------\n\nAs you have seen, the `ParseAndCheckProject` lets you access results of project-wide analysis\nsuch as symbol references. To learn more about working with symbols, see [Symbols](symbols.html).\n\nUsing the FSharpChecker component in multi-project, incremental and interactive editing situations may involve\nknowledge of the [FSharpChecker operations queue](queue.html) and the [FSharpChecker caches](caches.html).\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/tokenizer.html","title":"F# Language Tokenizer","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Using the F# tokenizer\n=========================================\n\nThis tutorial demonstrates how to call the F# language tokenizer. Given F#\nsource code, the tokenizer generates a list of source code lines that contain\ninformation about tokens on each line. For each token, you can get the type\nof the token, exact location as well as color kind of the token (keyword,\nidentifier, number, operator, etc.).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nCreating the tokenizer\n---------------------\n\nTo use the tokenizer, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\n(**\nNow you can create an instance of `FSharpSourceTokenizer`. The class takes two\narguments - the first is the list of defined symbols and the second is the\nfile name of the source code. The defined symbols are required because the\ntokenizer handles `#if` directives. The file name is required only to specify\nlocations of the source code (and it does not have to exist):\n*)\nlet sourceTok = FSharpSourceTokenizer([], Some \"C:\\\\test.fsx\")\n(**\nUsing the `sourceTok` object, we can now (repeatedly) tokenize lines of\nF# source code.\n\nTokenizing F# code\n------------------\n\nThe tokenizer operates on individual lines rather than on the entire source\nfile. After getting a token, the tokenizer also returns new state (as `int64` value).\nThis can be used to tokenize F# code more efficiently. When source code changes,\nyou do not need to re-tokenize the entire file - only the parts that have changed.\n\n### Tokenizing single line\n\nTo tokenize a single line, we create a `FSharpLineTokenizer` by calling `CreateLineTokenizer`\non the `FSharpSourceTokenizer` object that we created earlier:\n*)\nlet tokenizer = sourceTok.CreateLineTokenizer(\"let answer=42\")\n(**\nNow, we can write a simple recursive function that calls `ScanToken` on the `tokenizer`\nuntil it returns `None` (indicating the end of line). When the function succeeds, it\nreturns `FSharpTokenInfo` object with all the interesting details:\n*)\n/// Tokenize a single line of F# code\nlet rec tokenizeLine (tokenizer:FSharpLineTokenizer) state =\n  match tokenizer.ScanToken(state) with\n  | Some tok, state ->\n      // Print token name\n      printf \"%s \" tok.TokenName\n      // Tokenize the rest, in the new state\n      tokenizeLine tokenizer state\n  | None, state -> state\n(**\nThe function returns the new state, which is needed if you need to tokenize multiple lines\nand an earlier line ends with a multi-line comment. As an initial state, we can use `0L`:\n*)\ntokenizeLine tokenizer FSharpTokenizerLexState.Initial\n(**\nThe result is a sequence of tokens with names LET, WHITESPACE, IDENT, EQUALS and INT32.\nThere is a number of interesting properties on `FSharpTokenInfo` including:\n\n - `CharClass` and `ColorClass` return information about the token category that\n   can be used for colorizing F# code.\n - `LeftColumn` and `RightColumn` return the location of the token inside the line.\n - `TokenName` is the name of the token (as defined in the F# lexer)\n\nNote that the tokenizer is stateful - if you want to tokenize single line multiple times,\nyou need to call `CreateLineTokenizer` again.\n\n### Tokenizing sample code\n\nTo run the tokenizer on a longer sample code or an entire file, you need to read the\nsample input as a collection of `string` values:\n*)\nlet lines = \"\"\"\n  // Hello world\n  let hello() =\n     printfn \"Hello world!\" \"\"\".Split('\\r','\\n')\n(**\nTo tokenize multi-line input, we again need a recursive function that keeps the current\nstate. The following function takes the lines as a list of strings (together with line number\nand the current state). We create a new tokenizer for each line and call `tokenizeLine`\nusing the state from the *end* of the previous line:\n*)\n/// Print token names for multiple lines of code\nlet rec tokenizeLines state count lines =\n  match lines with\n  | line::lines ->\n      // Create tokenizer & tokenize single line\n      printfn \"\\nLine %d\" count\n      let tokenizer = sourceTok.CreateLineTokenizer(line)\n      let state = tokenizeLine tokenizer state\n      // Tokenize the rest using new state\n      tokenizeLines state (count+1) lines\n  | [] -> ()\n(**\nThe function simply calls `tokenizeLine` (defined earlier) to print the names of all\nthe tokens on each line. We can call it on the previous input with `0L` as the initial\nstate and `1` as the number of the first line:\n*)\nlines\n|> List.ofSeq\n|> tokenizeLines FSharpTokenizerLexState.Initial 1\n(**\nIgnoring some unimportant details (like whitespace at the beginning of each line and\nthe first line which is just whitespace), the code generates the following output:\n\n    [lang=text]\n    Line 1\n      LINE_COMMENT LINE_COMMENT (...) LINE_COMMENT\n    Line 2\n      LET WHITESPACE IDENT LPAREN RPAREN WHITESPACE EQUALS\n    Line 3\n      IDENT WHITESPACE STRING_TEXT (...) STRING_TEXT STRING\n\nIt is worth noting that the tokenizer yields multiple `LINE_COMMENT` tokens and multiple\n`STRING_TEXT` tokens for each single comment or string (roughly, one for each word), so\nif you want to get the entire text of a comment/string, you need to concatenate the\ntokens.\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/react.html","title":"Reacting to Changes","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Reacting to Changes\n============================================\n\nThis tutorial discusses some technical aspects of how to make sure the F# compiler service is\nproviding up-to-date results especially when hosted in an IDE. See also [project wide analysis](project.html)\nfor information on project analysis.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published.\n\nThe logical results of all \"Check\" routines (``ParseAndCheckFileInProject``, ``GetBackgroundCheckResultsForFileInProject``,\n``TryGetRecentTypeCheckResultsForFile``, ``ParseAndCheckProject``) depend on results reported by the file system,\nespecially the ``IFileSystem`` implementation described in the tutorial on [project wide analysis](project.html).\nLogically speaking, these results would be different if file system changes occur.  For example,\nreferenced DLLs may change on disk, or referenced files may change.\n\nThe ``FSharpChecker`` component from FSharp.Compiler.Service does _not_ actively \"listen\"\nto changes in the file system.  However ``FSharpChecker`` _does_ repeatedly ask for\ntime stamps from the file system which it uses to decide if recomputation is needed.\nFCS doesn't listen for changes directly - for example, it creates no ``FileWatcher`` object (and the\n``IFileSystem`` API has no ability to create such objects).  This is partly for legacy reasons,\nand partly because some hosts forbid the creation of FileWatcher objects.\n\nIn most cases the repeated timestamp requests are sufficient. If you don't actively\nlisten for changes, then ``FSharpChecker`` will still do _approximately_\nthe right thing, because it is asking for time stamps repeatedly.  However, some updates on the file system\n(such as a DLL appearing after a build, or the user randomly pasting a file into a folder)\nmay not actively be noticed by ``FSharpChecker`` until some operation happens to ask for a timestamp.\nBy issuing fresh requests, you can ensure that FCS actively reassesses the state of play when\nstays up-to-date when changes are observed.\n\nIf you want to more actively listen for changes, then you should add watchers for the\nfiles specified in the ``DependencyFiles`` property of ``FSharpCheckFileResults`` and ``FSharpCheckProjectResults``.\nHere�s what you need to do:\n\n* When your client notices an CHANGE event on a DependencyFile, it should schedule a refresh call to perform the ParseAndCheckFileInProject (or other operation) again.\n  This will result in fresh FileSystem calls to compute time stamps.\n\n* When your client notices an ADD event on a DependencyFile, it should call ``checker.InvalidateConfiguration``\n  for all active projects in which the file occurs. This will result in fresh FileSystem calls to compute time\n  stamps, and fresh calls to compute whether files exist.\n\n* Generally clients don�t listen for DELETE events on files.  Although it would be logically more consistent\n  to do so, in practice it�s very irritating for a \"project clean\" to invalidate all intellisense and\n  cause lots of red squiggles.  Some source control tools also make a change by removing and adding files, which\n  is best noticed as a single change event.\n\n\n\nIf your host happens to be Visual Studio, then this is one technique you can use:\n* Listeners should be associated with a visual source file buffer\n* Use fragments like this to watch the DependencyFiles:\n\n        // Get the service\n        let vsFileWatch = fls.GetService(typeof<SVsFileChangeEx >) :?> IVsFileChangeEx\n\n        // Watch the Add and Change events\n        let fileChangeFlags =\n            uint32 (_VSFILECHANGEFLAGS.VSFILECHG_Add |||\n                    // _VSFILECHANGEFLAGS.VSFILECHG_Del ||| // don't listen for deletes - if a file (such as a 'Clean'ed project reference) is deleted, just keep using stale info\n                    _VSFILECHANGEFLAGS.VSFILECHG_Time)\n\n        // Advise on file changes...\n        let cookie = Com.ThrowOnFailure1(vsFileWatch.AdviseFileChange(file, fileChangeFlags, changeEvents))\n\n        ...\n\n        // Unadvised file changes...\n        Com.ThrowOnFailure0(vsFileWatch.UnadviseFileChange(cookie))\n\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/untypedtree.html","title":"Processing untyped AST","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nCompiler Services: Processing untyped syntax tree\n=================================================\n\nThis tutorial demonstrates how to get the untyped abstract syntax tree (AST)\nfor F# code and how to walk over the tree. This can be used for creating tools\nsuch as code formatter, basic refactoring or code navigation tools. The untyped\nsyntax tree contains information about the code structure, but does not contain\ntypes and there are some ambiguities that are resolved only later by the type\nchecker. You can also combine the untyped AST information with the API available\nfrom [editor services](editor.html).\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n\n\nGetting the untyped AST\n-----------------------\n\nTo access the untyped AST, you need to create an instance of `FSharpChecker`.\nThis type represents a context for type checking and parsing and corresponds either\nto a stand-alone F# script file (e.g. opened in Visual Studio) or to a loaded project\nfile with multiple files. Once you have an instance of `FSharpChecker`, you can\nuse it to perform \"untyped parse\" which is the first step of type-checking. The\nsecond phase is \"typed parse\" and is used by [editor services](editor.html).\n\nTo use the interactive checker, reference `FSharp.Compiler.Service.dll` and open the\n`SourceCodeServices` namespace:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Text\n(**\n\n### Performing untyped parse\n\nThe untyped parse operation is very fast (compared to type checking, which can\ntake notable amount of time) and so we can perform it synchronously. First, we\nneed to create `FSharpChecker` - the constructor takes an argument that\ncan be used to notify the checker about file changes (which we ignore).\n\n*)\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n(**\n\nTo get the AST, we define a function that takes file name and the source code\n(the file is only used for location information and does not have to exist).\nWe first need to get \"interactive checker options\" which represents the context.\nFor simple tasks, you can use `GetProjectOptionsFromScriptRoot` which infers\nthe context for a script file. Then we use the `ParseFile` method and\nreturn the `ParseTree` property:\n\n*)\n/// Get untyped tree for a specified input\nlet getUntypedTree (file, input) =\n  // Get compiler options for the 'project' implied by a single script file\n  let projOptions, errors =\n      checker.GetProjectOptionsFromScript(file, input)\n      |> Async.RunSynchronously\n\n  let parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n  // Run the first phase (untyped parsing) of the compiler\n  let parseFileResults =\n      checker.ParseFile(file, input, parsingOptions)\n      |> Async.RunSynchronously\n\n  match parseFileResults.ParseTree with\n  | Some tree -> tree\n  | None -> failwith \"Something went wrong during parsing!\"\n\n(**\n\nWalking over the AST\n--------------------\n\nThe abstract syntax tree is defined as a number of discriminated unions that represent\ndifferent syntactical elements (such as expressions, patterns, declarations etc.). The best\nway to understand the AST is to look at the definitions in [`ast.fs` in the source\ncode](https://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs#L464).\n\nThe relevant parts are in the following namespace:\n*)\nopen FSharp.Compiler.SyntaxTree\n(**\n\nWhen processing the AST, you will typically write a number of mutually recursive functions\nthat pattern match on the different syntactical elements. There is a number of elements\nthat need to be supported - the top-level element is module or namespace declaration,\ncontaining declarations inside a module (let bindings, types etc.). A let declaration inside\na module then contains expression, which can contain patterns.\n\n### Walking over patterns and expressions\n\nWe start by looking at functions that walk over expressions and patterns - as we walk,\nwe print information about the visited elements. For patterns, the input is of type\n`SynPat` and has a number of cases including `Wild` (for `_` pattern), `Named` (for\n`<pat> as name`) and `LongIdent` (for a `Foo.Bar` name). Note that the parsed pattern\nis occasionally more complex than what is in the source code (in particular, `Named` is\nused more often):\n*)\n/// Walk over a pattern - this is for example used in\n/// let <pat> = <expr> or in the 'match' expression\nlet rec visitPattern = function\n  | SynPat.Wild(_) ->\n      printfn \"  .. underscore pattern\"\n  | SynPat.Named(pat, name, _, _, _) ->\n      visitPattern pat\n      printfn \"  .. named as '%s'\" name.idText\n  | SynPat.LongIdent(LongIdentWithDots(ident, _), _, _, _, _, _) ->\n      let names = String.concat \".\" [ for i in ident -> i.idText ]\n      printfn \"  .. identifier: %s\" names\n  | pat -> printfn \"  .. other pattern: %A\" pat\n(**\nThe function is recursive (for nested patterns such as `(foo, _) as bar`), but it does not\ncall any of the functions defined later (because patterns cannot contain other syntactical\nelements).\n\nThe next function iterates over expressions - this is where most of the work would be and\nthere are around 20 cases to cover (type `SynExpr.` and you'll get completion with other\noptions). In the following, we only show how to handle `if .. then ..` and `let .. = ...`:\n*)\n/// Walk over an expression - if expression contains two or three\n/// sub-expressions (two if the 'else' branch is missing), let expression\n/// contains pattern and two sub-expressions\nlet rec visitExpression = function\n  | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n      // Visit all sub-expressions\n      printfn \"Conditional:\"\n      visitExpression cond\n      visitExpression trueBranch\n      falseBranchOpt |> Option.iter visitExpression\n\n  | SynExpr.LetOrUse(_, _, bindings, body, _) ->\n      // Visit bindings (there may be multiple\n      // for 'let .. = .. and .. = .. in ...'\n      printfn \"LetOrUse with the following bindings:\"\n      for binding in bindings do\n        let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                     data, pat, retInfo, init, m, sp)) = binding\n        visitPattern pat\n        visitExpression init\n      // Visit the body expression\n      printfn \"And the following body:\"\n      visitExpression body\n  | expr -> printfn \" - not supported expression: %A\" expr\n(**\nThe `visitExpression` function will be called from a function that visits all top-level\ndeclarations inside a module. In this tutorial, we ignore types and members, but that would\nbe another source of calls to `visitExpression`.\n\n### Walking over declarations\n\nAs mentioned earlier, the AST of a file contains a number of module or namespace declarations\n(top-level node) that contain declarations inside a module (let bindings or types) or inside\na namespace (just types). The following functions walks over declarations - we ignore types,\nnested modules and all other elements and look only at top-level `let` bindings (values and\nfunctions):\n*)\n/// Walk over a list of declarations in a module. This is anything\n/// that you can write as a top-level inside module (let bindings,\n/// nested modules, type declarations etc.)\nlet visitDeclarations decls =\n  for declaration in decls do\n    match declaration with\n    | SynModuleDecl.Let(isRec, bindings, range) ->\n        // Let binding as a declaration is similar to let binding\n        // as an expression (in visitExpression), but has no body\n        for binding in bindings do\n          let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                       data, pat, retInfo, body, m, sp)) = binding\n          visitPattern pat\n          visitExpression body\n    | _ -> printfn \" - not supported declaration: %A\" declaration\n(**\nThe `visitDeclarations` function will be called from a function that walks over a\nsequence of module or namespace declarations. This corresponds, for example, to a file\nwith multiple `namespace Foo` declarations:\n*)\n/// Walk over all module or namespace declarations\n/// (basically 'module Foo =' or 'namespace Foo.Bar')\n/// Note that there is one implicitly, even if the file\n/// does not explicitly define it..\nlet visitModulesAndNamespaces modulesOrNss =\n  for moduleOrNs in modulesOrNss do\n    let (SynModuleOrNamespace(lid, isRec, isMod, decls, xml, attrs, _, m)) = moduleOrNs\n    printfn \"Namespace or module: %A\" lid\n    visitDeclarations decls\n(**\nNow that we have functions that walk over the elements of the AST (starting from declaration,\ndown to expressions and patterns), we can get AST of a sample input and run the above function.\n\nPutting things together\n-----------------------\n\nAs already discussed, the `getUntypedTree` function uses `FSharpChecker` to run the first\nphase (parsing) on the AST and get back the tree. The function requires F# source code together\nwith location of the file. The location does not have to exist (it is used only for location\ninformation) and it can be in both Unix and Windows formats:\n*)\n// Sample input for the compiler service\nlet input =\n  \"\"\"\n  let foo() =\n    let msg = \"Hello world\"\n    if true then\n      printfn \"%s\" msg\n  \"\"\"\n\n// File name in Unix format\nlet file = \"/home/user/Test.fsx\"\n\n// Get the AST of sample F# code\nlet tree = getUntypedTree(file, SourceText.ofString input)\n(**\nWhen you run the code in F# interactive, you can enter `tree;;` in the interactive console and\nsee pretty printed representation of the data structure - the tree contains a lot of information,\nso this is not particularly readable, but it gives you good idea about how the tree looks.\n\nThe returned `tree` value is again a discriminated union that can be two different cases - one case\nis `ParsedInput.SigFile` which represents F# signature file (`*.fsi`) and the other one is\n`ParsedInput.ImplFile` representing regular source code (`*.fsx` or `*.fs`). The implementation\nfile contains a sequence of modules or namespaces that we can pass to the function implemented\nin the previous step:\n*)\n// Extract implementation file details\nmatch tree with\n| ParsedInput.ImplFile(implFile) ->\n    // Extract declarations and walk over them\n    let (ParsedImplFileInput(fn, script, name, _, _, modules, _)) = implFile\n    visitModulesAndNamespaces modules\n| _ -> failwith \"F# Interface file (*.fsi) not supported.\"\n(**\nSummary\n-------\nIn this tutorial, we looked at basic of working with the untyped abstract syntax tree. This is a\ncomprehensive topic, so it is not possible to explain everything in a single article. The\n[Fantomas project](https://github.com/dungpa/fantomas) is a good example of tool based on the untyped\nAST that can help you understand more. In practice, it is also useful to combine the information here\nwith some information you can obtain from the [editor services](editor.html) discussed in the next\ntutorial.\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/compiler.html","title":"Hosted Compiler","content":"(*** hide ***)\n#I \"../../../artifacts/bin/fcs/Release/netcoreapp3.0\"\n(**\nHosted Compiler\n===============\n\nThis tutorial demonstrates how to host the F# compiler.\n\n> **NOTE:** The FSharp.Compiler.Service API is subject to change when later versions of the nuget package are published\n*)\n\n(**\n> **NOTE:** There are several options for hosting the F# compiler. The easiest one is to use the\n`fsc.exe` process and pass arguments.\n*)\n\n(**\n\n> **NOTE:** By default [compilations using FSharp.Compiler.Service reference FSharp.Core 4.3.0.0](https://github.com/fsharp/FSharp.Compiler.Service/issues/156) (matching F# 3.0).  You can override\nthis choice by passing a reference to FSharp.Core for 4.3.1.0 or later explicitly in your command-line arguments.\n\n*)\n\n(**\n---------------------------\n\nFirst, we need to reference the libraries that contain F# interactive service:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\n\n// Create an interactive checker instance\nlet checker = FSharpChecker.Create()\n\n(**\nNow write content to a temporary file:\n\n*)\nlet fn = Path.GetTempFileName()\nlet fn2 = Path.ChangeExtension(fn, \".fsx\")\nlet fn3 = Path.ChangeExtension(fn, \".dll\")\n\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\ntype C() =\n   member x.P = 1\n\nlet x = 3 + 4\n\"\"\")\n\n(**\nNow invoke the compiler:\n*)\n\nlet errors1, exitCode1 =\n    checker.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |])\n    |> Async.RunSynchronously\n\n(**\n\nIf errors occur you can see this in the 'exitCode' and the returned array of errors:\n\n*)\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\nlet x = 1.0 + \"\" // a type error\n\"\"\")\n\nlet errors1b, exitCode1b =\n    checker.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |])\n    |> Async.RunSynchronously\n\n(**\n\nCompiling to a dynamic assembly\n===============================\n\nYou can also compile to a dynamic assembly, which uses the F# Interactive code generator.\nThis can be useful if you are, for example, in a situation where writing to the file system\nis not really an option.\n\nYou still have to pass the \"-o\" option to name the output file, but the output file is not actually written to disk.\n\nThe 'None' option indicates that the initialization code for the assembly is not executed.\n*)\nlet errors2, exitCode2, dynAssembly2 =\n    checker.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], execute=None)\n     |> Async.RunSynchronously\n\n(*\nPassing 'Some' for the 'execute' parameter executes  the initialization code for the assembly.\n*)\nlet errors3, exitCode3, dynAssembly3 =\n    checker.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], Some(stdout,stderr))\n     |> Async.RunSynchronously\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/filesystem.html","title":"ファイルシステム仮想化","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: ファイルシステム仮想化\n==========================================\n\n`FSharp.Compiler.Service` にはファイルシステムを表すグローバル変数があります。\nこの変数を設定するこにより、ファイルシステムが利用できない状況でも\nコンパイラをホストすることができるようになります。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\nFileSystemの設定\n----------------\n\n以下の例ではディスクからの読み取りを行うような実装をファイルシステムに設定しています:\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen System.IO\nopen System.Collections.Generic\nopen System.Text\nopen FSharp.Compiler.AbstractIL.Internal.Library\n\nlet defaultFileSystem = Shim.FileSystem\n\nlet fileName1 = @\"c:\\mycode\\test1.fs\" // 注意: 実際には存在しないファイルのパス\nlet fileName2 = @\"c:\\mycode\\test2.fs\" // 注意: 実際には存在しないファイルのパス\n\ntype MyFileSystem() =\n    let file1 = \"\"\"\nmodule File1\n\nlet A = 1\"\"\"\n    let file2 = \"\"\"\nmodule File2\nlet B = File1.A + File1.A\"\"\"\n    let files = dict [(fileName1, file1); (fileName2, file2)]\n\n    interface IFileSystem with\n        // 読み取りおよび書き込み用にファイルをオープンする機能を実装\n        member __.FileStreamReadShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> new MemoryStream(Encoding.UTF8.GetBytes(text)) :> Stream\n            | _ -> defaultFileSystem.FileStreamReadShim(fileName)\n\n        member __.FileStreamCreateShim(fileName) =\n            defaultFileSystem.FileStreamCreateShim(fileName)\n\n        member __.IsStableFileHeuristic(fileName) =\n            defaultFileSystem.IsStableFileHeuristic(fileName)\n\n        member __.FileStreamWriteExistingShim(fileName) =\n            defaultFileSystem.FileStreamWriteExistingShim(fileName)\n\n        member __.ReadAllBytesShim(fileName) =\n            match files.TryGetValue fileName with\n            | true, text -> Encoding.UTF8.GetBytes(text)\n            | _ -> defaultFileSystem.ReadAllBytesShim(fileName)\n\n        // 一時パスおよびファイルのタイムスタンプに関連する機能を実装\n        member __.GetTempPathShim() =\n            defaultFileSystem.GetTempPathShim()\n\n        member __.GetLastWriteTimeShim(fileName) =\n            defaultFileSystem.GetLastWriteTimeShim(fileName)\n\n        member __.GetFullPathShim(fileName) =\n            defaultFileSystem.GetFullPathShim(fileName)\n\n        member __.IsInvalidPathShim(fileName) =\n            defaultFileSystem.IsInvalidPathShim(fileName)\n\n        member __.IsPathRootedShim(fileName) =\n            defaultFileSystem.IsPathRootedShim(fileName)\n\n        // ファイルの存在確認および削除に関連する機能を実装\n        member __.SafeExists(fileName) =\n            files.ContainsKey(fileName) || defaultFileSystem.SafeExists(fileName)\n\n        member __.FileDelete(fileName) =\n            defaultFileSystem.FileDelete(fileName)\n\n        // アセンブリのロードに関連する機能を実装。\n        // 型プロバイダやF# Interactiveで使用される。\n        member __.AssemblyLoadFrom(fileName) =\n            defaultFileSystem.AssemblyLoadFrom fileName\n\n        member __.AssemblyLoad(assemblyName) =\n            defaultFileSystem.AssemblyLoad assemblyName\n\nlet myFileSystem = MyFileSystem()\nShim.FileSystem <- MyFileSystem()\n\n(**\n\nFileSystemによるコンパイルの実行\n--------------------------------\n\n*)\nopen FSharp.Compiler.SourceCodeServices\n\nlet checker = FSharpChecker.Create()\nlet projectOptions =\n    let allFlags =\n        [| yield \"--simpleresolution\";\n           yield \"--noframework\";\n           yield \"--debug:full\";\n           yield \"--define:DEBUG\";\n           yield \"--optimize-\";\n           yield \"--doc:test.xml\";\n           yield \"--warn:3\";\n           yield \"--fullpaths\";\n           yield \"--flaterrors\";\n           yield \"--target:library\";\n           let references =\n             [ @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\mscorlib.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.Core.dll\";\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"]\n           for r in references do\n                 yield \"-r:\" + r |]\n\n    { ProjectFileName = @\"c:\\mycode\\compilation.fsproj\" // 現在のディレクトリで一意な名前を指定\n      ProjectId = None\n      SourceFiles = [| fileName1; fileName2 |]\n      OriginalLoadReferences = []\n      ExtraProjectInfo=None\n      Stamp = None\n      OtherOptions = allFlags\n      ReferencedProjects=[| |]\n      IsIncompleteTypeCheckEnvironment = false\n      UseScriptResolutionRules = true\n      LoadTime = System.DateTime.Now // 'Now' を指定して強制的に再読込させている点に注意\n      UnresolvedReferences = None }\n\nlet results = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\nresults.Errors\nresults.AssemblySignature.Entities.Count //2\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.Count //1\nresults.AssemblySignature.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"B\"\n\n(**\nまとめ\n------\nこのチュートリアルでは FSharp.Compiler.Service コンポーネントで使用される\nファイルシステムに注目して、グローバルな設定を変更する方法について紹介しました。\n\nこのチュートリアルの執筆時点では、以下に列挙したSystem.IOの操作に対しては\n仮想化されたファイルシステムAPIが用意されない予定になっています。\n将来のバージョンのコンパイラサービスではこれらのAPIが追加されるかもしれません。\n\n  - Path.Combine\n  - Path.DirectorySeparatorChar\n  - Path.GetDirectoryName\n  - Path.GetFileName\n  - Path.GetFileNameWithoutExtension\n  - Path.HasExtension\n  - Path.GetRandomFileName (アセンブリ内にコンパイル済みwin32リソースを生成する場合にのみ使用される)\n\n**注意:** `SourceCodeServices` API内の一部の操作では、\n引数にファイルの内容だけでなくファイル名を指定する必要があります。\nこれらのAPIにおいて、ファイル名はエラーの報告のためだけに使用されます。\n\n**注意:** 型プロバイダーコンポーネントは仮想化されたファイルシステムを使用しません。\n\n**注意:** コンパイラサービスは `--simpleresolution` が指定されていない場合、\nMSBuildを使ってアセンブリの解決を試みることがあります。\n`FileSystem` APIを使用する場合、通常はコンパイラへのフラグとして\n`--simpleresolution` を指定することになります。\nそれと同時に `--noframework` を指定します。\n.NETアセンブリに対するすべての参照を明示的に指定する必要があるでしょう。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/symbols.html","title":"シンボルの処理","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: シンボルの処理\n==================================\n\nこのチュートリアルでは、F#コンパイラによって提供される\nシンボルの扱い方についてのデモを紹介します。\nシンボルの参照に関する情報については [プロジェクト全体の分析](project.html)\nも参考にしてください。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、\n  最新のnugetパッケージの公開に伴って変更されることがあります。\n\nこれまでと同じく、 `FSharp.Compiler.Service.dll` への参照を追加した後、\n適切な名前空間をオープンし、 `FSharpChecker` のインスタンスを作成します:\n\n*)\n// F#コンパイラAPIへの参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.IO\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n\nそして特定の入力値に対して型チェックを行います:\n\n*)\n\nlet parseAndTypeCheckSingleFile (file, input) =\n    // スタンドアロンの(スクリプト)ファイルを表すコンテキストを取得\n    let projOptions, _errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let parseFileResults, checkFileResults =\n        checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n        |> Async.RunSynchronously\n\n    // 型チェックが成功(あるいは100%に到達)するまで待機\n    match checkFileResults with\n    | FSharpCheckFileAnswer.Succeeded(res) -> parseFileResults, res\n    | res -> failwithf \"Parsing did not finish... (%A)\" res\n\nlet file = \"/home/user/Test.fsx\"\n\n(**\n## ファイルに対する解決済みのシグネチャ情報を取得する\n\nファイルに対する型チェックが完了すると、\n`TypeCheckResults` の `PartialAssemblySignature` プロパティを参照することにより、\nチェック中の特定のファイルを含む、推論されたプロジェクトのシグネチャに\nアクセスすることができます。\n\nモジュールや型、属性、メンバ、値、関数、共用体、レコード型、測定単位、\nおよびその他のF#言語要素に対する完全なシグネチャ情報が参照できます。\n\nただし型付き式ツリーに対する情報は(今のところ)この方法では利用できません。\n\n*)\n\nlet input2 =\n      \"\"\"\n[<System.CLSCompliant(true)>]\nlet foo(x, y) =\n    let msg = String.Concat(\"Hello\",\" \",\"world\")\n    if true then\n        printfn \"x = %d, y = %d\" x y\n        printfn \"%s\" msg\n\ntype C() =\n    member x.P = 1\n      \"\"\"\nlet parseFileResults, checkFileResults =\n    parseAndTypeCheckSingleFile(file, input2)\n\n(**\nこれでコードに対する部分的なアセンブリのシグネチャが取得できるようになります:\n*)\nlet partialAssemblySignature = checkFileResults.PartialAssemblySignature\n\npartialAssemblySignature.Entities.Count = 1  // エンティティは1つ\n\n(**\nそしてコードを含むモジュールに関連したエンティティを取得します:\n*)\nlet moduleEntity = partialAssemblySignature.Entities.[0]\n\nmoduleEntity.DisplayName = \"Test\"\n\n(**\nそしてコード内の型定義に関連したエンティティを取得します:\n*)\nlet classEntity = moduleEntity.NestedEntities.[0]\n\n(**\nそしてコード内で定義された関数に関連した値を取得します:\n*)\nlet fnVal = moduleEntity.MembersFunctionsAndValues.[0]\n\n(**\n関数値に関するプロパティの値を確認してみましょう。\n*)\nfnVal.Attributes.Count // 1\nfnVal.CurriedParameterGroups.Count // 1\nfnVal.CurriedParameterGroups.[0].Count // 2\nfnVal.CurriedParameterGroups.[0].[0].Name // \"x\"\nfnVal.CurriedParameterGroups.[0].[1].Name // \"y\"\nfnVal.DeclarationLocation.StartLine // 3\nfnVal.DisplayName // \"foo\"\nfnVal.DeclaringEntity.Value.DisplayName // \"Test\"\nfnVal.DeclaringEntity.Value.DeclarationLocation.StartLine // 1\nfnVal.GenericParameters.Count // 0\nfnVal.InlineAnnotation // FSharpInlineAnnotation.OptionalInline\nfnVal.IsActivePattern // false\nfnVal.IsCompilerGenerated // false\nfnVal.IsDispatchSlot // false\nfnVal.IsExtensionMember // false\nfnVal.IsPropertyGetterMethod // false\nfnVal.IsImplicitConstructor // false\nfnVal.IsInstanceMember // false\nfnVal.IsMember // false\nfnVal.IsModuleValueOrMember // true\nfnVal.IsMutable // false\nfnVal.IsPropertySetterMethod // false\nfnVal.IsTypeFunction // false\n\n(**\n次に、この関数の型がファーストクラスの値として使用されているかどうかチェックします。\n(ちなみに `CurriedParameterGroups` プロパティには引数の名前など、\nより多くの情報も含まれています)\n*)\nfnVal.FullType // int * int -> unit\nfnVal.FullType.IsFunctionType // true\nfnVal.FullType.GenericArguments.[0] // int * int\nfnVal.FullType.GenericArguments.[0].IsTupleType // true\nlet argTy1 = fnVal.FullType.GenericArguments.[0].GenericArguments.[0]\n\nargTy1.TypeDefinition.DisplayName // int\n\n(**\nというわけで `int * int -> unit` という型を表現するオブジェクトが取得できて、\nその1つめの 'int' を確認できたわけです。\nまた、以下のようにすると 'int' 型についてのより詳細な情報が取得でき、\nそれが名前付きの型であり、F#の型省略形 `type int = int32` であることがわかります:\n*)\n\nargTy1.HasTypeDefinition // true\nargTy1.TypeDefinition.IsFSharpAbbreviation // true\n\n(**\n型省略形の右辺、つまり `int32` についてもチェックしてみましょう:\n*)\n\nlet argTy1b = argTy1.TypeDefinition.AbbreviatedType\nargTy1b.TypeDefinition.Namespace // Some \"Microsoft.FSharp.Core\"\nargTy1b.TypeDefinition.CompiledName // \"int32\"\n\n(**\nそして再び型省略形 `type int32 = System.Int32` から型に関する完全な情報が取得できます:\n*)\nlet argTy1c = argTy1b.TypeDefinition.AbbreviatedType\nargTy1c.TypeDefinition.Namespace // Some \"System\"\nargTy1c.TypeDefinition.CompiledName // \"Int32\"\n\n(**\nファイルに対する型チェックの結果には、\nコンパイル時に使用されたプロジェクト(あるいはスクリプト)のオプションに関する\n`ProjectContext` と呼ばれる情報も含まれています:\n*)\nlet projectContext = checkFileResults.ProjectContext\n\nfor assembly in projectContext.GetReferencedAssemblies() do\n    match assembly.FileName with\n    | None -> printfn \"コンパイル時にファイルの存在しないアセンブリを参照しました\"\n    | Some s -> printfn \"コンパイル時にアセンブリ '%s' を参照しました\" s\n\n(**\n**注意:**\n\n  - 不完全なコードが存在する場合、一部あるいはすべての属性が意図したとおりには\n    並ばないことがあります。\n  - (実際には非常によくあることですが)一部のアセンブリが見つからない場合、\n    外部アセンブリに関連する値やメンバ、エンティティにおける 'IsUnresolved' が\n    trueになることがあります。\n    IsUnresolvedによる例外に対処できるよう、堅牢なコードにしておくべきです。\n\n*)\n\n(**\n\n## プロジェクト全体に対するシンボル情報を取得する\n\nプロジェクト全体をチェックする場合、チェッカーを作成した後に `parseAndCheckScript`\nを呼び出します。\n今回の場合は単に1つのスクリプトだけが含まれたプロジェクトをチェックします。\n異なる \"projOptions\" を指定すると、巨大なプロジェクトに対する設定を\n構成することもできます。\n*)\nlet parseAndCheckScript (file, input) =\n    let projOptions, errors =\n        checker.GetProjectOptionsFromScript(file, input)\n        |> Async.RunSynchronously\n\n    let projResults =\n        checker.ParseAndCheckProject(projOptions)\n        |> Async.RunSynchronously\n\n    projResults\n\n(**\nそして特定の入力に対してこの関数を呼び出します:\n*)\n\nlet tmpFile = Path.ChangeExtension(System.IO.Path.GetTempFileName() , \"fs\")\nFile.WriteAllText(tmpFile, input2)\n\nlet projectResults = parseAndCheckScript(tmpFile, input2)\n\n\n(**\n結果は以下の通りです:\n*)\n\nlet assemblySig = projectResults.AssemblySignature\n\nassemblySig.Entities.Count = 1  // エンティティは1つ\nassemblySig.Entities.[0].Namespace  // null\nassemblySig.Entities.[0].DisplayName // \"Tmp28D0\"\nassemblySig.Entities.[0].MembersFunctionsAndValues.Count // 1\nassemblySig.Entities.[0].MembersFunctionsAndValues.[0].DisplayName // \"foo\"\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/interactive.html","title":"F# Interactiveの組み込み","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nインタラクティブサービス: F# Interactiveの組み込み\n==================================================\n\nこのチュートリアルでは、独自のアプリケーションに\nF# Interactiveを組み込む方法について紹介します。\nF# Interactiveは対話式のスクリプティング環境で、\nF#コードを高度に最適化されたILコードへとコンパイルしつつ、\nそれを即座に実行することができます。\nF# Interactiveサービスを使用すると、独自のアプリケーションに\nF#の評価機能を追加できます。\n\n> **注意:** F# Interactiveは様々な方法で組み込むことができます。\n  最も簡単な方法は `fsi.exe` プロセスとの間で標準入出力経由でやりとりする方法です。\n  このチュートリアルではF# Interactiveの機能を.NET APIで\n  直接呼び出す方法について紹介します。\n  ただし入力用のコントロールを備えていない場合、別プロセスでF# Interactiveを\n  起動するのはよい方法だといえます。\n  理由の1つとしては `StackOverflowException` を処理する方法がないため、\n  出来の悪いスクリプトによってはホストプロセスが停止させられてしまう\n  場合があるからです。\n  **.NET APIを通じてF# Interactiveを呼び出すとしても、 `--shadowcopyreferences`\n  オプションは無視されることを覚えておきましょう。**\n  詳細な議論については、[このスレッド](https://github.com/fsharp/FSharp.Compiler.Service/issues/292)\n  に目を通してみてください。\n  **注意:** もし`FSharp.Core.dll` が見つからないというエラーが出て `FsiEvaluationSession.Create`\n  に失敗した場合、 `FSharp.Core.sigdata` と `FSharp.Core.optdata` というファイルを追加してください。\n  詳しい内容は[こちら](https://fsharp.github.io/FSharp.Compiler.Service/ja/corelib.html)\n  にあります。\n\nしかしそれでもF# InteractiveサービスにはF# Interactiveを実行ファイルに埋め込んで\n実行出来る(そしてアプリケーションの各機能とやりとり出来る)、あるいは\n機能限定されたF#コード(たとえば独自のDSLによって生成されたコード)だけを\n実行させることが出来るという便利さがあります。\n\nF# Interactiveの開始\n--------------------\n\nまずF# Interactiveサービスを含むライブラリへの参照を追加します:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen FSharp.Compiler.Interactive.Shell\n\n(**\nF# Interactiveとやりとりするには、入出力を表すストリームを作成する必要があります。\nこれらのストリームを使用することで、\nいくつかのF#コードに対する評価結果を後から出力することができます:\n*)\nopen System\nopen System.IO\nopen System.Text\n\n// 入出力のストリームを初期化\nlet sbOut = new StringBuilder()\nlet sbErr = new StringBuilder()\nlet inStream = new StringReader(\"\")\nlet outStream = new StringWriter(sbOut)\nlet errStream = new StringWriter(sbErr)\n\n// コマンドライン引数を組み立てて、FSIセッションを開始する\nlet argv = [| \"C:\\\\fsi.exe\" |]\nlet allArgs = Array.append argv [|\"--noninteractive\"|]\n\nlet fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\nlet fsiSession = FsiEvaluationSession.Create(fsiConfig, allArgs, inStream, outStream, errStream)\n\n(**\nコードの評価および実行\n----------------------\n\nF# Interactiveサービスにはコードを評価するためのメソッドがいくつか用意されています。\n最初の1つは `EvalExpression` で、式を評価してその結果を返します。\n結果には戻り値が( `obj` として)含まれる他、値に対して静的に推論された型も含まれます:\n*)\n/// 式を評価して結果を返す\nlet evalExpression text =\n  match fsiSession.EvalExpression(text) with\n  | Some value -> printfn \"%A\" value.ReflectionValue\n  | None -> printfn \"結果が得られませんでした！\"\n\n(**\nこれは引数に文字列を取り、それをF#コードとして評価(つまり実行)します。\n*)\nevalExpression \"42+1\" // '43' を表示する\n\n(**\nこれは以下のように強く型付けされた方法で使うことができます:\n*)\n\n/// 式を評価して、強く型付けされた結果を返す\nlet evalExpressionTyped<'T> (text) =\n    match fsiSession.EvalExpression(text) with\n    | Some value -> value.ReflectionValue |> unbox<'T>\n    | None -> failwith \"結果が得られませんでした！\"\n\nevalExpressionTyped<int> \"42+1\"  // '43' になる\n\n\n(**\n`EvalInteraction` メソッドは画面出力機能や宣言、\nF#の式としては不正なものの、F# Interactiveコンソールには入力できるようなものなど、\n副作用を伴う命令を評価する場合に使用できます。\nたとえば `#time \"on\"` (あるいはその他のディレクティブ)や `open System` 、\nその他の宣言やトップレベルステートメントなどが該当します。\n指定するコードの終端に `;;` を入力する必要はありません。\n実行したいコードだけを入力します:\n*)\nfsiSession.EvalInteraction \"printfn \\\"bye\\\"\"\n\n\n(**\n`EvalScript` メソッドを使用すると、完全な .fsx スクリプトを評価することができます。\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 10 + 10\")\nfsiSession.EvalScript \"sample.fsx\"\n\n(**\n例外処理\n--------\n\nコードに型チェックの警告やエラーがあった場合、または評価して例外で失敗した場合、\n`EvalExpression` 、 `EvalInteraction` そして `EvalScript` ではあまりうまく処理されません。\nこれらのケースでは、 `EvalExpressionNonThrowing` 、 `EvalInteractionNonThrowing`\nそして `EvalScriptNonThrowing` を使うことが出来ます。\nこれらは結果と `FSharpErrorInfo` 値の配列の組を返します。\nこれらはエラーと警告を表します。結果の部分は実際の結果と例外のいずれかを表す\n`Choice<_,_>` です。\n\n`EvalExpression` および `EvalExpressionNonThrowing` の結果部分は\nオプションの `FSharpValue` 値です。\nその値が存在しない場合、式が .NET オブジェクトとして表現できる具体的な結果を\n持っていなかったということを指し示しています。\nこの状況は実際には入力されたどんな通常の式に対しても発生すべきではなく、\nライブラリ内で使われるプリミティブ値に対してのみ発生すべきです。\n*)\n\nFile.WriteAllText(\"sample.fsx\", \"let twenty = 'a' + 10.0\")\nlet result, warnings = fsiSession.EvalScriptNonThrowing \"sample.fsx\"\n\n// 結果を表示する\nmatch result with\n| Choice1Of2 () -> printfn \"チェックと実行はOKでした\"\n| Choice2Of2 exn -> printfn \"実行例外: %s\" exn.Message\n\n\n(**\nは次のようになります:\n\n    実行例外: Operation could not be completed due to earlier error\n*)\n\n// エラーと警告を表示する\nfor w in warnings do\n   printfn \"警告 %s 場所 %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n\n(**\nは次のようになります:\n\n    警告 The type 'float' does not match the type 'char' 場所 1,19\n    警告 The type 'float' does not match the type 'char' 場所 1,17\n\n式に対しては:\n*)\n\n\nlet evalExpressionTyped2<'T> text =\n   let res, warnings = fsiSession.EvalExpressionNonThrowing(text)\n   for w in warnings do\n       printfn \"警告 %s 場所 %d,%d\" w.Message w.StartLineAlternate w.StartColumn\n   match res with\n   | Choice1Of2 (Some value) -> value.ReflectionValue |> unbox<'T>\n   | Choice1Of2 None -> failwith \"null または結果がありません\"\n   | Choice2Of2 (exn:exn) -> failwith (sprintf \"例外 %s\" exn.Message)\n\nevalExpressionTyped2<int> \"42+1\"  // '43' になる\n\n\n(**\n並列実行\n--------\n\nデフォルトでは `EvalExpression` に渡したコードは即時実行されます。\n並列に実行するために、タスクを開始する計算を投入します:\n*)\n\nopen System.Threading.Tasks\n\nlet sampleLongRunningExpr =\n    \"\"\"\nasync {\n    // 実行したいコード\n    do System.Threading.Thread.Sleep 5000\n    return 10\n}\n  |> Async.StartAsTask\"\"\"\n\nlet task1 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\nlet task2 = evalExpressionTyped<Task<int>>(sampleLongRunningExpr)\n\n(**\n両方の計算がいま開始しました。結果を取得することが出来ます:\n*)\n\n\ntask1.Result // 完了後に結果が出てくる (最大5秒)\ntask2.Result // 完了後に結果が出てくる (最大5秒)\n\n(**\n評価コンテキスト内での型チェック\n--------------------------------\n\nF# Interactiveの一連のスクリプティングセッション中で\nコードの型チェックを実行したいような状況を考えてみましょう。\nたとえばまず宣言を評価します:\n*)\n\nfsiSession.EvalInteraction \"let xxx = 1 + 1\"\n\n(**\n\n次に部分的に完全な `xxx + xx` というコードの型チェックを実行したいとします:\n*)\n\nlet parseResults, checkResults, checkProjectResults =\n    fsiSession.ParseAndCheckInteraction(\"xxx + xx\") |> Async.RunSynchronously\n\n(**\n`parseResults` と `checkResults` はそれぞれ [エディタ](editor.html)\nのページで説明している `ParseFileResults` と `CheckFileResults` 型です。\nたとえば以下のようなコードでエラーを確認出来ます:\n*)\ncheckResults.Errors.Length // 1\n\n(**\nコードはF# Interactiveセッション内において、その時点までに実行された\n有効な宣言からなる論理的な型コンテキストと結びつく形でチェックされます。\n\nまた、宣言リスト情報やツールチップテキスト、シンボルの解決といった処理を\n要求することもできます:\n\n*)\nopen FSharp.Compiler\n\n// ツールチップを取得する\ncheckResults.GetToolTipText(1, 2, \"xxx + xx\", [\"xxx\"], FSharpTokenTag.IDENT)\n\ncheckResults.GetSymbolUseAtLocation(1, 2, \"xxx + xx\", [\"xxx\"]) // シンボル xxx\n\n(**\n'fsi'オブジェクト\n-----------------\n\nスクリプトのコードが'fsi'オブジェクトにアクセスできるようにしたい場合、\nこのオブジェクトの実装を明示的に渡さなければなりません。\n通常、FSharp.Compiler.Interactive.Settings.dll由来の1つが使われます。\n*)\n\nlet fsiConfig2 = FsiEvaluationSession.GetDefaultConfiguration(fsi)\n\n(**\n収集可能なコード生成\n--------------------\n\nFsiEvaluationSessionを使用してコードを評価すると、\n.NET の動的アセンブリを生成し、他のリソースを使用します。\n`collectible=true` を渡すことで、生成されたコードを収集可能に出来ます。\nしかしながら、例えば `EvalExpression` から返される `FsiValue` のような型を必要とする未解放のオブジェクト参照が無く、\nかつ `FsiEvaluationSession` を破棄したに違いない場合に限ってコードが収集されます。\n[収集可能なアセンブリに対する制限](https://msdn.microsoft.com/ja-jp/library/dd554932%28v=vs.110%29.aspx#Anchor_1)\nも参照してください。\n\n以下の例は200個の評価セッションを生成しています。 `collectible=true` と `use session = ...`\nの両方を使っていることに気をつけてください。\n\n収集可能なコードが正しく動いた場合、全体としてのリソース使用量は\n評価が進んでも線形には増加しないでしょう。\n*)\n\nlet collectionTest() =\n\n    for i in 1 .. 200 do\n        let defaultArgs = [|\"fsi.exe\";\"--noninteractive\";\"--nologo\";\"--gui-\"|]\n        use inStream = new StringReader(\"\")\n        use outStream = new StringWriter()\n        use errStream = new StringWriter()\n\n        let fsiConfig = FsiEvaluationSession.GetDefaultConfiguration()\n        use session = FsiEvaluationSession.Create(fsiConfig, defaultArgs, inStream, outStream, errStream, collectible=true)\n\n        session.EvalInteraction (sprintf \"type D = { v : int }\")\n        let v = session.EvalExpression (sprintf \"{ v = 42 * %d }\" i)\n        printfn \"その %d, 結果 = %A\" i v.Value.ReflectionValue\n\n// collectionTest()  <-- このようにテストを実行する"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/corelib.html","title":"FSharp.Core.dll についてのメモ","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/net461\"\n(**\nコンパイラサービス: FSharp.Core.dll についてのメモ\n==================================================\n\nあなたのアプリケーションとともに FSharp.Core を配布する\n-------------------------------------------------------\n\nFSharp.Compiler.Service.dll を利用するアプリケーションまたはプラグイン・コンポーネントをビルドする際、普通はアプリの一部として FSharp.Core.dll のコピーも含めることになるでしょう。\n\n例えば、 ``HostedCompiler.exe`` をビルドする場合、普通はあなたの ``HostedCompiler.exe`` と同じフォルダに FSharp.Core.dll (例えば 4.3.1.0)を配置します。\n\n動的コンパイルや動的実行を行う場合、FSharp.Core.optdata と FSharp.Core.sigdata も含める必要があるかもしれませんが、これらについては下記の指針をご覧ください。\n\nあなたのアプリケーションにリダイレクトをバインドする\n----------------------------------------------------\n\nFSharp.Compiler.Service.dll コンポーネントは FSharp.Core 4.3.0.0 に依存しています。通例、あなたのアプリケーションはこれより後のバージョンの FSharp.Core をターゲットにしており、FSharp.Core 4.3.0.0 をあなたのアプリケーションで用いる FSharp.Core.dll の最終バージョンにちゃんと転送させるように[バインド リダイレクト](https://msdn.microsoft.com/ja-jp/library/7wd6ex19(v=vs.110).aspx)が必要になるでしょう。バインド リダイレクト ファイルは通常ビルドツールによって自動的に生成されます。そうでない場合、下記のようなファイル(あなたのツールが ``HostedCompiler.exe`` という名前で、バインド リダイレクト ファイルが ``HostedCompiler.exe.config`` という名前の場合)を使うことが出来ます。\n\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <configuration>\n        <runtime>\n          <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n            <dependentAssembly>\n              <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\"/>\n              <bindingRedirect oldVersion=\"2.0.0.0-4.3.0.0\" newVersion=\"4.3.1.0\"/>\n            </dependentAssembly>\n            <dependentAssembly>\n              <assemblyIdentity name=\"System.Collections.Immutable\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n              <bindingRedirect oldVersion=\"1.0.0.0-1.2.0.0\" newVersion=\"1.2.1.0\" />\n            </dependentAssembly>\n          </assemblyBinding>\n        </runtime>\n    </configuration>\n\nどの FSharp.Core と .NET フレームワークがコンパイル時に参照される？\n--------------------------------------\n\nFSharp.Combiler.Service コンポーネントは多かれ少なかれ、F#コードを コンパイルするために使われるに過ぎません。特に、コマンドライン引数(あなたのツールを実行するために使われる FSharp.Core や .NET フレームワークとは違います)に明示的に FSharp.Core および/またはフレームワークのアセンブリを参照することが出来ます。\n\n特定の FSharp.Core および .NET フレームワーク アセンブリ、またはそのいずれかをターゲットにする場合、 ``--noframework`` 引数と適切なコマンドライン引数を使います:\n\n    [<Literal>]\n    let fsharpCorePath =\n        @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.1.0\\FSharp.Core.dll\"\n    let errors2, exitCode2 =\n      scs.Compile(\n        [| \"fsc.exe\"; \"--noframework\";\n           \"-r\"; fsharpCorePath;\n           \"-r\"; @\"C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorlib.dll\";\n           \"-o\"; fn3;\n           \"-a\"; fn2 |])\n\nこれらのアセンブリが配置されている場所を指定する必要があります。クロスプラットフォームに対応した方法でDLL を配置して、それらをコマンドライン引数に変換する最も簡単な方法は、[F# プロジェクトファイルをクラックする](https://fsharp.github.io/FSharp.Compiler.Service/ja/project.html)ことです。\n自分で SDK のパスを処理する代わりに、[FSharp.Compiler.Service.dll 用のテスト](https://github.com/fsharp/FSharp.Compiler.Service/blob/8a943dd3b545648690cb3bed652a469bdb6dd869/tests/service/Common.fs#L54)で使用しているようなヘルパー関数も用意されています。\n\n\nスクリプトを処理しているか ``GetCheckOptionsFromScriptRoot`` を使っている場合\n-------------------------------------------------------------------------\n\nもし SDK 配置先にある FSharp.Core.dll を明示的に参照 *していない* 場合、または ``FsiEvaluationSession`` や ``GetCheckOptionsFromScriptRoot`` を使用してスクリプトを処理している場合、以下のいずれかの方法により、暗黙的にFSharp.Core が参照されます:\n\n1. ``System.Reflection.Assembly.GetEntryAssembly()`` によって返されるホストアセンブリから静的に参照されたFSharp.Core.dll のバージョン\n\n2. ホストアセンブリに FSharp.Core への静的な参照がない場合、\n\n   - FSharp.Compiler.Service 0.x シリーズでは、FSharp.Core バージョン 4.3.0.0 への参照が付与されます\n\n   - FSharp.Compiler.Service 1.3.1.x (F# 3.1 シリーズ)では、FSharp.Core バージョン 4.3.1.0 への参照が付与されます\n\n   - FSharp.Compiler.Service 1.4.0.x (F# 4.0 シリーズ)では、FSharp.Core バージョン 4.4.0.0 への参照が付与されます\n\nFSharp.Core.optdata と FSharp.Core.sigdata を含める必要はありますか？\n--------------------------------------\n\nもしあなたのコンパイル引数が SDK 配置先にある FSharp.Core.dll を明示的に参照している場合、FSharp.Core.sigdata と FSharp.Core.optdata はその DLL と同じフォルダになければいけません(これらのファイルがインストールされていない場合、F# SDKの インストールに問題があります)。もしコンパイル引数で常に明示的に参照していたなら、FSharp.Core.optdata と FSharp.Core.sigdata はあなたのアプリケーションの一部として含める必要は *ありません* 。\n\nもしあなたが暗黙的な参照(例えば、上記のスクリプト処理など)に頼っているのなら、これはあなたのツールがアプリケーションの一部として FSharp.Core.dll を参照しているかもしれない、ということです。この場合、FSharp.Core.optdata および FSharp.Core.sigdata が FSharp.Core.dll と同じフォルダに見つからないというエラーが発生するかもしれません。 **もしあなたがアプリケーションに含めている FSharp.Core.dll を暗黙的に参照したいのであれば、FSharp.Core.sigdata と FSharp.Core.optdata もアプリケーションに追加する2つのファイルとして追加しましょう。** ``CombileToDynamicAssembly`` を使用する場合、この問題によって[アセンブリ解決中のスタックオーバーフロー](https://github.com/fsharp/FSharp.Compiler.Service/issues/258)も引き起こされるでしょう。\n\n動的コンパイルと動的コード実行を行うツール(例: ``HostedExecution.exe``)はしばしば FSharp.Core.dll を暗黙的に参照するようになっています。\nこれはつまり通常 FSharp.Core.optdata と FSharp.Core.sigdata を含んでいるということです。\n\n要約\n-------\n\nこのデザインノートでは3つのポイントを検討しました:\n\n- どの FSharp.Core.dll があなたのコンパイルツールを実行するのに使われるか\n- あなたのコンパイルツールを実行するのに使われる FSharp.Core.dll へのバインド リダイレクトを設定する方法\n- あなたのツールによって実行されるチェック時およびコンパイル時にどの FSharp.Core.dll および/またはフレームワークのアセンブリが参照されるか\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/editor.html","title":"エディタサービス","content":"\n(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: エディタサービス\n====================================\n\nこのチュートリアルはF#コンパイラによって公開されるエディタサービスの\n使用方法についてのデモです。\nこのAPIにより、Visual StudioやXamarin Studio、EmacsなどのF#エディタ内において、\n自動補完機能やツールチップ表示、引数情報のヘルプ表示、括弧の補完などの機能を\n実装することができます\n(詳細については [fsharpbindings](https://github.com/fsharp/fsharpbinding) のプロジェクトを参照してください)。\n[型無しASTを使用するチュートリアル](untypedtree.html) と同じく、\n今回も `FSharpChecker` オブジェクトを作成するところから始めます。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、最新バージョンのnugetパッケージの\n公開に伴って変更されることがあります。\n\nサンプルソースコードの型チェック\n--------------------------------\n\n[前回の(型無しASTを使った)チュートリアル](untypedtree.html) と同じく、\n`FSharp.Compiler.Service.dll` への参照を追加した後に特定の名前空間をオープンし、\n`FSharpChecker` のインスタンスを作成します:\n\n*)\n// F#コンパイラAPIを参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n\n[前回](untypedtree.html) 同様、\nコンパイラに渡されるファイルとしては特定の入力値だけであるという\nコンテキストを想定するため、 `GetCheckOptionsFromScriptRoot` を使います\n(この入力値はコンパイラによってスクリプトファイル、\nあるいはスタンドアロンのF#ソースコードとみなされます)。\n\n*)\n// サンプルの入力となる複数行文字列\nlet input =\n    \"\"\"\nopen System\n\nlet foo() =\nlet msg = String.Concat(\"Hello\",\" \",\"world\")\nif true then\nprintfn \"%s\" msg.\n\"\"\"\n// 入力値の分割とファイル名の定義\nlet inputLines = input.Split('\\n')\nlet file = \"/home/user/Test.fsx\"\n\nlet projOptions, _errors1 = checker.GetProjectOptionsFromScript(file, input) |> Async.RunSynchronously\n\nlet parsingOptions, _errors2 = checker.GetParsingOptionsFromProjectOptions(projOptions)\n\n(**\n\n型チェックを実行するには、まず `ParseFile` を使って\n入力値をパースする必要があります。\nこのメソッドを使うと [型無しAST](untypedtree.html) にアクセスできるようになります。\nしかし今回は完全な型チェックを実行するため、続けて `CheckFileInProject`\nを呼び出す必要があります。\nこのメソッドは `ParseFile` の結果も必要とするため、\nたいていの場合にはこれら2つのメソッドをセットで呼び出すことになります。\n\n*)\n// パースを実行\nlet parseFileResults =\n    checker.ParseFile(file, input, parsingOptions)\n    |> Async.RunSynchronously\n(**\n`TypeCheckResults` に備えられた興味深い機能の紹介に入る前に、\nサンプル入力に対して型チェッカーを実行する必要があります。\nF#コードにエラーがあった場合も何らかの型チェックの結果が返されます\n(ただし間違って「推測された」結果が含まれることがあります)。\n*)\n\n// 型チェックを実行\nlet checkFileAnswer =\n    checker.CheckFileInProject(parseFileResults, file, 0, input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nあるいは `ParseAndCheckFileInProject` を使用すれば1つの操作で両方のチェックを行うことができます：\n*)\n\nlet parseResults2, checkFileAnswer2 =\n    checker.ParseAndCheckFileInProject(file, 0, input, projOptions)\n    |> Async.RunSynchronously\n\n(**\nこの返り値は `CheckFileAnswer` 型で、この型に機能的に興味深いものが揃えられています...\n*)\n\nlet checkFileResults =\n    match checkFileAnswer with\n    | FSharpCheckFileAnswer.Succeeded(res) -> res\n    | res -> failwithf \"パースが完了していません... (%A)\" res\n\n(**\n\n今回は単に(状況に応じて)「Hello world」と表示するだけの\n単純な関数の型をチェックしています。\n最終行では値 `msg` に対する補完リストを表示することができるように、\n`msg.` というようにドットを追加している点に注意してください\n(今回の場合は文字列型に対する様々なメソッドが期待されます)。\n\n\n型チェックの結果を使用する\n--------------------------\n\nでは `TypeCheckResults` 型で公開されているAPIをいくつか見ていきましょう。\n一般的に、F#ソースコードエディタサービスの実装に必要な機能は\nほとんどこの型に備えられています。\n\n### ツールチップの取得\n\nツールチップを取得するには `GetToolTipTextAlternate` メソッドを使用します。\nこのメソッドには行数と文字オフセットを指定します。\nいずれも0から始まる数値です。\nサンプルコードでは3行目(0行目は空白行)、インデックス7にある文字 `f` から始まる関数\n`foo` のツールチップを取得しています\n(ツールチップは識別子の中であれば任意の位置で機能します)。\n\nまたこのメソッドにはトークンタグを指定する必要もあります。\nトークンタグは一般的には `IDENT` を指定して、識別子に対する\nツールチップが取得できるようにします\n(あるいは `#r \"...\"` を使用している場合にはアセンブリの完全パスを表示させるように\nすることもできるでしょう)。\n\n*)\n// 最後の引数に指定する、IDENTトークンのタグを取得\nopen FSharp.Compiler\n\n// 特定の位置におけるツールチップを取得\nlet tip = checkFileResults.GetToolTipText(4, 7, inputLines.[1], [\"foo\"], FSharpTokenTag.Identifier)\nprintfn \"%A\" tip\n\n(**\n\n> **注意：** `GetToolTipTextAlternate` は古い関数 `GetToolTipText` に代わるものです。\n`GetToolTipText` は0から始まる行番号を受け取るようになっていたため、非推奨になりました。\n\nこの関数には位置とトークンの種類の他にも、\n(ソースコードの変更時に役立つように)特定行の現在の内容と、\n現時点における完全修飾された `名前` を表す文字列のリストを指定する必要があります。\nたとえば完全修飾名 `System.Random` という名前を持った識別子 `Random` に対する\nツールチップを取得する場合、 `Random` という文字列が現れる場所の他に、\n`[\"System\"; \"Random\"]` という値を指定する必要があります。\n\n返り値の型は `ToolTipText` で、この型には `ToolTipElement` という\n判別共用体が含まれます。\nこの共用体は、コンパイラによって返されたツールチップの種類に応じて異なります。\n\n### 自動補完リストの取得\n\n次に紹介する `TypeCheckResults` のメソッドを使用すると、\n特定の位置における自動補完機能を実装できます。\nこの機能は任意の識別子上、\nあるいは(特定のスコープ内で利用可能な名前の一覧を取得する場合には)任意のスコープ、\nあるいは特定のオブジェクトにおけるメンバーリストを取得する場合には\n`.` の直後で呼び出すことができます。\n今回は文字列の値 `msg` に対するメンバーリストを取得することにします。\n\nそのためには最終行( `printfn \"%s\" msg.` で終わっている行)にある\nシンボル `.` の位置を指定して `GetDeclarationListInfo` を呼び出します。\nオフセットは1から始まるため、位置は `7, 23` になります。\nまた、テキストが変更されていないことを表す関数と、\n現時点において補完する必要がある識別子を指定する必要もあります。\n*)\n// 特定の位置における宣言(自動補完)を取得する\nlet decls =\n    checkFileResults.GetDeclarationListInfo\n      (Some parseFileResults, 7, inputLines.[6], PartialLongName.Empty 23, (fun _ -> []), fun _ -> false)\n      |> Async.RunSynchronously\n\n// 利用可能な項目を表示\nfor item in decls.Items do\n    printfn \" - %s\" item.Name\n(**\n\n> **注意：** `GetDeclarationListInfo` は古い関数 `GetDeclarations` に代わるものです。\n`GetDeclarations` は0から始まる行番号を受け取るようになっていたため、非推奨になりました。\nまた、将来的には現在の `GetDeclarations` が削除され、 `GetDeclarationListInfo` が\n`GetDeclarations` になる予定です。\n\nコードを実行してみると、 `Substring` や `ToUpper` 、 `ToLower` といった\n文字列に対するいつものメソッドのリストが取得できていることでしょう。\n`GetDeclarations` の5,6番目の引数( `[]` および `\"msg\"` )には\n自動補完用のコンテキストを指定します。\n今回の場合は完全名 `msg` に対する補完を行いましたが、\nたとえば `[\"System\"; \"Collections\"]` と `\"Generic\"` というように\n完全修飾された名前空間を指定して補完リストを取得することもできます。\n\n### 引数の情報を取得する\n\n次に一般的なエディタの機能としては、メソッドのオーバーロードに\n関する情報を提供するというものでしょう。\nサンプルコード中では多数のオーバーロードを持った `String.Concat` を使っています。\nこのオーバーロード一覧は `GetMethods` で取得できます。\n先ほどと同じく、このメソッドには対象とする項目の位置を0基準のオフセットで指定し\n(今回は `String.Concat` 識別子の右側の終端)、\n識別子もやはり指定します\n(これにより、コンパイラはソースコードが変更された場合でも最新の情報に追従できます):\n\n*)\n//String.Concatメソッドのオーバーロードを取得する\nlet methods =\n    checkFileResults.GetMethods(5, 27, inputLines.[4], Some [\"String\"; \"Concat\"]) |> Async.RunSynchronously\n\n// 連結された引数リストを表示\nfor mi in methods.Methods do\n    [ for p in mi.Parameters -> p.Display ]\n    |> String.concat \", \"\n    |> printfn \"%s(%s)\" methods.MethodName\n(**\nここでは `Display` プロパティを使用することで各引数に対する\nアノテーションを取得しています。\nこのプロパティは `arg0: obj` あるいは `params args: obj[]` 、\n`str0: string, str1: string` といった情報を返します。\nこれらの引数を連結した後、メソッド名とメソッドの型情報とともに表示させています。\n*)\n\n(**\n\n## 非同期操作と即時操作\n\n`CheckFileInProject` が非同期操作であることを気にされる人もいるかもしれません。\nこれはつまり、F#コードの型チェックにはある程度時間がかかることを示唆しています。\nF#コンパイラは型チェックを(自動的に)バックグラウンドで処理を進めているため、\n`CheckFileInProject` メソッドを呼び出すと非同期操作が返されることになります。\n\nまた、 `CheckFileInProjectIfReady` というメソッドもあります。\nこのメソッドは、型チェックの操作が即座に開始できない場合、\nつまりプロジェクト内の他のファイルがまだ型チェックされていない場合には\n処理が即座に返されます。\nこの場合、バックグラウンドワーカーは一定期間他の作業を進めるか、\n`FileTypeCheckStateIsDirty` イベントが発生するまでは\nファイルに対する型チェックを諦めるか、どちらか選択することになります。\n\n> [fsharpbinding](https://github.com/fsharp/fsharpbinding) プロジェクトには\n1つのF#エージェント経由ですべてのリクエストをバックグラウンドワークとして\n処理するような、より複雑な具体例も含まれています。\nエディタの機能を実装する方法としてはこちらのほうが適切です。\n\n*)\n\n\n(**\nまとめ\n------\n\n`CheckFileAnswer` にはチュートリアルで紹介していないような便利なメソッドが\n多数揃えられています。\nこれらを使用すれば特定の識別子に対する宣言の位置を取得したり、\n付加的な色情報を取得したりすることができます\n(F# 3.1では式ビルダーの識別子やクエリ演算子も着色表示されます)。\n\n最後に、直接.NET APIを呼び出すことができないようなエディタに対するサポート機能を\n実装する場合、ここで紹介した様々な機能を\n[FSharp.AutoComplete](https://github.com/fsharp/fsharpbinding/tree/master/FSharp.AutoComplete)\nプロジェクトのコマンドラインインターフェイス経由で呼び出すこともできます。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/project.html","title":"プロジェクトの分析","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス: プロジェクトの分析\n======================================\n\nこのチュートリアルではF#コンパイラによって提供されるサービスを使用して\nプロジェクト全体を分析する方法について紹介します。\n\n> **注意:** 以下で使用しているAPIは試験的なもので、\n  最新のnugetパッケージの公開に伴って変更されることがあります。\n\n\nプロジェクト全体の結果を取得する\n--------------------------------\n\n[以前の(型無しASTを使った)チュートリアル](untypedtree.html) と同じく、\nまずは `FSharp.Compiler.Service.dll` への参照追加と、適切な名前空間のオープン、\n`FSharpChecker` インスタンスの作成を行います:\n\n*)\n// F#コンパイラAPIへの参照\n#r \"FSharp.Compiler.Service.dll\"\n\nopen System\nopen System.Collections.Generic\nopen FSharp.Compiler.SourceCodeServices\n\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n\n(**\n今回のサンプル入力は以下の通りです:\n*)\n\nmodule Inputs =\n    open System.IO\n\n    let base1 = Path.GetTempFileName()\n    let fileName1 = Path.ChangeExtension(base1, \".fs\")\n    let base2 = Path.GetTempFileName()\n    let fileName2 = Path.ChangeExtension(base2, \".fs\")\n    let dllName = Path.ChangeExtension(base2, \".dll\")\n    let projFileName = Path.ChangeExtension(base2, \".fsproj\")\n    let fileSource1 = \"\"\"\nmodule M\n\ntype C() =\n    member x.P = 1\n\nlet xxx = 3 + 4\nlet fff () = xxx + xxx\n    \"\"\"\n    File.WriteAllText(fileName1, fileSource1)\n\n    let fileSource2 = \"\"\"\nmodule N\n\nopen M\n\ntype D1() =\n    member x.SomeProperty = M.xxx\n\ntype D2() =\n    member x.SomeProperty = M.fff()\n\n// 警告を発生させる\nlet y2 = match 1 with 1 -> M.xxx\n    \"\"\"\n    File.WriteAllText(fileName2, fileSource2)\n\n\n(**\n`GetProjectOptionsFromCommandLineArgs` を使用して、\n2つのファイルを1つのプロジェクトとして扱えるようにします:\n*)\n\nlet projectOptions =\n    checker.GetProjectOptionsFromCommandLineArgs\n       (Inputs.projFileName,\n        [| yield \"--simpleresolution\"\n           yield \"--noframework\"\n           yield \"--debug:full\"\n           yield \"--define:DEBUG\"\n           yield \"--optimize-\"\n           yield \"--out:\" + Inputs.dllName\n           yield \"--doc:test.xml\"\n           yield \"--warn:3\"\n           yield \"--fullpaths\"\n           yield \"--flaterrors\"\n           yield \"--target:library\"\n           yield Inputs.fileName1\n           yield Inputs.fileName2\n           let references =\n             [ @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\mscorlib.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\System.Core.dll\"\n               @\"C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\FSharp\\.NETFramework\\v4.0\\4.3.0.0\\FSharp.Core.dll\"]\n           for r in references do\n                 yield \"-r:\" + r |])\n\n(**\nそして(ディスク上に保存されたファイルを使用して)\nプロジェクト全体をチェックします:\n*)\n\nlet wholeProjectResults = checker.ParseAndCheckProject(projectOptions) |> Async.RunSynchronously\n\n(**\n発生したエラーと警告は以下のようにしてチェックできます:\n*)\nwholeProjectResults.Errors.Length // 1\nwholeProjectResults.Errors.[0].Message.Contains(\"Incomplete pattern matches on this expression\") // true\n\nwholeProjectResults.Errors.[0].StartLineAlternate // 13\nwholeProjectResults.Errors.[0].EndLineAlternate // 13\nwholeProjectResults.Errors.[0].StartColumn // 15\nwholeProjectResults.Errors.[0].EndColumn // 16\n\n(**\n推測されたプロジェクトのシグネチャをチェックします:\n*)\n[ for x in wholeProjectResults.AssemblySignature.Entities -> x.DisplayName ] // [\"N\"; \"M\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].NestedEntities -> x.DisplayName ] // [\"D1\"; \"D2\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[1].NestedEntities -> x.DisplayName ] // [\"C\"]\n[ for x in wholeProjectResults.AssemblySignature.Entities.[0].MembersFunctionsAndValues -> x.DisplayName ] // [\"y2\"]\n\n(**\nプロジェクト内の全シンボルを取得することもできます:\n*)\nlet rec allSymbolsInEntities (entities: IList<FSharpEntity>) =\n    [ for e in entities do\n          yield (e :> FSharpSymbol)\n          for x in e.MembersFunctionsAndValues do\n             yield (x :> FSharpSymbol)\n          for x in e.UnionCases do\n             yield (x :> FSharpSymbol)\n          for x in e.FSharpFields do\n             yield (x :> FSharpSymbol)\n          yield! allSymbolsInEntities e.NestedEntities ]\n\nlet allSymbols = allSymbolsInEntities wholeProjectResults.AssemblySignature.Entities\n(**\nプロジェクト全体のチェックが完了した後は、\nプロジェクト内の各ファイルに対する個別の結果を取得することもできます。\nこの処理は即座に完了し、改めてチェックが実行されることもありません。\n*)\n\nlet backgroundParseResults1, backgroundTypedParse1 =\n    checker.GetBackgroundCheckResultsForFileInProject(Inputs.fileName1, projectOptions)\n    |> Async.RunSynchronously\n\n\n(**\nそしてそれぞれのファイル内にあるシンボルを解決できます:\n*)\n\nlet xSymbol =\n    backgroundTypedParse1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\n(**\nそれぞれのシンボルに対して、シンボルへの参照を検索することもできます:\n*)\nlet usesOfXSymbol = wholeProjectResults.GetUsesOfSymbol(xSymbol.Value.Symbol)\n\n(**\n推測されたシグネチャ内にあるすべての定義済みシンボルに対して、\nそれらがどこで使用されているのかを探し出すこともできます:\n*)\nlet allUsesOfAllSignatureSymbols =\n    [ for s in allSymbols do\n         yield s.ToString(), wholeProjectResults.GetUsesOfSymbol(s) ]\n\n(**\n(ローカルスコープで使用されているものも含めて)\nプロジェクト全体で使用されているすべてのシンボルを確認することもできます：\n*)\nlet allUsesOfAllSymbols = wholeProjectResults.GetAllUsesOfAllSymbols()\n\n(**\nまた、プロジェクト内のファイルに対して、更新後のバージョンに対して\nチェックを実行するようにリクエストすることもできます\n(なお [FileSystem API](filesystem.html) を使用していない場合には、\nプロジェクト内のその他のファイルがまだディスクから\n読み取り中であることに注意してください):\n\n*)\nlet parseResults1, checkAnswer1 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName1, 0, Inputs.fileSource1, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults1 =\n    match checkAnswer1 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"想定外の終了状態です\"\n\nlet parseResults2, checkAnswer2 =\n    checker.ParseAndCheckFileInProject(Inputs.fileName2, 0, Inputs.fileSource2, projectOptions)\n    |> Async.RunSynchronously\n\nlet checkResults2 =\n    match checkAnswer2 with\n    | FSharpCheckFileAnswer.Succeeded x ->  x\n    | _ -> failwith \"想定外の終了状態です\"\n\n(**\nそして再びシンボルを解決したり、参照を検索したりすることができます:\n*)\n\nlet xSymbol2 =\n    checkResults1.GetSymbolUseAtLocation(9,9,\"\",[\"xxx\"])\n    |> Async.RunSynchronously\n\nlet usesOfXSymbol2 = wholeProjectResults.GetUsesOfSymbol(xSymbol2.Value.Symbol)\n\n(**\nあるいは(ローカルスコープで使用されているシンボルも含めて)\nファイル中で使用されているすべてのシンボルを検索することもできます：\n*)\nlet allUsesOfAllSymbolsInFile1 = checkResults1.GetAllUsesOfAllSymbolsInFile()\n\n(**\nあるいは特定のファイル中で使用されているシンボルを検索することもできます：\n*)\nlet allUsesOfXSymbolInFile1 = checkResults1.GetUsesOfSymbolInFile(xSymbol2.Value.Symbol)\n\nlet allUsesOfXSymbolInFile2 = checkResults2.GetUsesOfSymbolInFile(xSymbol2.Value.Symbol)\n\n(**\n\n複数プロジェクトの分析\n----------------------\n\n複数のプロジェクトにまたがった参照があるような、\n複数のF# プロジェクトを分析したい場合、\nそれらのプロジェクトを一旦ビルドして、\nProjectOptionsで `-r:プロジェクト-出力-までの-パス.dll` 引数を指定して\nプロジェクトの相互参照を設定すると一番簡単です。\nしかしこの場合、それぞれのプロジェクトが正しくビルド出来、\nDLLファイルが参照可能なディスク上に生成されなければいけません。\n\nたとえばIDEを操作している場合など、状況によっては\nDLLのコンパイルが通るようになる前に\nプロジェクトを参照したいことがあるでしょう。\nこの場合はProjectOptionsのReferencedProjectsを設定します。\nこの値には依存するプロジェクトのオプションを再帰的に指定します。\nそれぞれのプロジェクト参照にはやはり、\nReferencedProjectsのエントリそれぞれに対応する\n`-r:プロジェクト-出力-までの-パス.dll` というコマンドライン引数を\nProjectOptionsに設定する必要があります。\n\nプロジェクト参照が設定されると、ソースファイルからのF#プロジェクト分析処理が\nインクリメンタル分析の結果を使用して行われるようになります。\nその際にはソースファイルファイルをDLLへとコンパイルする必要はありません。\n\n相互参照を含むようなF#プロジェクトを効率よく分析するには、\nReferencedProjectsを正しく設定した後、\nそれぞれのプロジェクトを順番通りに分析していくとよいでしょう。\n\n> **注意：** プロジェクトの参照機能は試作段階です。\n  プロジェクトの参照を使用すると、依存先のプロジェクトがまだ分析中で、\n  要求したサービスがまだ利用できないことがあるため、\n  コンパイラサービスの性能が低下することがあります。\n\n> **注意：** アセンブリが型プロバイダーのコンポーネントを含む場合、\n  プロジェクト参照機能は利用できません。\n  プロジェクトの分析処理を強制しない限りはプロジェクト参照を設定しても\n  効果がありません。\n  また、分析を強制する場合にはディスク上にDLLが存在しなければいけません。\n\n*)\n\n(**\nまとめ\n------\n\nこれまで説明してきた通り、 `ParseAndCheckProject` を使用すると\nシンボルの参照などのようなプロジェクト全体の解析結果にアクセスできるようになります。\nシンボルに対する処理の詳細については [シンボル](symbols.html) のページを参照してください。\n\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/tokenizer.html","title":"F#トークナイザを使用する","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス：F#トークナイザを使用する\n============================================\n\nこのチュートリアルではF#言語トークナイザの呼び出し方を紹介します。\nF#のソースコードに対して、トークナイザは\nコードの各行にあるトークンに関する情報を含んだソースコード行のリストを生成します。\n各トークンに対してはトークンの種類や位置を取得したり、\nトークンの種類(キーワード、識別子、数値、演算子など)に応じた\n色を取得したりすることができます。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\nトークナイザの作成\n------------------\n\nトークナイザを使用するには、 `FSharp.Compiler.Service.dll` への参照を追加した後に\n`SourceCodeServices` 名前空間をオープンします：\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\n(**\nすると `FSharpSourceTokenizer` のインスタンスを作成できるようになります。\nこのクラスには2つの引数を指定します。\n最初の引数には定義済みのシンボルのリスト、\n2番目の引数にはソースコードのファイル名を指定します。\n定義済みのシンボルのリストを指定するのは、\nトークナイザが `#if` ディレクティブを処理する必要があるからです。\nファイル名はソースコードの位置を特定する場合にのみ指定する必要があります\n(存在しないファイル名でも指定できます):\n*)\nlet sourceTok = FSharpSourceTokenizer([], \"C:\\\\test.fsx\")\n(**\n`sourceTok` オブジェクトを使用することでF#ソースコードの各行を\n(繰り返し)トークン化することができます。\n\nF#コードのトークン化\n--------------------\n\nトークナイザはソースファイル全体ではなく、行単位で処理を行います。\nトークンを取得した後、トークナイザは新しいステートを( `int64` 値として)返します。\nこの値を使うとF#コードをより効率的にトークン化できます。\nつまり、ソースコードが変更された場合もファイル全体を\n再度トークン化する必要はありません。\n変更された部分だけをトークン化すればよいのです。\n\n### 1行をトークン化する\n\n1行をトークン化するには、先ほど作成した `FSharpSourceTokenizer` オブジェクトに対して\n`CreateLineTokenizer` を呼び、 `FSharpLineTokenizer` を作成します:\n*)\nlet tokenizer = sourceTok.CreateLineTokenizer(\"let answer=42\")\n(**\nそして `tokenizer` の `ScanToken` を繰り返し `None` を返すまで\n(つまり最終行に到達するまで)繰り返し呼び出すような単純な再帰関数を用意します。\nこの関数が成功すると、必要な詳細情報をすべて含んだ `FSharpTokenInfo` オブジェクトが\n返されます:\n*)\n/// F#コード1行をトークン化します\nlet rec tokenizeLine (tokenizer:FSharpLineTokenizer) state =\n  match tokenizer.ScanToken(state) with\n  | Some tok, state ->\n      // トークン名を表示\n      printf \"%s \" tok.TokenName\n      // 新しい状態で残りをトークン化\n      tokenizeLine tokenizer state\n  | None, state -> state\n(**\nこの関数は、複数行コードや複数行コメント内の前方の行をトークン化する場合に\n必要となるような新しい状態を返します。\n初期値としては `0L` を指定します:\n*)\ntokenizeLine tokenizer FSharpTokenizerLexState.Initial\n(**\nこの結果は LET WHITESPACE IDENT EQUALS INT32 という\nトークン名のシーケンスになります。\n`FSharpTokenInfo` にはたとえば以下のような興味深いプロパティが多数あります:\n\n - `CharClass` および `ColorClass` はF#コードを色づけする場合に使用できるような、\n   トークンのカテゴリに関する情報を返します。\n - `LeftColumn` および `RightColumn` は行内におけるトークンの位置を返します。\n - `TokenName` は(F# レキサ内で定義された)トークンの名前を返します。\n\nなおトークナイザはステートフルであることに注意してください。\nつまり、1行を複数回トークン化したい場合にはその都度 `CreateLineTokenizer` を\n呼び出す必要があります。\n\n### サンプルコードのトークン化\n\nトークナイザをもっと長いサンプルコードやファイル全体に対して実行する場合、\nサンプル入力を `string` のコレクションとして読み取る必要があります:\n*)\nlet lines = \"\"\"\n  // Hello world\n  let hello() =\n     printfn \"Hello world!\" \"\"\".Split('\\r','\\n')\n(**\n複数行の入力値をトークン化する場合も、現在の状態を保持するような\n再帰関数が必要になります。\n以下の関数はソースコード行を文字列のリストとして受け取ります\n(また、行番号および現在の状態も受け取ります)。\n各行に対して新しいトークナイザを作成して、\n直前の行における **最後** の状態を使って `tokenizeLine` を呼び出します:\n*)\n/// 複数行のコードに対してトークンの名前を表示します\nlet rec tokenizeLines state count lines =\n  match lines with\n  | line::lines ->\n      // トークナイザを作成して1行をトークン化\n      printfn \"\\nLine %d\" count\n      let tokenizer = sourceTok.CreateLineTokenizer(line)\n      let state = tokenizeLine tokenizer state\n      // 新しい状態を使って残りをトークン化\n      tokenizeLines state (count+1) lines\n  | [] -> ()\n(**\nここでは単に(先ほど定義した) `tokenizeLine` を呼び出して、\n各行にあるすべてのトークンの名前を表示しています。\nこの関数は先と同じく、初期状態の値 `0L` と、1行目を表す `1` を\n指定して呼び出すことができます:\n*)\nlines\n|> List.ofSeq\n|> tokenizeLines FSharpTokenizerLexState.Initial 1\n(**\n重要ではない部分(各行の先頭にある空白文字や、1行目のように空白文字しかない行)\nを除けば、このコードを実行すると以下のような出力になります:\n\n    [lang=text]\n    Line 1\n      LINE_COMMENT LINE_COMMENT (...) LINE_COMMENT\n    Line 2\n      LET WHITESPACE IDENT LPAREN RPAREN WHITESPACE EQUALS\n    Line 3\n      IDENT WHITESPACE STRING_TEXT (...) STRING_TEXT STRING\n\n注目すべきは、単一行コメントや文字列に対して、\nトークナイザが複数回(大まかにいって単語単位で) `LINE_COMMENT` や\n`STRING_TEXT` を返しているところです。\nしたがって、コメントや文字列全体をテキストとして取得したい場合には\nそれぞれのトークンを連結する必要があります。\n*)"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/untypedtree.html","title":"型無し構文木の処理","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラサービス：型無し構文木の処理\n======================================\n\nこのチュートリアルではF#コードに対する型無し抽象構文木\n(untyped abstract syntax tree: untyped AST)\nを取得する方法、および木全体を走査する方法を紹介します。\nこの処理を行うことによって、コードフォーマットツールや\n基本的なリファクタリングツール、コードナビゲーションツールなどを作成できます。\n型無し構文木にはコードの構造に関する情報が含まれていますが、\n型情報が含まれていないだけでなく、後で型チェッカーを通すまでは\n解決されないような曖昧さも残されています。\nまた、 [エディタサービス](editor.html) として提供されているAPIと\n型無しASTの情報を組み合わせることもできます。\n\n> **注釈:** 以下で使用しているAPIは試験的なもので、将来的に変更される場合があります。\n  つまりFSharp.Compiler.Service.dll には既存のものと重複する機能が多数あるため、\n  将来的にはもっときちんとした形に変更されます。\n  そのため、これらのサービスを使用するAPIには破壊的変更が加えられる可能性があります。\n\n\n型無しASTの取得\n---------------\n\n\n型無しASTにアクセスするには、 `FSharpChecker` のインスタンスを作成します。\nこれは型チェックおよびパース用のコンテキストを表す型で、、\nスタンドアロンのF#スクリプトファイル(たとえばVisual Studioで開いたファイル)、\nあるいは複数ファイルで構成されたロード済みのプロジェクトファイルの\nいずれかと結びつきます。\nこのインスタンスを作成すると、型チェックの最初のステップである\n「型無しパース」を実行できます。\n次のフェーズは「型有りパース」で、これは [エディタサービス](editor.html) で\n使用されるものです。\n\nインタラクティブチェッカーを使用するには、\n`FSharp.Compiler.Service.dll` への参照を追加した後、\n`SourceCodeServices` 名前空間をオープンします：\n*)\n#r \"FSharp.Compiler.Service.dll\"\nopen System\nopen FSharp.Compiler.SourceCodeServices\n(**\n\n### 型無しパースの実行\n\n型無しパース処理は(それなりの時間がかかる型チェック処理と比較すると)\nかなり高速なため、同期的に実行できます。\nまず `FSharpChecker` を作成します。\n\n*)\n// インタラクティブチェッカーのインスタンスを作成\nlet checker = FSharpChecker.Create()\n(**\n\nASTを取得するために、ファイル名とソースコードを受け取る関数を用意します\n(ファイル名は位置情報のためだけに使用されるもので、存在しなくても構いません)。\nまず、コンテキストを表す「インタラクティブチェッカーオプション」を\n用意する必要があります。\n単純な処理に対しては、 `GetCheckOptionsFromScriptRoot` を使えば\nスクリプトファイルのコンテキストを推測させることができます。\nそして `UntypedParse` メソッドを呼び出した後、\n`ParseTree` プロパティの値を返します:\n\n*)\n/// 特定の入力に対する型無し構文木を取得する\nlet getUntypedTree (file, input) =\n  // 1つのスクリプトファイルから推測される「プロジェクト」用の\n  // コンパイラオプションを取得する\n  let projOptions, errors =\n      checker.GetProjectOptionsFromScript(file, input)\n      |> Async.RunSynchronously\n\n  let parsingOptions, _errors = checker.GetParsingOptionsFromProjectOptions(projectOptions)\n\n  // コンパイラの第1フェーズを実行する\n  let untypedRes =\n      checker.ParseFile(file, input, parsingOptions)\n      |> Async.RunSynchronously\n\n  match untypedRes.ParseTree with\n  | Some tree -> tree\n  | None -> failwith \"パース中に何らかの問題が発生しました!\"\n\n(**\n`FSharpChecker` の詳細については\n[ APIドキュメント](../reference/microsoft-fsharp-compiler-sourcecodeservices-FSharpChecker.html)\nの他に、F# ソースコードのインラインコメントも参考になるでしょう\n( [`service.fsi` のソースコードを参照](https://github.com/fsharp/fsharp/blob/fsharp_31/src/fsharp/service/service.fsi) )。\n\nASTの走査\n---------\n\n抽象構文木は(式やパターン、宣言など)それぞれ異なる文法的要素を表現する、\n多数の判別共用体として定義されています。\nASTを理解するには\n[`ast.fs`内にあるソースコード](https://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs#L464)\nの定義を確認する方法が一番よいでしょう。\n\nASTに関連する要素は以下の名前空間に含まれています:\n*)\nopen FSharp.Compiler.Ast\n(**\n\nASTを処理する場合、異なる文法的要素に対するパターンマッチを行うような\n相互再帰関数を多数用意することになります。\nサポートすべき要素は非常に多種多様です。\nたとえばトップレベル要素としてはモジュールや名前空間の宣言、\nモジュール内における(letバインディングや型などの)宣言などがあります。\nモジュール内のlet宣言には式が含まれ、さらにこの式に\nパターンが含まれていることもあります。\n\n### パターンと式を走査する\n\nまずは式とパターンを走査する関数から始めます。\nこの関数は要素を走査しつつ、要素に関する情報を画面に表示します。\nパターンの場合、入力は `SynPat` 型であり、この型には `Wild` ( `_` パターンを表す)や\n`Named` ( `<pat> という名前` のパターン)、\n`LongIdent` ( `Foo.Bar` 形式の名前)など、多数のケースがあります。\nなお、基本的にパース後のパターンは元のソースコードの見た目よりも複雑になります\n(具体的には `Named` がかなり多数現れます):\n*)\n/// パターンの走査\n/// これは let <pat> = <expr> あるいは 'match' 式に対する例です\nlet rec visitPattern = function\n  | SynPat.Wild(_) ->\n      printfn \"  .. アンダースコアパターン\"\n  | SynPat.Named(pat, name, _, _, _) ->\n      visitPattern pat\n      printfn \"  .. 名前 '%s' のパターン\" name.idText\n  | SynPat.LongIdent(LongIdentWithDots(ident, _), _, _, _, _, _) ->\n      let names = String.concat \".\" [ for i in ident -> i.idText ]\n      printfn \"  .. 識別子: %s\" names\n  | pat -> printfn \"  .. その他のパターン: %A\" pat\n(**\nこの関数は (`bar という名前の (foo, _)` のような、\nネストされたパターンに対応するために) 再帰関数になっていますが、\n以降で定義するいずれの関数も呼び出しません\n(パターンはその他の文法的な要素を含むことができないからです)。\n\n次の関数は式全体を走査するものです。\nこれは処理の大部分が行われる関数で、\n20以上のケースをカバーすることになるでしょう\n( `SynExpr` と入力するとその他のオプションが確認できます)。\n以下のコードでは `if .. then ..` と `let .. = ...` という式を\n処理する方法だけを紹介しています:\n*)\n/// 式を走査する。\n/// 式に2つあるいは3つの部分式が含まれていた場合('else'の分岐がない場合は2つ)、\n/// let式にはパターンおよび2つの部分式が含まれる\nlet rec visitExpression = function\n  | SynExpr.IfThenElse(cond, trueBranch, falseBranchOpt, _, _, _, _) ->\n      // すべての部分式を走査\n      printfn \"条件部:\"\n      visitExpression cond\n      visitExpression trueBranch\n      falseBranchOpt |> Option.iter visitExpression\n\n  | SynExpr.LetOrUse(_, _, bindings, body, _) ->\n      // バインディングを走査\n      // ('let .. = .. and .. = .. in ...' に対しては複数回走査されることがある)\n      printfn \"以下のバインディングを含むLetOrUse:\"\n      for binding in bindings do\n        let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                     data, pat, retInfo, init, m, sp)) = binding\n        visitPattern pat\n        visitExpression init\n      // 本体の式を走査\n      printfn \"本体は以下:\"\n      visitExpression body\n  | expr -> printfn \" - サポート対象外の式: %A\" expr\n(**\n`visitExpression` 関数はモジュール内のすべてのトップレベル宣言を走査するような\n関数から呼ばれることになります。\n今回のチュートリアルでは型やメンバーを無視していますが、\nこれらを走査する場合も `visitExpression` を呼び出すことになるでしょう。\n\n### 宣言を走査する\n\n既に説明したように、1つのファイルに対するASTには多数のモジュールや\n名前空間の宣言が(トップレベルノードとして)含まれ、\nモジュール内にも(letバインディングや型の)宣言が、\n名前空間にも(こちらは単に型だけの)宣言が含まれます。\n以下の関数はそれぞれの宣言を走査します。\nただし今回は型やネストされたモジュール、その他の要素については無視して、\nトップレベルの(値および関数に対する) `let` バインディングだけを対象にしています:\n*)\n/// モジュール内の宣言リストを走査する。\n/// モジュール内のトップレベルに記述できるすべての要素\n/// (letバインディングやネストされたモジュール、型の宣言など)が対象になる。\nlet visitDeclarations decls =\n  for declaration in decls do\n    match declaration with\n    | SynModuleDecl.Let(isRec, bindings, range) ->\n        // 宣言としてのletバインディングは\n        // (visitExpressionで処理したような)式としてのletバインディングと\n        // 似ているが、本体を持たない\n        for binding in bindings do\n          let (Binding(access, kind, inlin, mutabl, attrs, xmlDoc,\n                       data, pat, retInfo, body, m, sp)) = binding\n          visitPattern pat\n          visitExpression body\n    | _ -> printfn \" - サポート対象外の宣言: %A\" declaration\n(**\n`visitDeclarations` 関数はモジュールや名前空間の宣言のシーケンスを走査する\n関数から呼ばれることになります。\nこのシーケンスはたとえば複数の `namespace Foo` 宣言を含むようなファイルに対応します:\n*)\n/// すべてのモジュールや名前空間の宣言を走査する\n/// (基本的には 'module Foo =' または 'namespace Foo.Bar' というコード)\n/// なおファイル中で明示的に定義されていない場合であっても\n/// 暗黙的にモジュールまたは名前空間の宣言が存在することに注意。\nlet visitModulesAndNamespaces modulesOrNss =\n  for moduleOrNs in modulesOrNss do\n    let (SynModuleOrNamespace(lid, isRec, isMod, decls, xml, attrs, _, m)) = moduleOrNs\n    printfn \"名前空間またはモジュール: %A\" lid\n    visitDeclarations decls\n(**\n以上でASTの要素を(宣言から始まって式やパターンに至るまで)走査するための\n関数がそろったので、サンプル入力からASTを取得した後、\n上記の関数を実行することができるようになりました。\n\nすべてを組み合わせる\n--------------------\n\n既に説明したように、 `getUntypedTree` 関数では `FSharpChecker` を使って\nASTに対する第1フェーズ(パース)を行ってツリーを返しています。\nこの関数にはF#のソースコードとともに、ファイルのパスを指定する必要があります。\n(単に位置情報として利用されるだけなので)\n指定先のパスにファイルが存在している必要はなく、\nUnixとWindowsどちらの形式でも指定できます:\n*)\n// コンパイラサービスへのサンプル入力\nlet input = \"\"\"\n  let foo() =\n    let msg = \"Hello world\"\n    if true then\n      printfn \"%s\" msg \"\"\"\n// Unix形式のファイル名\nlet file = \"/home/user/Test.fsx\"\n\n// サンプルF#コードに対するASTを取得\nlet tree = getUntypedTree(file, input)\n(**\nこのコードをF# Interactiveで実行した場合、コンソールに `tree;;` と入力すると、\nデータ構造に対する文字列表現が表示されることが確認できます。\nツリーには大量の情報が含まれているため、あまり読みやすいものではありませんが、\n木が動作する様子を想像することはできるでしょう。\n\n`tree` の返値はやはり判別共用体で、2つのケースに分かれます。\n1つはF#のシグネチャファイル( `*.fsi` )を表す `ParsedInput.SigFile` で、\nもう1つは通常のソースコード( `*.fsx` または `*.fs` )を表す\n`ParsedInput.ImplFile` です。\n上記の手順で作成した関数に渡すことができるモジュールや名前空間のシーケンスは\n実装ファイルに含まれています:\n*)\n// 実装ファイルの詳細をチェックする\nmatch tree with\n| ParsedInput.ImplFile(implFile) ->\n    // 宣言を展開してそれぞれを走査する\n    let (ParsedImplFileInput(fn, script, name, _, _, modules, _)) = implFile\n    visitModulesAndNamespaces modules\n| _ -> failwith \"F# インターフェイスファイル (*.fsi) は未サポートです。\"\n(**\nまとめ\n------\nこのチュートリアルでは型無し抽象構文木に対する基本的な走査方法を紹介しました。\nこのトピックは包括的なものであるため、1つの記事ですべてを説明することは不可能です。\nさらに深く理解するためには、型無しASTを活用するツールのよい例として\n[Fantomas project](https://github.com/dungpa/fantomas) を参考にするとよいでしょう。\n実際には今回参照したような情報と、次のチュートリアルで説明する\n[エディタサービス](editor.html) から得られる情報とを\n組み合わせて利用することになるでしょう。\n*)\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/ja/compiler.html","title":"コンパイラの組み込み","content":"(*** hide ***)\n#I \"../../../../artifacts/bin/fcs/Release/net461\"\n(**\nコンパイラの組み込み\n====================\n\nこのチュートリアルではF#コンパイラをホストする方法を紹介します。\n\n> **注意:** 以下で使用しているAPIは実験的なもので、\n  新しいnugetパッケージの公開に伴って変更される可能性があります。\n\n> **注意:** F#コンパイラをホストする方法はいくつかあります。\n  一番簡単な方法は `fsc.exe` のプロセスを使って引数を渡す方法です。\n\n---------------------------\n\nまず、F# Interactiveサービスを含むライブラリへの参照を追加します:\n*)\n\n#r \"FSharp.Compiler.Service.dll\"\nopen FSharp.Compiler.SourceCodeServices\nopen System.IO\n\nlet scs = FSharpChecker.Create()\n\n(**\n次に、一時ファイルへコンテンツを書き込みます:\n\n*)\nlet fn = Path.GetTempFileName()\nlet fn2 = Path.ChangeExtension(fn, \".fs\")\nlet fn3 = Path.ChangeExtension(fn, \".dll\")\n\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\ntype C() =\n   member x.P = 1\n\nlet x = 3 + 4\n\"\"\")\n\n(**\nそしてコンパイラを呼び出します:\n*)\n\nlet errors1, exitCode1 = scs.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |]) |> Async.RunSynchronously\n\n(**\n\nエラーが発生した場合は「終了コード」とエラーの配列から原因を特定できます:\n\n*)\nFile.WriteAllText(fn2, \"\"\"\nmodule M\n\nlet x = 1.0 + \"\" // a type error\n\"\"\")\n\nlet errors1b, exitCode1b = scs.Compile([| \"fsc.exe\"; \"-o\"; fn3; \"-a\"; fn2 |]) |> Async.RunSynchronously\n\nif exitCode1b <> 0 then\n    errors1b\n    |> Array.iter (printfn \"%A\")\n\n(**\n\n動的アセンブリへのコンパイル\n============================\n\nコードを動的アセンブリとしてコンパイルすることもできます。\n動的アセンブリはF# Interactiveコードジェネレータでも使用されています。\n\nこの機能はたとえばファイルシステムが必ずしも利用できないような状況で役に立ちます。\n\n出力ファイルの名前を指定する \"-o\" オプションを指定することは可能ですが、\n実際には出力ファイルがディスク上に書き込まれることはありません。\n\n'execute' 引数に 'None' を指定するとアセンブリ用の初期化コードが実行されません。\n*)\nlet errors2, exitCode2, dynAssembly2 =\n    scs.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], execute=None) |> Async.RunSynchronously\n\n(**\n'Some' を指定するとアセンブリ用の初期化コードが実行されます。\n*)\nlet errors3, exitCode3, dynAssembly3 =\n    scs.CompileToDynamicAssembly([| \"-o\"; fn3; \"-a\"; fn2 |], Some(stdout,stderr)) |> Async.RunSynchronously\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/index.html","title":"FSharp.Compiler.Service - API Reference","content":"FSharp.Compiler.Service \n FSharp.Compiler FSharp.Compiler.AbstractIL FSharp.Compiler.AbstractIL.Internal FSharp.Compiler.Interactive FSharp.Compiler.SourceCodeServices FSharp.Compiler.Text Internal.Utilities Internal.Utilities.StructuredFormat Microsoft.DotNet.DependencyManager"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-compilerglobalstate.html","title":"CompilerGlobalState","content":"CompilerGlobalState \n <p>Defines the global environment for all type checking.</p>\n\n \n  \n NiceNameGenerator <p>Generates compiler-generated names. Each name generated also includes the StartLine number of the range passed in\nat the point of first generation.</p>\n<p>This type may be accessed concurrently, though in practice it is only used from the compilation thread.\nIt is made concurrency-safe since a global instance of the type is allocated in tast.fs, and it is good\npolicy to make all globally-allocated objects concurrency safe in case future versions of the compiler\nare used to host multiple concurrent instances of compilation.</p>\n\n StableNiceNameGenerator <p>Generates compiler-generated names marked up with a source code location, but if given the same unique value then\nreturn precisely the same name. Each name generated also includes the StartLine number of the range passed in\nat the point of first generation.</p>\n<p>This type may be accessed concurrently, though in practice it is only used from the compilation thread.\nIt is made concurrency-safe since a global instance of the type is allocated in tast.fs.</p>\n\n Unique <p>Unique name generator for stamps attached to lambdas and object expressions</p>\n\n \n newUnique  newStamp <p>Unique name generator for stamps attached to to val<em>specs, tycon</em>specs etc.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger.html","title":"ErrorLogger","content":"ErrorLogger \n  \n BuildPhaseSubcategory <p>Literal build phase subcategory strings.</p>\n\n ErrorLoggerExtensions  OperationResult  \n BuildPhase <p>Closed enumeration of build phases.</p>\n\n CapturingErrorLogger  Deprecated  Error  ErrorLogger  ErrorStyle <p>Represents the style being used to format errors</p>\n\n ErrorWithSuggestions  Exiter  Experimental  FSharpErrorSeverityOptions  ImperativeOperationResult  InternalError  LibraryUseOnly  NumberedError  OperationResult<'T>  PhasedDiagnostic  PossibleUnverifiableCode  ReportedError <p>Thrown when immediate, local error recovery is not possible. This indicates\nwe've reported an error but need to make a non-local transfer of control.\nError recovery may catch this and continue (see 'errorRecovery')</p>\n<p>The exception that caused the report is carried as data because in some\nsituations (LazyWithContext) we may need to re-report the original error\nwhen a lazy thunk is re-evaluated.</p>\n\n StopProcessingExn <p>Thrown when we stop processing the F# Interactive entry or #load.</p>\n\n Suggestions  TrackErrorsBuilder  UnresolvedPathReference  UnresolvedPathReferenceNoRange  UnresolvedReferenceError  UnresolvedReferenceNoRange  UserCompilerMessage  WrappedError <p>Thrown when we want to add some range information to a .NET exception</p>\n\n \n findOriginalException  NoSuggestions  StopProcessing  protectAssemblyExploration  protectAssemblyExplorationF  protectAssemblyExplorationNoReraise  AttachRange  QuitProcessExiter  DiscardErrorsLogger  AssertFalseErrorLogger  PushThreadBuildPhaseUntilUnwind <p>NOTE: The change will be undone when the returned \"unwind\" object disposes</p>\n\n PushErrorLoggerPhaseUntilUnwind <p>NOTE: The change will be undone when the returned \"unwind\" object disposes</p>\n\n SetThreadBuildPhaseNoUnwind  SetThreadErrorLoggerNoUnwind  errorR <p>Raises an exception with error recovery and returns unit.</p>\n\n warning <p>Raises a warning with error recovery and returns unit.</p>\n\n error <p>Raises a special exception and returns 'T - can be caught later at an errorRecovery point.</p>\n\n simulateError <p>Simulates an error. For test purposes only.</p>\n\n diagnosticSink  errorSink  warnSink  errorRecovery  stopProcessingRecovery  errorRecoveryNoRange  report  deprecatedWithError  reportLibraryOnlyFeatures  libraryOnlyError  libraryOnlyWarning  deprecatedOperator  mlCompatWarning  suppressErrorReporting  conditionallySuppressErrorReporting  ReportWarnings  CommitOperationResult  RaiseOperationResult  ErrorD  WarnD  CompleteD  ResultD  CheckNoErrorsAndGetWarnings  ( ++ ) <p>The bind in the monad. Stop on first error. Accumulate warnings and continue.</p>\n\n IterateD <p>Stop on first error. Accumulate warnings and continue.</p>\n\n WhileD  MapD  trackErrors  OptionD <p>Stop on first error. Accumulate warnings and continue.</p>\n\n IterateIdxD <p>Stop on first error. Report index</p>\n\n Iterate2D <p>Stop on first error. Accumulate warnings and continue.</p>\n\n TryD <p>Keep the warnings, propagate the error to the exception continuation.</p>\n\n RepeatWhileD  AtLeastOneD  stringThatIsAProxyForANewlineInFlatErrors  NewlineifyErrorString  NormalizeErrorString <p>fixes given string by replacing all control chars with spaces.\nNOTE: newlines are recognized and replaced with stringThatIsAProxyForANewlineInFlatErrors (ASCII 29, the 'group separator'),\nwhich is decoded by the IDE with 'NewlineifyErrorString' back into newlines, so that multi-line errors can be displayed in QuickInfo</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-buildphasesubcategory.html","title":"BuildPhaseSubcategory","content":"BuildPhaseSubcategory \n <p>Literal build phase subcategory strings.</p>\n\n \n  \n  \n DefaultPhase  Compile  Parameter  Parse  TypeCheck  CodeGen  Optimize  IlxGen  IlGen  Output  Interactive  Internal  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-errorloggerextensions.html","title":"ErrorLoggerExtensions","content":"ErrorLoggerExtensions \n  \n  \n  \n tryAndDetectDev15  PreserveStackTrace <p>Instruct the exception not to reset itself when thrown again.</p>\n\n ReraiseIfWatsonable <p>Reraise an exception if it is one we want to report to Watson.</p>\n\n \n ErrorR  Warning  Error  SimulateError  ErrorRecovery  StopProcessingRecovery  ErrorRecoveryNoRange "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-operationresult.html","title":"OperationResult","content":"OperationResult \n  \n  \n  \n ignore  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout.html","title":"Layout","content":"Layout \n <p>DSL to create structured layout objects with optional breaks and render them</p>\n\n \n LeftL  RightL  SepL  TaggedTextOps  WordL  \n LayoutRenderer<'a, 'b> <p>Render a Layout yielding an 'a using a 'b (hidden state) type</p>\n\n LayoutTag  NavigableTaggedText  NoResult  NoState  TaggedText  layout  \n mkNav  emptyL  isEmptyL  wordL  sepL  rightL  leftL  ( ^^ ) <p>never break \"glue\"</p>\n\n ( ++ ) <p>optional break, indent=0</p>\n\n ( -- )  ( --- ) <p>optional break, indent=2</p>\n\n ( ---- ) <p>optional break, indent=3</p>\n\n ( ----- ) <p>optional break, indent=4</p>\n\n ( @@ ) <p>non-optional break ident=0</p>\n\n ( @@- ) <p>non-optional break ident=1</p>\n\n ( @@-- ) <p>non-optional break ident=2</p>\n\n commaListL  spaceListL  semiListL  sepListL  bracketL  tupleL  aboveL  aboveListL  optionL  listL  squashTo  showL  outL  bufferL  renderL <p>Run a render on a Layout</p>\n\n stringR <p>Render layout to string</p>\n\n channelR <p>Render layout to channel</p>\n\n bufferR <p>Render layout to StringBuilder</p>\n\n taggedTextListR <p>Render layout to collector of TaggedText</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-leftl.html","title":"LeftL","content":"LeftL \n  \n  \n  \n leftParen  questionMark  colon  leftBracketAngle  leftBracketBar  keywordTypeof  keywordTypedefof  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-rightl.html","title":"RightL","content":"RightL \n  \n  \n  \n comma  rightParen  colon  rightBracket  rightAngle  rightBracketAngle  rightBracketBar  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-sepl.html","title":"SepL","content":"SepL \n  \n  \n  \n dot  star  colon  questionMark  leftParen  comma  space  leftBracket  leftAngle  lineBreak  rightParen  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-taggedtextops.html","title":"TaggedTextOps","content":"TaggedTextOps \n  \n Literals  \n  \n tagActivePatternCase  tagActivePatternResult  tagAlias  tagClass  tagUnion  tagUnionCase  tagDelegate  tagEnum  tagEvent  tagField  tagInterface  tagKeyword  tagLineBreak  tagMethod  tagLocal  tagRecord  tagRecordField  tagModule  tagModuleBinding  tagMember  tagNamespace  tagNumericLiteral  tagOperator  tagParameter  tagProperty  tagSpace  tagStringLiteral  tagStruct  tagTypeParameter  tagText  tagPunctuation  tagUnknownEntity  tagUnknownType  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-taggedtextops-literals.html","title":"Literals","content":"Literals \n  \n  \n  \n lineBreak  space  comma  dot  semicolon  leftParen  rightParen  leftBracket  rightBracket  leftBrace  rightBrace  leftBraceBar  rightBraceBar  leftAngle  rightAngle  equals  arrow  questionMark  colon  minus  keywordTrue  keywordFalse  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-wordl.html","title":"WordL","content":"WordL \n  \n  \n  \n arrow  star  colon  equals  keywordNew  structUnit  keywordStatic  keywordMember  keywordVal  keywordEvent  keywordWith  keywordSet  keywordGet  keywordTrue  keywordFalse  bar  keywordStruct  keywordInherit  keywordEnd  keywordNested  keywordType  keywordDelegate  keywordOf  keywordInternal  keywordPrivate  keywordAbstract  keywordOverride  keywordEnum  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers.html","title":"ParseHelpers","content":"ParseHelpers \n  \n LexbufLocalXmlDocStore <p>XmlDoc F# lexer/parser state, held in the BufferLocalStore for the lexer.\nThis is the only use of the lexer BufferLocalStore in the codebase.</p>\n\n \n LexCont  LexerEndlineContinuation <p>Specifies how the 'endline' function in the lexer should continue after\nit reaches end of line or eof. The options are to continue with 'token' function\nor to continue with 'skip' function.</p>\n\n LexerIfdefExpression  LexerIfdefStack  LexerIfdefStackEntries  LexerIfdefStackEntry  LexerWhitespaceContinuation <p>The parser defines a number of tokens for whitespace and\ncomments eliminated by the lexer.  These carry a specification of\na continuation for the lexer for continued processing after we've dealt with\nthe whitespace.</p>\n\n SyntaxError <p>The error raised by the parse<em>error</em>rich function, which is called by the parser engine\nwhen a syntax error occurs. The first object is the ParseErrorContext which contains a dump of\ninformation about the grammar at the point where the error occurred, e.g. what tokens\nare valid to shift next at that point in the grammar. This information is processed in CompileOps.fs.</p>\n\n \n LexerIfdefEval  ParseAssemblyCodeInstructions  ParseAssemblyCodeType <p>Helper for parsing the inline IL fragments.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexbuflocalxmldocstore.html","title":"LexbufLocalXmlDocStore","content":"LexbufLocalXmlDocStore \n <p>XmlDoc F# lexer/parser state, held in the BufferLocalStore for the lexer.\nThis is the only use of the lexer BufferLocalStore in the codebase.</p>\n\n \n  \n  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming.html","title":"PrettyNaming","content":"PrettyNaming \n <p>Some general F# utilities for mangling / unmangling / manipulating names.\nAnything to do with special names of identifiers and other lexical rules</p>\n\n \n CustomOperations  FSharpLib  \n ActivePatternInfo  InvalidMangledStaticArg  NameArityPair  \n parenGet  parenSet  qmark  qmarkSet  opNamePrefix <p>Prefix for compiled (mangled) operator names.</p>\n\n IsOperatorOrBacktickedName <p>Returns <code>true</code> if given string is an operator or double backticked name, e.g. ( |&gt;&gt; ) or ( long identifier ).\n(where ( long identifier ) is the display name for <code>long identifier</code>).</p>\n\n IsOperatorName <p>Returns <code>true</code> if given string is an operator display name, e.g. ( |&gt;&gt; )</p>\n\n IsMangledOpName  CompileOpName <p>Compiles an operator into a mangled operator name.\nFor example, \"!%\" becomes \"op_DereferencePercent\".\nThis function accepts both built-in and custom operators.</p>\n\n DecompileOpName <p>Decompiles a mangled operator name back into an operator.\nFor example, \"op_DereferencePercent\" becomes \"!%\".\nThis function accepts mangled names for both built-in and custom operators.</p>\n\n DemangleOperatorName  DemangleOperatorNameAsLayout  opNameCons  opNameNil  opNameEquals  opNameEqualsNullable  opNameNullableEquals  opNameNullableEqualsNullable  IsIdentifierFirstCharacter <p>The characters that are allowed to be the first character of an identifier.</p>\n\n IsIdentifierPartCharacter <p>The characters that are allowed to be in an identifier.</p>\n\n IsLongIdentifierPartCharacter <p>Is this character a part of a long identifier?</p>\n\n isTildeOnlyString  IsValidPrefixOperatorUse  IsValidPrefixOperatorDefinitionName  IsPrefixOperator  IsPunctuation  IsTernaryOperator  IsInfixOperator  IsCompilerGeneratedName  CompilerGeneratedName  GetBasicNameOfPossibleCompilerGeneratedName  CompilerGeneratedNameSuffix  TryDemangleGenericNameAndPos  DecodeGenericTypeName  DemangleGenericTypeNameWithPos  DemangleGenericTypeName  TryChopPropertyName <p>Try to chop \"get<em>\" or \"set</em>\" from a string</p>\n\n ChopPropertyName <p>Try to chop \"get<em>\" or \"set</em>\" from a string.\nIf the string does not start with \"get<em>\" or \"set</em>\", this function raises an exception.</p>\n\n SplitNamesForILPath  FSharpModuleSuffix  MangledGlobalName  IllegalCharactersInTypeAndNamespaceNames  IsActivePatternName <p>Determines if the specified name is a valid name for an active pattern.</p>\n\n ActivePatternInfoOfValName  demangleProvidedTypeName <p>Demangle the static parameters</p>\n\n mangleProvidedTypeName <p>Mangle the static parameters for a provided type or method</p>\n\n computeMangledNameWithoutDefaultArgValues <p>Mangle the static parameters for a provided type or method</p>\n\n outArgCompilerGeneratedName  ExtraWitnessMethodName  mkUnionCaseFieldName <p>Reuses generated union case field name objects for common field numbers</p>\n\n mkExceptionFieldName <p>Reuses generated exception field name objects for common field numbers</p>\n\n FsiDynamicModulePrefix <p>The prefix of the names used for the fake namespace path added to all dynamic code entries in FSI.EXE</p>\n\n unassignedTyparName  FSharpOptimizationDataResourceName  FSharpSignatureDataResourceName  FSharpOptimizationDataResourceName2  FSharpSignatureDataResourceName2  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming-customoperations.html","title":"CustomOperations","content":"CustomOperations \n  \n  \n  \n Into  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming-fsharplib.html","title":"FSharpLib","content":"FSharpLib \n  \n  \n  \n Root  RootPath  Core  CorePath  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-quickparse.html","title":"QuickParse","content":"QuickParse \n <p>Methods for cheaply and inaccurately parsing F#.</p>\n<p>These methods are very old and are mostly to do with extracting \"long identifier islands\"\nA.B.C\nfrom F# source code, an approach taken from pre-F# VS samples for implementing intelliense.</p>\n<p>This code should really no longer be needed since the language service has access to\nparsed F# source code ASTs.  However, the long identifiers are still passed back to GetDeclarations and friends in the\nF# Compiler Service and it's annoyingly hard to remove their use completely.</p>\n<p>In general it is unlikely much progress will be made by fixing this code - it will be better to\nextract more information from the F# ASTs.</p>\n<p>It's also surprising how hard even the job of getting long identifier islands can be. For example the code\nbelow is inaccurate for long identifier chains involving <code>...</code> identifiers.  And there are special cases\nfor active pattern names and so on.</p>\n\n \n  \n  \n MagicalAdjustmentConstant <p>Puts us after the last character.</p>\n\n CorrectIdentifierToken  GetCompleteIdentifierIsland <p>Given a string and a position in that string, find an identifier as\nexpected by <code>GotoDefinition</code>. This will work when the cursor is\nimmediately before the identifier, within the identifier, or immediately\nafter the identifier.</p>\n<p>'tolerateJustAfter' indicates that we tolerate being one character after the identifier, used\nfor goto-definition</p>\n<p>In general, only identifiers composed from upper/lower letters and '.' are supported, but there\nare a couple of explicitly handled exceptions to allow some common scenarios:\n- When the name contains only letters and '|' symbol, it may be an active pattern, so we\ntreat it as a valid identifier - e.g. let ( |Identity| ) a = a\n(but other identifiers that include '|' are not allowed - e.g. '||' operator)\n- It searches for double tick (<code>) to see if the identifier could be something like</code>a b``</p>\n<p>REVIEW: Also support, e.g., operators, performing the necessary mangling.\n(i.e., I would like that the name returned here can be passed as-is\n(post <code>.</code>-chopping) to `GetDeclarationLocation.)</p>\n<p>In addition, return the position where a <code>.</code> would go if we were making\na call to <code>DeclItemsForNamesAtPosition</code> for intellisense. This will\nallow us to use find the correct qualified items rather than resorting\nto the more expensive and less accurate environment lookup.</p>\n\n GetPartialLongName <p>Get the partial long name of the identifier to the left of index.</p>\n\n GetPartialLongNameEx <p>Get the partial long name of the identifier to the left of index.\nFor example, for <code>System.DateTime.Now</code> it returns PartialLongName ([|\"System\"; \"DateTime\"|], \"Now\", Some 32), where \"32\" pos of the last dot.</p>\n\n TestMemberOrOverrideDeclaration <p>Tests whether the user is typing something like \"member x.\" or \"override (<em>comment</em>) x.\"</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range.html","title":"Range","content":"Range \n  \n Line  Pos  Range  \n FileIndex <p>An index into a global tables of filenames</p>\n\n Line0 <p>Represents a line number when using zero-based line counting (used by Visual Studio)</p>\n\n Pos01 <p>Represents a position using zero-based line counting (used by Visual Studio)</p>\n\n Range01 <p>Represents a range using zero-based line counting (used by Visual Studio)</p>\n\n pos <p>Represents a position in a file</p>\n\n range <p>Represents a range within a known file</p>\n\n \n fileIndexOfFile <p>Convert a file path to an index</p>\n\n fileOfFileIndex <p>Convert an index into a file path</p>\n\n mkPos <p>Create a position for the given line and column</p>\n\n posOrder <p>Ordering on positions</p>\n\n unknownFileName  startupFileName  commandLineArgsFileName  mkFileIndexRange <p>This view of range marks uses file indexes explicitly</p>\n\n mkRange <p>This view hides the use of file indexes and just uses filenames</p>\n\n equals  trimRangeToLine <p>Reduce a range so it only covers a line</p>\n\n rangeOrder <p>not a total order, but enough to sort on ranges</p>\n\n outputPos <p>Output a position</p>\n\n outputRange <p>Output a range</p>\n\n posLt <p>Compare positions for less-than</p>\n\n posGt <p>Compare positions for greater-than</p>\n\n posEq <p>Compare positions for equality</p>\n\n posGeq <p>Compare positions for greater-than-or-equal-to</p>\n\n unionRanges <p>Union two ranges, taking their first occurring start position and last occurring end position</p>\n\n rangeContainsRange <p>Test to see if one range contains another range</p>\n\n rangeContainsPos <p>Test to see if a range contains a position</p>\n\n rangeBeforePos <p>Test to see if a range occurs fully before a position</p>\n\n rangeN <p>Make a dummy range for a file</p>\n\n pos0 <p>The zero position</p>\n\n range0 <p>The zero range</p>\n\n rangeStartup <p>A range associated with a dummy file called \"startup\"</p>\n\n rangeCmdArgs <p>A range associated with a dummy file for the command line arguments</p>\n\n stringOfPos <p>Convert a position to a string</p>\n\n stringOfRange <p>Convert a range to a string</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-line.html","title":"Line","content":"Line \n  \n  \n  \n fromZ <p>Convert a line number from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages)</p>\n\n toZ <p>Convert a line number from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-pos-0.html","title":"Pos","content":"Pos \n  \n  \n  \n fromZ <p>Convert a position from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages)</p>\n\n toZ <p>Convert a position from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-range-0.html","title":"Range","content":"Range \n  \n  \n  \n toZ <p>Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)</p>\n\n toFileZ <p>Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)</p>\n\n comparer <p>Equality comparer for range.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-referenceresolver.html","title":"ReferenceResolver","content":"ReferenceResolver \n  \n  \n ResolutionEnvironment  ResolvedFile  Resolver  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree.html","title":"SyntaxTree","content":"SyntaxTree \n  \n  \n BlockSeparator <p>Represents the location of the separator block + optional position\nof the semicolon (used for tooling support)</p>\n\n DebugPointAtFinally <p>Represents whether a debug point should be present for the 'finally' in a 'try .. finally',\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n DebugPointAtFor <p>Represents whether a debug point should be present for the 'for' in a 'for...' loop,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n DebugPointAtSequential <p>Represents whether a debug point should be present for either the\nfirst or second part of a sequential execution, that is whether the\nconstruct corresponds to a debug point in the original source.</p>\n\n DebugPointAtTry <p>Represents whether a debug point should be present for a 'try', that is whether\nthe construct corresponds to a debug point in the original source.</p>\n\n DebugPointAtWhile <p>Represents whether a debug point should be present for the 'while' in a 'while...' loop,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n DebugPointAtWith <p>Represents whether a debug point should be present for the 'with' in a 'try .. with',\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n DebugPointForBinding <p>Represents whether a debug point should be present for a 'let' binding,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n DebugPointForTarget <p>Represents whether a debug point should be present for the target\nof a decision tree, that is whether the construct corresponds to a debug\npoint in the original source.</p>\n\n ExprAtomicFlag <p>Indicates if an expression is an atomic expression.</p>\n<p>An atomic expression has no whitespace unless enclosed in parentheses, e.g.\n1, \"3\", ident, ident.[expr] and (expr). If an atomic expression has type T,\nthen the largest expression ending at the same range as the atomic expression\nalso has type T.</p>\n\n Ident <p>Represents an identifier in F# code</p>\n\n LongIdent <p>Represents a long identifier e.g. 'A.B.C'</p>\n\n LongIdentWithDots <p>Represents a long identifier with possible '.' at end.</p>\n<p>Typically dotms.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. \"Foo.Bar.\"\nThe dots mostly matter for parsing, and are typically ignored by the typechecker, but\nif dotms.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed\nmore freedom about typechecking these expressions.\nLongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)</p>\n\n MemberFlags <p>Represents the flags for a 'member' declaration</p>\n\n MemberKind <p>Note the member kind is actually computed partially by a syntax tree transformation in tc.fs</p>\n\n ParsedFsiInteraction <p>Represents a parsed syntax tree for an F# Interactive interaction</p>\n\n ParsedHashDirective <p>Represents a parsed hash directive</p>\n\n ParsedImplFile <p>Represents a parsed implementation file made up of fragments</p>\n\n ParsedImplFileFragment <p>Represents the syntax tree for the contents of a parsed implementation file</p>\n\n ParsedImplFileInput <p>Represents the full syntax tree, file name and other parsing information for an implementation file</p>\n\n ParsedInput <p>Represents the syntax tree for a parsed implementation or signature file</p>\n\n ParsedSigFile <p>Represents a parsed signature file made up of fragments</p>\n\n ParsedSigFileFragment <p>Represents the syntax tree for the contents of a parsed signature file</p>\n\n ParsedSigFileInput <p>Represents the full syntax tree, file name and other parsing information for a signature file</p>\n\n ParserDetail <p>Indicates if the construct arises from error recovery</p>\n\n QualifiedNameOfFile <p>Represents a qualifying name for anonymous module specifications and implementations,</p>\n\n RecordFieldName <p>Represents a record field name plus a flag indicating if given record field name is syntactically\ncorrect and can be used in name resolution.</p>\n\n ScopedPragma <p>Represents a scoped pragma</p>\n\n SeqExprOnly <p>Indicates if a for loop is 'for x in e1 -&gt; e2', only valid in sequence expressions</p>\n\n SynAccess <p>Represents an accessibility modifier in F# syntax</p>\n\n SynArgInfo <p>Represents the argument names and other metadata for a parameter for a member or function</p>\n\n SynArgPats <p>Represents a syntax tree for arguments patterns</p>\n\n SynAttribute <p>Represents an attribute</p>\n\n SynAttributeList <p>List of attributes enclosed in [< ... >].</p>\n\n SynAttributes  SynBinding <p>Represents a binding for a 'let' or 'member' declaration</p>\n\n SynBindingKind <p>The kind associated with a binding - \"let\", \"do\" or a standalone expression</p>\n\n SynBindingReturnInfo <p>Represents the return information in a binding for a 'let' or 'member' declaration</p>\n\n SynComponentInfo <p>Represents the syntax tree associated with the name of a type definition or module\nin signature or implementation.</p>\n<p>This includes the name, attributes, type parameters, constraints, documentation and accessibility\nfor a type definition or module. For modules, entries such as the type parameters are\nalways empty.</p>\n\n SynConst <p>The unchecked abstract syntax tree of constants in F# types and expressions.</p>\n\n SynEnumCase <p>Represents the syntax tree for one case in an enum definition.</p>\n\n SynExceptionDefn <p>Represents the right hand side of an exception declaration 'exception E = ... ' plus\nany member definitions for the exception</p>\n\n SynExceptionDefnRepr <p>Represents the right hand side of an exception declaration 'exception E = ... '</p>\n\n SynExceptionSig <p>Represents the right hand side of an exception definition in a signature file</p>\n\n SynExpr <p>Represents a syntax tree for F# expressions</p>\n\n SynField <p>Represents the syntax tree for a field declaration in a record or class</p>\n\n SynIndexerArg <p>Represents a syntax tree for an F# indexer expression argument</p>\n\n SynInterfaceImpl <p>Represents a set of bindings that implement an interface</p>\n\n SynMatchClause <p>Represents a clause in a 'match' expression</p>\n\n SynMeasure <p>Represents an unchecked syntax tree of F# unit of measure annotations.</p>\n\n SynMemberDefn <p>Represents a definition element within a type definition, e.g. 'member ... '</p>\n\n SynMemberDefns  SynMemberSig <p>Represents the syntax tree for a member signature (used in signature files, abstract member declarations\nand member constraints)</p>\n\n SynModuleDecl <p>Represents a definition within a module</p>\n\n SynModuleOrNamespace <p>Represents the definition of a module or namespace</p>\n\n SynModuleOrNamespaceKind <p>Represents the kind of a module or namespace definition</p>\n\n SynModuleOrNamespaceSig <p>Represents the definition of a module or namespace in a signature file</p>\n\n SynModuleSigDecl <p>Represents a definition within a module or namespace in a signature file</p>\n\n SynPat <p>Represents a syntax tree for an F# pattern</p>\n\n SynRationalConst <p>Represents an unchecked syntax tree of F# unit of measure exponents.</p>\n\n SynReturnInfo <p>Represents the syntactic elements associated with the \"return\" of a function or method.</p>\n\n SynSimplePat <p>Represents a syntax tree for simple F# patterns</p>\n\n SynSimplePatAlternativeIdInfo <p>Represents the alternative identifier for a simple pattern</p>\n\n SynSimplePats <p>Represents a simple set of variable bindings a, (a, b) or (a: Type, b: Type) at a lambda,\nfunction definition or other binding point, after the elimination of pattern matching\nfrom the construct, e.g. after changing a \"function pat1 -&gt; rule1 | ...\" to a\n\"fun v -&gt; match v with ...\"</p>\n\n SynStaticOptimizationConstraint <p>Represents a syntax tree for a static optimization constraint in the F# core library</p>\n\n SynTypar <p>Represents a syntactic type parameter</p>\n\n SynTyparDecl <p>Represents the explicit declaration of a type parameter</p>\n\n SynType <p>Represents a syntax tree for F# types</p>\n\n SynTypeConstraint <p>The unchecked abstract syntax tree of F# type constraints</p>\n\n SynTypeDefn <p>Represents a type or exception declaration 'type C = ... ' plus\nany additional member definitions for the type</p>\n\n SynTypeDefnKind <p>Represents the kind of a type definition whether explicit or inferred</p>\n\n SynTypeDefnRepr <p>Represents the right hand side of a type or exception declaration 'type C = ... ' plus\nany additional member definitions for the type</p>\n\n SynTypeDefnSig <p>Represents the syntax tree for a type definition in a signature</p>\n\n SynTypeDefnSigRepr <p>Represents the syntax tree for the right-hand-side of a type definition in a signature.\nNote: in practice, using a discriminated union to make a distinction between\n\"simple\" types and \"object oriented\" types is not particularly useful.</p>\n\n SynTypeDefnSimpleRepr <p>Represents the syntax tree for the core of a simple type definition, in either signature\nor implementation.</p>\n\n SynUnionCase <p>Represents the syntax tree for one case in a union definition.</p>\n\n SynUnionCaseType <p>Represents the syntax tree for the right-hand-side of union definition, excluding members,\nin either a signature or implementation.</p>\n\n SynValData <p>Represents extra information about the declaration of a value</p>\n\n SynValInfo <p>The argument names and other metadata for a member or function</p>\n\n SynValSig <p>Represents the syntax tree for a 'val' definition in an abstract slot or a signature file</p>\n\n SynValTyparDecls <p>Represents the names and other metadata for the type parameters for a member or function</p>\n\n TyparStaticReq <p>Represents whether a type parameter has a static requirement or not (^T or 'T)</p>\n\n \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtreeops.html","title":"SyntaxTreeOps","content":"SyntaxTreeOps \n  \n SynInfo <p>Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.</p>\n\n \n SynArgNameGenerator  \n ident  textOfId  pathOfLid  arrPathOfLid  textOfPath  textOfLid  rangeOfLid  mkSynId  pathToSynLid  mkSynIdGet  mkSynLidGet  mkSynIdGetWithAlt  mkSynSimplePatVar  mkSynCompGenSimplePatVar  IsControlFlowExpression <p>This affects placement of sequence points</p>\n\n mkAnonField  mkNamedField  mkSynPatVar  mkSynThisPatVar  mkSynPatMaybeVar  SimplePatOfPat <p>Push non-simple parts of a patten match over onto the r.h.s. of a lambda.\nReturn a simple pattern and a function to build a match on the r.h.s. if the pattern is complex</p>\n\n appFunOpt  composeFunOpt  SimplePatsOfPat  PushPatternToExpr  PushCurriedPatternsToExpr <p>\"fun (UnionCase x) (UnionCase y) -&gt; body\"\n==&gt;\n\"fun tmp1 tmp2 -&gt;\nlet (UnionCase x) = tmp1 in\nlet (UnionCase y) = tmp2 in\nbody\"</p>\n\n opNameParenGet  opNameQMark  mkSynOperator  mkSynInfix  mkSynBifix  mkSynTrifix  mkSynPrefixPrim  mkSynPrefix  mkSynCaseName  mkSynApp1  mkSynApp2  mkSynApp3  mkSynApp4  mkSynApp5  mkSynDotParenSet  mkSynDotBrackGet  mkSynQMarkSet  mkSynDotBrackSliceGet  mkSynDotBrackSeqSliceGet  mkSynDotParenGet  mkSynUnit  mkSynUnitPat  mkSynDelay  mkSynAssign  mkSynDot  mkSynDotMissing  mkSynFunMatchLambdas  arbExpr  unionRangeWithListBy  mkAttributeList  ConcatAttributesLists  rangeOfNonNilAttrs  stripParenTypes  mkSynBindingRhs  mkSynBinding  NonVirtualMemberFlags  CtorMemberFlags  ClassCtorMemberFlags  OverrideMemberFlags  AbstractMemberFlags  StaticMemberFlags  inferredTyparDecls  noInferredTypars  synExprContainsError  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtreeops-syninfo.html","title":"SynInfo","content":"SynInfo \n <p>Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.</p>\n\n \n  \n  \n unnamedTopArg1 <p>The argument information for an argument without a name</p>\n\n unnamedTopArg <p>The argument information for a curried argument without a name</p>\n\n unitArgData <p>The argument information for a '()' argument</p>\n\n unnamedRetVal <p>The 'argument' information for a return value where no attributes are given for the return value (the normal case)</p>\n\n selfMetadata <p>The 'argument' information for the 'this'/'self' parameter in the cases where it is not given explicitly</p>\n\n HasNoArgs <p>Determine if a syntactic information represents a member without arguments (which is implicitly a property getter)</p>\n\n IsOptionalArg <p>Check if one particular argument is an optional argument. Used when adjusting the\ntypes of optional arguments for function and member signatures.</p>\n\n HasOptionalArgs <p>Check if there are any optional arguments in the syntactic argument information. Used when adjusting the\ntypes of optional arguments for function and member signatures.</p>\n\n IncorporateEmptyTupledArgForPropertyGetter <p>Add a parameter entry to the syntactic value information to represent the '()' argument to a property getter. This is\nused for the implicit '()' argument in property getter signature specifications.</p>\n\n IncorporateSelfArg <p>Add a parameter entry to the syntactic value information to represent the 'this' argument. This is\nused for the implicit 'this' argument in member signature specifications.</p>\n\n IncorporateSetterArg <p>Add a parameter entry to the syntactic value information to represent the value argument for a property setter. This is\nused for the implicit value argument in property setter signature specifications.</p>\n\n AritiesOfArgs <p>Get the argument counts for each curried argument group. Used in some adhoc places in tc.fs.</p>\n\n AttribsOfArgData <p>Get the argument attributes from the syntactic information for an argument.</p>\n\n InferSynArgInfoFromSimplePat <p>Infer the syntactic argument info for a single argument from a simple pattern.</p>\n\n InferSynArgInfoFromSimplePats <p>Infer the syntactic argument info for one or more arguments one or more simple patterns.</p>\n\n InferSynArgInfoFromPat <p>Infer the syntactic argument info for one or more arguments a pattern.</p>\n\n AdjustArgsForUnitElimination <p>Make sure only a solitary unit argument has unit elimination</p>\n\n AdjustMemberArgs <p>Transform a property declared using '[static] member P = expr' to a method taking a \"unit\" argument.\nThis is similar to IncorporateEmptyTupledArgForPropertyGetter, but applies to member definitions\nrather than member signatures.</p>\n\n InferLambdaArgs <p>For 'let' definitions, we infer syntactic argument information from the r.h.s. of a definition, if it\nis an immediate 'fun ... -&gt; ...' or 'function ...' expression. This is noted in the F# language specification.\nThis does not apply to member definitions.</p>\n\n InferSynReturnData  emptySynValData  InferSynValData <p>Infer the syntactic information for a 'let' or 'member' definition, based on the argument pattern,\nany declared return information (e.g. .NET attributes on the return element), and the r.h.s. expression\nin the case of 'let' definitions.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-xmldoc.html","title":"XmlDoc","content":"XmlDoc \n  \n  \n PreXmlDoc <p>Represents the XmlDoc fragments as collected from the lexer during parsing</p>\n\n XmlDoc <p>Represents the final form of collected XmlDoc lines</p>\n\n XmlDocCollector <p>Used to collect XML documentation during lexing and parsing.</p>\n\n XmlDocStatics  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il.html","title":"IL","content":"IL \n <p>The \"unlinked\" view of .NET metadata and code.  Central to the Abstract IL library</p>\n\n \n  \n ILAlignment  ILArgConvention  ILArrayBound <p>Array shapes. For most purposes the rank is the only thing that matters.</p>\n\n ILArrayBounds <p>Lower-bound/size pairs</p>\n\n ILArrayShape  ILAssemblyLongevity  ILAssemblyManifest <p>The main module of an assembly is a module plus some manifest information.</p>\n\n ILAssemblyRef  ILAttribElem  ILAttribute <p>Custom attribute.</p>\n\n ILAttributeNamedArg <p>Named args: values and flags indicating if they are fields or properties.</p>\n\n ILAttributes  ILAttributesStored <p>Represents the efficiency-oriented storage of ILAttributes in another item.</p>\n\n ILBasicType  ILBoxity  ILCallingConv  ILCallingSignature  ILCode  ILCodeLabel <p>ILCode labels.  In structured code each code label refers to a basic block somewhere in the code of the method.</p>\n\n ILComparisonInstr  ILConst  ILDefaultPInvokeEncoding <p>Default Unicode encoding for P/Invoke  within a type.</p>\n\n ILEnumInfo <p>Decompose a type definition according to its kind.</p>\n\n ILEventDef <p>Event definitions.</p>\n\n ILEventDefs <p>Table of those events in a type definition.</p>\n\n ILEventRef <p>A utility type provided for completeness</p>\n\n ILExceptionClause  ILExceptionSpec  ILExportedTypeOrForwarder <p>these are only found in the ILExportedTypesAndForwarders table in the manifest</p>\n\n ILExportedTypesAndForwarders  ILFieldDef <p>Field definitions.</p>\n\n ILFieldDefs <p>Tables of fields.  Logically equivalent to a list of fields but the table is kept in\na form to allow efficient looking up fields by name.</p>\n\n ILFieldInit <p>Field Init</p>\n\n ILFieldRef <p>Formal identities of fields.</p>\n\n ILFieldSpec <p>Field specs.  The data given for a ldfld, stfld etc. instruction.</p>\n\n ILGenericArgs <p>Actual generic parameters are  always types.</p>\n\n ILGenericArgsList  ILGenericParameterDef <p>Generic parameters.  Formal generic parameter declarations may include the bounds, if any, on the generic parameter.</p>\n\n ILGenericParameterDefs  ILGenericVariance  ILGlobals <p>A table of common references to items in primary assembly (System.Runtime or mscorlib).\nIf a particular version of System.Runtime.dll has been loaded then you should\nreference items from it via an ILGlobals for that specific version built using mkILGlobals.</p>\n\n ILGuid <p>Represents guids</p>\n\n ILInstr <p>The instruction set.</p>\n\n ILLazyMethodBody  ILLocal <p>Local variables</p>\n\n ILLocalDebugInfo  ILLocalDebugMapping <p>Indicates that a particular local variable has a particular source\nlanguage name within a given set of ranges. This does not effect local\nvariable numbering, which is global over the whole method.</p>\n\n ILLocals  ILLocalsAllocator <p>Helpers for codegen: scopes for allocating new temporary variables.</p>\n\n ILMemberAccess <p>Member Access</p>\n\n ILMethodBody <p>IL method bodies</p>\n\n ILMethodDef <p>IL Method definitions.</p>\n\n ILMethodDefs <p>Tables of methods.  Logically equivalent to a list of methods but\nthe table is kept in a form optimized for looking up methods by\nname and arity.</p>\n\n ILMethodImplDef <p>Method Impls</p>\n\n ILMethodImplDefs  ILMethodRef <p>Formal identities of methods.</p>\n\n ILMethodSpec <p>The information at the callsite of a method</p>\n\n ILMethodVirtualInfo  ILModuleDef <p>One module in the \"current\" assembly, either a main-module or\nan auxiliary module.  The main module will have a manifest.</p>\n<p>An assembly is built by joining together a \"main\" module plus\nseveral auxiliary modules.</p>\n\n ILModuleRef  ILNativeResource  ILNativeType <p>Native Types, for marshalling to the native C interface.\nThese are taken directly from the ILASM syntax, see ECMA Spec (Partition II, 7.4).</p>\n\n ILNativeVariant  ILNestedExportedType <p>these are only found in the \"Nested\" field of ILExportedTypeOrForwarder objects</p>\n\n ILNestedExportedTypes  ILOverridesSpec \n ILParameter <p>Method parameters and return values.</p>\n\n ILParameters  ILPlatform  ILPreTypeDef <p>Represents a prefix of information for ILTypeDef.</p>\n<p>The information is enough to perform name resolution for the F# compiler, probe attributes\nfor ExtensionAttribute  etc.  This is key to the on-demand exploration of .NET metadata.\nThis information has to be \"Goldilocks\" - not too much, not too little, just right.</p>\n\n ILPreTypeDefImpl  ILPropertyDef <p>Property definitions</p>\n\n ILPropertyDefs <p>Table of properties in an IL type definition.</p>\n\n ILPropertyRef <p>A utility type provided for completeness</p>\n\n ILReadonly  ILReferences  ILResource <p>\"Manifest ILResources\" are chunks of resource data, being one of:\n- the data section of the current module (byte[] of resource given directly).\n- in an external file in this assembly (offset given in the ILResourceLocation field).\n- as a resources in another assembly of the same name.</p>\n\n ILResourceAccess  ILResourceLocation  ILResources <p>Table of resources in a module.</p>\n\n ILReturn <p>Method return values.</p>\n\n ILScopeRef  ILSecurityAction  ILSecurityDecl  ILSecurityDecls <p>Abstract type equivalent to ILSecurityDecl list - use helpers\nbelow to construct/destruct these.</p>\n\n ILSecurityDeclsStored <p>Represents the efficiency-oriented storage of ILSecurityDecls in another item.</p>\n\n ILSourceDocument <p>Debug info.  Values of type \"source\" can be attached at sequence\npoints and some other locations.</p>\n\n ILSourceMarker  ILTailcall  ILThisConvention  ILToken  ILType  ILTypeDef <p>Represents IL Type Definitions.</p>\n\n ILTypeDefAccess <p>Type Access.</p>\n\n ILTypeDefKind <p>A categorization of type definitions into \"kinds\"</p>\n\n ILTypeDefLayout <p>Type Layout information.</p>\n\n ILTypeDefLayoutInfo  ILTypeDefStored  ILTypeDefs <p>Tables of named type definitions.</p>\n\n ILTypeInit <p>Indicate the initialization semantics of a type.</p>\n\n ILTypeRef <p>Type refs, i.e. references to types in some .NET assembly</p>\n\n ILTypeSpec <p>Type specs and types.</p>\n\n ILTypes  ILVarArgs  ILVersionInfo  ILVolatility  MethodBody  MethodCodeKind  MethodKind  PInvokeCallingConvention <p>PInvoke attributes.</p>\n\n PInvokeCharBestFit  PInvokeCharEncoding  PInvokeMethod  PInvokeThrowOnUnmappableChar  PrimaryAssembly  PublicKey  \n typesOfILParams  mkILPreTypeDef  mkILPreTypeDefComputed  mkILPreTypeDefRead  mkILTypeDefReader  resolveILMethodRef <p>Find the method definition corresponding to the given property or\nevent operation. These are always in the same class as the property\nor event. This is useful especially if your code is not using the Ilbind\nAPI to bind references.</p>\n\n resolveILMethodRefWithRescope  splitNamespace  splitNamespaceToArray  splitILTypeName <p>The <c>splitILTypeName</c> utility helps you split a string representing\na type name into the leading namespace elements (if any), the\nnames of any nested types and the type name itself.  This function\nmemoizes and interns the splitting of the namespace portion of\nthe type name.</p>\n\n splitILTypeNameWithPossibleStaticArguments  splitTypeNameRight splitTypeNameRight is like splitILTypeName except the \n namespace is kept as a whole string, rather than split at dots.\n typeNameForGlobalFunctions  isTypeNameForGlobalFunctions  mkILGlobals <p>Build the table of commonly used references given functions to find types in system assemblies</p>\n\n EcmaMscorlibILGlobals  PrimaryAssemblyILGlobals  destTypeDefsWithGlobalFunctionsFirst <p>When writing a binary the fake \"toplevel\" type definition (called <Module>)\nmust come first. This function puts it first, and creates it in the returned\nlist as an empty typedef if it doesn't already exist.</p>\n\n decodeILAttribData <p>Not all custom attribute data can be decoded without binding types.  In particular\nenums must be bound in order to discover the size of the underlying integer.\nThe following assumes enums have size int32.</p>\n\n mkSimpleAssemblyRef <p>Generate simple references to assemblies and modules.</p>\n\n mkSimpleModRef  mkILTyvarTy  mkILNestedTyRef <p>Make type refs.</p>\n\n mkILTyRef  mkILTyRefInTyRef  mkILNonGenericTySpec <p>Make type specs.</p>\n\n mkILTySpec  mkILTy <p>Make types.</p>\n\n mkILNamedTy  mkILBoxedTy  mkILValueTy  mkILNonGenericBoxedTy  mkILNonGenericValueTy  mkILArrTy  mkILArr1DTy  isILArrTy  destILArrTy  mkILBoxedType  mkILMethRef <p>Make method references and specs.</p>\n\n mkILMethSpec  mkILMethSpecForMethRefInTy  mkILMethSpecInTy  mkILNonGenericMethSpecInTy <p>Construct references to methods on a given type .</p>\n\n mkILInstanceMethSpecInTy <p>Construct references to instance methods.</p>\n\n mkILNonGenericInstanceMethSpecInTy <p>Construct references to instance methods.</p>\n\n mkILStaticMethSpecInTy <p>Construct references to static methods.</p>\n\n mkILNonGenericStaticMethSpecInTy <p>Construct references to static, non-generic methods.</p>\n\n mkILCtorMethSpecForTy <p>Construct references to constructors.</p>\n\n mkILFieldRef <p>Construct references to fields.</p>\n\n mkILFieldSpec  mkILFieldSpecInTy  mkILCallSig  mkILFormalBoxedTy <p>Make generalized versions of possibly-generic types, e.g. Given the ILTypeDef for List, return the type \"List<T>\".</p>\n\n mkILFormalNamedTy  mkILFormalTypars  mkILFormalGenericArgs  mkILSimpleTypar  mkILCustomAttribMethRef <p>Make custom attributes.</p>\n\n mkILCustomAttribute  getCustomAttrData  mkPermissionSet  generateCodeLabel <p>Making code.</p>\n\n formatCodeLabel  nonBranchingInstrsToCode <p>Make some code that is a straight line sequence of instructions.\nThe function will add a \"return\" if the last instruction is not an exiting instruction.</p>\n\n mkNormalCall <p>Derived functions for making some common patterns of instructions.</p>\n\n mkNormalCallvirt  mkNormalCallconstraint  mkNormalNewobj  mkCallBaseConstructor  mkNormalStfld  mkNormalStsfld  mkNormalLdsfld  mkNormalLdfld  mkNormalLdflda  mkNormalLdobj  mkNormalStobj  mkLdcInt32  mkLdarg0  mkLdloc  mkStloc  mkLdarg  andTailness  mkILParam <p>Derived functions for making return, parameter and local variable\nobjects for use in method definitions.</p>\n\n mkILParamAnon  mkILParamNamed  mkILReturn  mkILLocal  mkILEmptyGenericParams <p>Make a formal generic parameters.</p>\n\n mkILMethodBody <p>Make method definitions.</p>\n\n mkMethodBody  methBodyNotAvailable  methBodyAbstract  methBodyNative  mkILCtor  mkILClassCtor  mkILNonGenericEmptyCtor  mkILStaticMethod  mkILNonGenericStaticMethod  mkILGenericVirtualMethod  mkILGenericNonVirtualMethod  mkILNonGenericVirtualMethod  mkILNonGenericInstanceMethod  mkILInstanceField <p>Make field definitions.</p>\n\n mkILStaticField  mkILLiteralField  mkILGenericClass <p>Make a type definition.</p>\n\n mkILSimpleClass  mkILTypeDefForGlobalFunctions  mkRawDataValueTypeDef <p>Make a type definition for a value type used to point to raw data.\nThese are useful when generating array initialization code\naccording to the\nldtoken    field valuetype '<PrivateImplementationDetails>'/'<span class=\"math\">\\[struct0x6000127-1' '&lt;PrivateImplementationDetails&gt;'::'\\]</span>method0x6000127-1'\ncall       void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class System.Array,valuetype System.RuntimeFieldHandle)\nidiom.</p>\n\n prependInstrsToCode <p>Injecting code into existing code blocks.  A branch will\nbe added from the given instructions to the (unique) entry of\nthe code, and the first instruction will be the new entry\nof the method.  The instructions should be non-branching.</p>\n\n prependInstrsToMethod  prependInstrsToClassCtor <p>Injecting initialization code into a class.\nAdd some code to the end of the .cctor for a type.  Create a .cctor\nif one doesn't exist already.</p>\n\n mkILStorageCtor <p>Derived functions for making some simple constructors</p>\n\n mkILSimpleStorageCtor  mkILSimpleStorageCtorWithParamNames  mkILDelegateMethods  mkCtorMethSpecForDelegate <p>Given a delegate type definition which lies in a particular scope,\nmake a reference to its constructor.</p>\n\n mkILTypeForGlobalFunctions <p>The toplevel \"class\" for a module or assembly.</p>\n\n mkILCustomAttrs <p>Making tables of custom attributes, etc.</p>\n\n mkILCustomAttrsFromArray  storeILCustomAttrs  mkILCustomAttrsReader  emptyILCustomAttrs  mkILSecurityDecls  emptyILSecurityDecls  storeILSecurityDecls  mkILSecurityDeclsReader  mkMethBodyAux  mkMethBodyLazyAux  mkILEvents  mkILEventsLazy  emptyILEvents  mkILProperties  mkILPropertiesLazy  emptyILProperties  mkILMethods  mkILMethodsFromArray  mkILMethodsComputed  emptyILMethods  mkILFields  mkILFieldsLazy  emptyILFields  mkILMethodImpls  mkILMethodImplsLazy  emptyILMethodImpls  mkILTypeDefs  mkILTypeDefsFromArray  emptyILTypeDefs  mkILTypeDefsComputed <p>Create table of types which is loaded/computed on-demand, and whose individual\nelements are also loaded/computed on-demand. Any call to tdefs.AsList will\nresult in the laziness being forced.  Operations can examine the\ncustom attributes and name of each type in order to decide whether\nto proceed with examining the other details of the type.</p>\n<p>Note that individual type definitions may contain further delays\nin their method, field and other tables.</p>\n\n addILTypeDef  mkTypeForwarder  mkILNestedExportedTypes  mkILNestedExportedTypesLazy  mkILExportedTypes  mkILExportedTypesLazy  mkILResources  mkILSimpleModule <p>Making modules.</p>\n\n mkRefForNestedILTypeDef <p>Generate references to existing type definitions, method definitions\netc.  Useful for generating references, e.g. to a  class we're processing\nAlso used to reference type definitions that we've generated.  <a href=\"fsharp-compiler-abstractil-il-ilscoperef.html\" title=\"ILScopeRef\">ILScopeRef</a>\nis normally ILScopeRef.Local, unless we've generated the ILTypeDef in\nan auxiliary module or are generating multiple assemblies at\nonce.</p>\n\n mkRefForILMethod  mkRefForILField  mkRefToILMethod  mkRefToILField  mkRefToILAssembly  mkRefToILModule  NoMetadataIdx  rescopeILScopeRef <p>Rescoping. The first argument tells the function how to reference the original scope from\nthe new scope.</p>\n\n rescopeILTypeSpec <p>Rescoping. The first argument tells the function how to reference the original scope from\nthe new scope.</p>\n\n rescopeILType <p>Rescoping. The first argument tells the function how to reference the original scope from\nthe new scope.</p>\n\n rescopeILMethodRef <p>Rescoping. The first argument tells the function how to reference the original scope from\nthe new scope.</p>\n\n rescopeILFieldRef <p>Rescoping. The first argument tells the function how to reference the original scope from\nthe new scope.</p>\n\n unscopeILType <p>Unscoping. Clears every scope information, use for looking up IL method references only.</p>\n\n buildILCode  instILTypeAux <p>Instantiate type variables that occur within types and other items.</p>\n\n instILType <p>Instantiate type variables that occur within types and other items.</p>\n\n ecmaPublicKey <p>This is a 'vendor neutral' way of referencing mscorlib.</p>\n\n isILObjectTy <p>Discriminating different important built-in types.</p>\n\n isILStringTy  isILSByteTy  isILByteTy  isILInt16Ty  isILUInt16Ty  isILInt32Ty  isILUInt32Ty  isILInt64Ty  isILUInt64Ty  isILIntPtrTy  isILUIntPtrTy  isILBoolTy  isILCharTy  isILTypedReferenceTy  isILDoubleTy  isILSingleTy  sha1HashInt64  sha1HashBytes <p>Get a public key token from a public key.</p>\n\n parseILVersion <p>Get a version number from a CLR version string, e.g. 1.0.3705.0</p>\n\n formatILVersion  compareILVersions  getTyOfILEnumInfo  computeILEnumInfo  computeILRefs <p>Find the full set of assemblies referenced by a module.</p>\n\n emptyILRefs  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader.html","title":"ILBinaryReader","content":"ILBinaryReader \n <p>Binary reader.  Read a .NET binary and concert it to Abstract IL data\nstructures.</p>\n<p>NOTE:\n- The metadata in the loaded modules will be relative to\nthose modules, e.g. ILScopeRef.Local will mean \"local to\nthat module\".  You must use [rescopeILType] etc. if you want to include\n(i.e. copy) the metadata into your own module.</p>\n<ul>\n<li>\n<p>PDB (debug info) reading/folding:\nThe PDB reader is invoked if you give a PDB path\nThis indicates if you want to search for PDB files and have the\nreader fold them in.  You cannot currently name the pdb file\ndirectly - you can only name the path.  Giving \"None\" says\n\"do not read the PDB file even if one exists\".</p>\n<p>The debug info appears primarily as I_seqpoint annotations in\nthe instruction streams.  Unfortunately the PDB information does\nnot, for example, tell you how to map back from a class definition\nto a source code line number - you will need to explicitly search\nfor a sequence point in the code for one of the methods of the\nclass.  That is not particularly satisfactory, and it may be\na good idea to build a small library which extracts the information\nyou need.</p>\n</li>\n</ul>\n\n \n Shim  \n ILModuleReader <p>Represents a reader of the metadata of a .NET binary.  May also give some values (e.g. IL code) from the PE file\nif it was provided.</p>\n\n ILReaderMetadataSnapshot <p>Used to implement a Binary file over native memory, used by Roslyn integration</p>\n\n ILReaderOptions  ILReaderTryGetMetadataSnapshot  MetadataOnlyFlag  ReduceMemoryFlag  Statistics  \n GetStatistics  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-shim.html","title":"Shim","content":"Shim \n  \n  \n DefaultAssemblyReader  IAssemblyReader  \n AssemblyReader  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library.html","title":"Library","content":"Library \n  \n Array  Cancellable  Dictionary  Eventually  IPartialEqualityComparer  Lazy  List  Map  MultiMap  NameMap  NameMultiMap  Option  Order  ResizeArray  ResultOrException  Shim  String  Tables <p>Intern tables to save space.</p>\n\n ValueOptionInternal <p>chunk the provided input into arrays that are smaller than the LOH limit\nin order to prevent long-term storage of those values</p>\n\n \n AnyCallerThreadToken <p>Represents a token that indicates execution on a any of several potential user threads calling the F# compiler services.</p>\n\n Cancellable<'TResult> <p>Represents a cancellable computation with explicit representation of a cancelled result.</p>\n<p>A cancellable computation is passed may be cancelled via a CancellationToken, which is propagated implicitly.<br />\nIf cancellation occurs, it is propagated as data rather than by raising an OperationCanceledException.</p>\n\n CancellableBuilder  CompilationThreadToken <p>Represents a token that indicates execution on the compilation thread, i.e.\n- we have full access to the (partially mutable) TAST and TcImports data structures\n- compiler execution may result in type provider invocations when resolving types and members\n- we can access various caches in the SourceCodeServices</p>\n<p>Like other execution tokens this should be passed via argument passing and not captured/stored beyond\nthe lifetime of stack-based calls. This is not checked, it is a discipline within the compiler code.</p>\n\n DictionaryExtensions  Eventually<'T> <p>Computations that can cooperatively yield by returning a continuation</p>\n<ul>\n<li>\n<p>Any yield of a NotYetDone should typically be \"abandonable\" without adverse consequences. No resource release\nwill be called when the computation is abandoned.</p>\n</li>\n<li>\n<p>Computations suspend via a NotYetDone may use local state (mutables), where these are\ncaptured by the NotYetDone closure. Computations do not need to be restartable.</p>\n</li>\n<li>\n<p>The key thing is that you can take an Eventually value and run it with\nEventually.repeatedlyProgressUntilDoneOrTimeShareOverOrCanceled</p>\n</li>\n<li>Cancellation results in a suspended computation rather than complete abandonment</li>\n</ul>\n\n EventuallyBuilder  ExecutionToken <p>Represents a permission active at this point in execution</p>\n\n IPartialEqualityComparer<'T> <p>Interface that defines methods for comparing objects using partial equality relation</p>\n\n InlineDelayInit<'T> <p>An efficient lazy for inline storage in a class type. Results in fewer thunks.</p>\n\n LayeredMap<'Key, 'Value>  LayeredMultiMap<'Key, 'Value> <p>Immutable map collection, with explicit flattening to a backing dictionary</p>\n\n LazyWithContext<'T, 'ctxt> <p>Just like \"Lazy\" but EVERY forcer must provide an instance of \"ctxt\", e.g. to help track errors\non forcing back to at least one sensible user location</p>\n\n LazyWithContextFailure  Lock<'LockTokenType> <p>Encapsulates a lock associated with a particular token-type representing the acquisition of that lock.</p>\n\n LockToken <p>A base type for various types of tokens that must be passed when a lock is taken.\nEach different static lock should declare a new subtype of this type.</p>\n\n MemoizationTable<'T, 'U> <p>memoize tables (all entries cached, never collected)</p>\n\n MultiMap<'T, 'U>  NameMap<'T>  NameMultiMap<'T>  ResultOrException<'TResult>  UndefinedException  UniqueStampGenerator<'T> <p>Generates unique stamps</p>\n\n ValueOrCancelled<'TResult>  \n ( >>>& )  notlazy  isNil  isNilOrSingleton <p>Returns true if the list has less than 2 elements. Otherwise false.</p>\n\n isSingleton <p>Returns true if the list contains exactly 1 element. Otherwise false.</p>\n\n isNonNull  nonNull  ( === )  LOH_SIZE_THRESHOLD_BYTES <p>Per the docs the threshold for the Large Object Heap is 85000 bytes: <a href=\"https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap#how-an-object-ends-up-on-the-large-object-heap-and-how-gc-handles-them\nWe\">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap#how-an-object-ends-up-on-the-large-object-heap-and-how-gc-handles-them\nWe</a> set the limit to be 80k to account for larger pointer sizes for when F# is running 64-bit.</p>\n\n reportTime  foldOn  notFound  RequireCompilationThread <p>Represents a place where we are stating that execution on the compilation thread is required. The\nreason why will be documented in a comment in the code at the callsite.</p>\n\n DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent <p>Represents a place in the compiler codebase where we are passed a CompilationThreadToken unnecessarily.\nThis represents code that may potentially not need to be executed on the compilation thread.</p>\n\n AssumeCompilationThreadWithoutEvidence <p>Represents a place in the compiler codebase where we assume we are executing on a compilation thread</p>\n\n AssumeAnyCallerThreadWithoutEvidence  AssumeLockWithoutEvidence  getHole <p>Get an initialization hole</p>\n\n cancellable  eventually  \n StartsWithOrdinal  EndsWithOrdinal  Empty  Empty  Values  Values  AddAndMarkAsCollapsible  LinearTryModifyThenLaterFlatten  MarkAsCollapsible "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-array.html","title":"Array","content":"Array \n  \n  \n  \n mapq  lengthsEqAndForall2  order  existsOne  existsTrue  findFirstIndexWhereTrue  revInPlace <p>pass an array byref to reverse it in place</p>\n\n mapAsync <p>Async implementation of Array.map.</p>\n\n replace <p>Returns a new array with an element replaced with a given value.</p>\n\n areEqual <p>Optimized arrays equality. ~100x faster than <code>array1 = array2</code> on strings.\n~2x faster for floats\n~0.8x slower for ints</p>\n\n heads <p>Returns all heads of a given array.\nFor [|1;2;3|] it returns [|[|1; 2; 3|]; [|1; 2|]; [|1|]|]</p>\n\n isSubArray <p>check if subArray is found in the wholeArray starting\nat the provided index</p>\n\n startsWith <p>Returns true if one array has another as its subset from index 0.</p>\n\n endsWith <p>Returns true if one array has trailing elements equal to another's.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-cancellablemodule.html","title":"Cancellable","content":"Cancellable \n  \n  \n  \n run <p>Run a cancellable computation using the given cancellation token</p>\n\n bind <p>Bind the result of a cancellable computation</p>\n\n map <p>Map the result of a cancellable computation</p>\n\n ret <p>Return a simple value as the result of a cancellable computation</p>\n\n fold <p>Fold a cancellable computation along a sequence of inputs</p>\n\n each <p>Iterate a cancellable computation over a collection</p>\n\n delay <p>Delay a cancellable computation</p>\n\n runWithoutCancellation <p>Run the computation in a mode where it may not be cancelled. The computation never results in a\nValueOrCancelled.Cancelled.</p>\n\n token <p>Bind the cancellation token associated with the computation</p>\n\n canceled <p>Represents a canceled computation</p>\n\n tryFinally <p>Implement try/finally for a cancellable computation</p>\n\n tryWith <p>Implement try/with for a cancellable computation</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-dictionary.html","title":"Dictionary","content":"Dictionary \n  \n  \n  \n newWithSize  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-eventuallymodule.html","title":"Eventually","content":"Eventually \n  \n  \n  \n box  forceWhile  force  repeatedlyProgressUntilDoneOrTimeShareOverOrCanceled <p>Keep running the computation bit by bit until a time limit is reached.\nThe runner gets called each time the computation is restarted</p>\n<p>If cancellation happens, the operation is left half-complete, ready to resume.</p>\n\n forceAsync <p>Keep running the asynchronous computation bit by bit. The runner gets called each time the computation is restarted.\nCan be cancelled as an Async in the normal way.</p>\n\n bind  fold  catch  delay  tryFinally  tryWith  token  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-ipartialequalitycomparer.html","title":"IPartialEqualityComparer","content":"IPartialEqualityComparer \n  \n  \n  \n On  partialDistinctBy  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-lazy.html","title":"Lazy","content":"Lazy \n  \n  \n  \n force  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-list.html","title":"List","content":"List \n  \n  \n  \n sortWithOrder  splitAfter  existsi  lengthsEqAndForall2  findi  splitChoose  checkq  mapq  frontAndBack  tryRemove  zip4  unzip4  iter3  takeUntil  order  indexNotFound  assoc  memAssoc  memq  mapNth  count  headAndTail  mapHeadTail  collectFold  collect2  toArraySquared  iterSquared  collectSquared  mapSquared  mapFoldSquared  forallSquared  mapiSquared  existsSquared  mapiFoldSquared  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-map.html","title":"Map","content":"Map \n  \n  \n  \n tryFindMulti  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-multimapmodule.html","title":"MultiMap","content":"MultiMap \n  \n  \n  \n existsInRange  find  add  range  empty  initBy  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-namemapmodule.html","title":"NameMap","content":"NameMap \n  \n  \n  \n empty  range  foldBack  forall  exists  ofKeyedList  ofList  ofSeq  toList  layer  layerAdditive <p>Not a very useful function - only called in one place - should be changed</p>\n\n union <p>Union entries by identical key, using the provided function to union sets of values</p>\n\n subfold2 <p>For every entry in m2 find an entry in m1 and fold</p>\n\n suball2  mapFold  foldBackRange  filterRange  mapFilter  map  iter  partition  mem  find  tryFind  add  isEmpty  existsInRange  tryFindInRange  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-namemultimapmodule.html","title":"NameMultiMap","content":"NameMultiMap \n  \n  \n  \n existsInRange  find  add  range  rangeReversingEachBucket  chooseRange  map  empty  initBy  ofList  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-option.html","title":"Option","content":"Option \n  \n  \n  \n mapFold  attempt  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-order.html","title":"Order","content":"Order \n  \n  \n  \n orderBy  orderOn  toFunction  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-resizearray.html","title":"ResizeArray","content":"ResizeArray \n  \n  \n  \n chunkBySize <p>Split a ResizeArray into an array of smaller chunks.\nThis requires <code>items/chunkSize</code> Array copies of length <code>chunkSize</code> if <code>items/chunkSize % 0 = 0</code>,\notherwise <code>items/chunkSize + 1</code> Array copies.</p>\n\n mapToSmallArrayChunks <p>Split a large ResizeArray into a series of array chunks that are each under the Large Object Heap limit.\nThis is done to help prevent a stop-the-world collection of the single large array, instead allowing for a greater\nprobability of smaller collections. Stop-the-world is still possible, just less likely.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-resultorexceptionmodule.html","title":"ResultOrException","content":"ResultOrException \n  \n  \n  \n success  raze  ( |?> )  ForceRaise  otherwise  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-shim.html","title":"Shim","content":"Shim \n  \n  \n DefaultFileSystem  IFileSystem  \n FileSystem  \n ReadBinaryChunk  OpenReaderAndRetry "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-string.html","title":"String","content":"String \n  \n  \n  \n make  get  sub  contains  order  lowercase  uppercase  isLeadingIdentifierCharacterUpperCase  capitalize  uncapitalize  dropPrefix  dropSuffix  toCharArray  lowerCaseFirstChar  extractTrailingIndex  trim <p>Remove all trailing and leading whitespace from the string\nreturn null if the string is null</p>\n\n split <p>Splits a string into substrings based on the strings in the array separators</p>\n\n getLines  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-tables.html","title":"Tables","content":"Tables \n <p>Intern tables to save space.</p>\n\n \n  \n  \n memoize  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-valueoptioninternal.html","title":"ValueOptionInternal","content":"ValueOptionInternal \n <p>chunk the provided input into arrays that are smaller than the LOH limit\nin order to prevent long-term storage of those values</p>\n\n \n  \n  \n ofOption  bind  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-utils.html","title":"Utils","content":"Utils \n  \n  \n  \n runningOnMono  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell.html","title":"Shell","content":"Shell \n  \n Settings <p>A default implementation of the 'fsi' object, used by GetDefaultConfiguration()</p>\n\n \n CompilerInputStream <p>Defines a read-only input stream used to feed content to the hosted F# Interactive dynamic compiler.</p>\n\n CompilerOutputStream <p>Defines a write-only stream used to capture output of the hosted F# Interactive dynamic compiler.</p>\n\n EvaluationEventArgs  FsiBoundValue <p>Represents an evaluated F# value that is bound to an identifier</p>\n\n FsiCompilationException <p>Thrown when there was an error compiling the given code in FSI.</p>\n\n FsiEvaluationSession <p>Represents an F# Interactive evaluation session.</p>\n\n FsiEvaluationSessionHostConfig  FsiValue <p>Represents an evaluated F# value</p>\n\n \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-settings.html","title":"Settings","content":"Settings \n <p>A default implementation of the 'fsi' object, used by GetDefaultConfiguration()</p>\n\n \n  \n IEventLoop <p>An event loop used by the currently executing F# Interactive session to execute code\nin the context of a GUI or another event-based system.</p>\n\n InteractiveSettings <p>Operations supported by the currently executing F# Interactive session.</p>\n\n \n fsi <p>A default implementation of the 'fsi' object, used by GetDefaultConfiguration().  Note this\nis a different object to FSharp.Compiler.Interactive.Settings.fsi in FSharp.Compiler.Interactive.Settings.dll,\nwhich can be used as an alternative implementation of the interactive settings if passed as a parameter\nto GetDefaultConfiguration(fsiObj).</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-assemblycontentprovider.html","title":"AssemblyContentProvider","content":"AssemblyContentProvider \n <p>Provides assembly content.</p>\n\n \n  \n  \n getAssemblySignatureContent <p>Given a <a href=\"fsharp-compiler-sourcecodeservices-fsharpassemblysignature.html\" title=\"FSharpAssemblySignature\"><code>FSharpAssemblySignature</code></a>, returns assembly content.</p>\n\n getAssemblyContent <p>Returns (possibly cached) assembly content.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-asttraversal.html","title":"AstTraversal","content":"AstTraversal \n <p>A range of utility functions to assist with traversing an AST</p>\n\n \n  \n AstVisitorBase<'T>  TraversePath  TraverseStep <p>used to track route during traversal AST</p>\n\n \n rangeContainsPosLeftEdgeInclusive  rangeContainsPosEdgesExclusive  rangeContainsPosLeftEdgeExclusiveAndRightEdgeInclusive  dive  pick  Traverse <p>traverse an implementation file walking all the way down to SynExpr or TypeAbbrev at a particular location</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-basicpatterns.html","title":"BasicPatterns","content":"BasicPatterns \n <p>A collection of active patterns to analyze expressions</p>\n\n \n  \n  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-compilerenvironmentmodule.html","title":"CompilerEnvironment","content":"CompilerEnvironment \n <p>Information about the compilation environment</p>\n\n \n  \n  \n DefaultReferencesForOrphanSources <p>These are the names of assemblies that should be referenced for .fs or .fsi files that\nare not associated with a project.</p>\n\n GetCompilationDefinesForEditing <p>Return the compilation defines that should be used when editing the given file.</p>\n\n IsCheckerSupportedSubcategory <p>Return true if this is a subcategory of error or warning message that the language service can emit</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-debuggerenvironment.html","title":"DebuggerEnvironment","content":"DebuggerEnvironment \n <p>Information about the debugging environment</p>\n\n \n  \n  \n GetLanguageID <p>Return the language ID, which is the expression evaluator id that the\ndebugger will use.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-extensions.html","title":"Extensions","content":"Extensions \n  \n  \n  \n  \n TryGetFullName <p>Safe version of <code>FullName</code>.</p>\n\n TryGetFullDisplayName <p>Safe version of <code>DisplayName</code>.</p>\n\n TryGetFullCompiledName <p>Safe version of <code>CompiledName</code>.</p>\n\n PublicNestedEntities <p>Public nested entities (methods, functions, values, nested modules).</p>\n\n PublicNestedEntities <p>Public nested entities (methods, functions, values, nested modules).</p>\n\n TryGetMembersFunctionsAndValues <p>Safe version of <code>GetMembersFunctionsAndValues</code>.</p>\n\n TryGetMembersFunctionsAndValues <p>Safe version of <code>GetMembersFunctionsAndValues</code>.</p>\n\n FullTypeSafe <p>Safe version of <code>FullType</code>.</p>\n\n FullTypeSafe <p>Safe version of <code>FullType</code>.</p>\n\n TryGetFullDisplayName <p>Full name with last part replaced with display name.</p>\n\n TryGetFullCompiledOperatorNameIdents <p>Full operator compiled name.</p>\n\n TryGetEntities <p>Safe version of <code>Entities</code>.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-externaltypemodule.html","title":"ExternalType","content":"ExternalType \n  \n  \n  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpfileutilities.html","title":"FSharpFileUtilities","content":"FSharpFileUtilities \n <p>A set of helpers for dealing with F# files.</p>\n\n \n  \n  \n isScriptFile  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnavigation.html","title":"FSharpNavigation","content":"FSharpNavigation \n  \n  \n  \n getNavigation  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokentag.html","title":"FSharpTokenTag","content":"FSharpTokenTag \n <p>Some of the values in the field FSharpTokenInfo.Tag</p>\n\n \n  \n  \n Identifier <p>Indicates the token is an identifier</p>\n\n String <p>Indicates the token is a string</p>\n\n IDENT <p>Indicates the token is an identifier (synonym for FSharpTokenTag.Identifier)</p>\n\n STRING <p>Indicates the token is an string (synonym for FSharpTokenTag.String)</p>\n\n LPAREN <p>Indicates the token is a <code>(</code></p>\n\n RPAREN <p>Indicates the token is a <code>)</code></p>\n\n LBRACK <p>Indicates the token is a <code>[</code></p>\n\n RBRACK <p>Indicates the token is a <code>]</code></p>\n\n LBRACE <p>Indicates the token is a <code>{</code></p>\n\n RBRACE <p>Indicates the token is a <code>}</code></p>\n\n LBRACK_LESS <p>Indicates the token is a <code>[&lt;</code></p>\n\n GREATER_RBRACK <p>Indicates the token is a <code>&gt;]</code></p>\n\n LESS <p>Indicates the token is a <code>&lt;</code></p>\n\n GREATER <p>Indicates the token is a <code>&gt;</code></p>\n\n LBRACK_BAR <p>Indicates the token is a <code>[|</code></p>\n\n BAR_RBRACK <p>Indicates the token is a <code>|]</code></p>\n\n PLUS_MINUS_OP <p>Indicates the token is a <code>+</code> or <code>-</code></p>\n\n MINUS <p>Indicates the token is a <code>-</code></p>\n\n STAR <p>Indicates the token is a <code>*</code></p>\n\n INFIX_STAR_DIV_MOD_OP <p>Indicates the token is a <code>%</code></p>\n\n PERCENT_OP <p>Indicates the token is a <code>%</code></p>\n\n INFIX_AT_HAT_OP <p>Indicates the token is a <code>^</code></p>\n\n QMARK <p>Indicates the token is a <code>?</code></p>\n\n COLON <p>Indicates the token is a <code>:</code></p>\n\n EQUALS <p>Indicates the token is a <code>=</code></p>\n\n SEMICOLON <p>Indicates the token is a <code>;</code></p>\n\n COMMA <p>Indicates the token is a <code>,</code></p>\n\n DOT <p>Indicates the token is a <code>.</code></p>\n\n DOT_DOT <p>Indicates the token is a <code>..</code></p>\n\n DOT_DOT_HAT <p>Indicates the token is a <code>..</code></p>\n\n INT32_DOT_DOT <p>Indicates the token is a <code>..^</code></p>\n\n UNDERSCORE <p>Indicates the token is a <code>..</code></p>\n\n BAR <p>Indicates the token is a <code>_</code></p>\n\n COLON_GREATER <p>Indicates the token is a <code>:&gt;</code></p>\n\n COLON_QMARK_GREATER <p>Indicates the token is a <code>:?&gt;</code></p>\n\n COLON_QMARK <p>Indicates the token is a <code>:?</code></p>\n\n INFIX_BAR_OP <p>Indicates the token is a <code>|</code></p>\n\n INFIX_COMPARE_OP <p>Indicates the token is a <code>|</code></p>\n\n COLON_COLON <p>Indicates the token is a <code>::</code></p>\n\n AMP_AMP <p>Indicates the token is a <code>@@</code></p>\n\n PREFIX_OP <p>Indicates the token is a <code>~</code></p>\n\n COLON_EQUALS <p>Indicates the token is a <code>:=</code></p>\n\n BAR_BAR <p>Indicates the token is a <code>||</code></p>\n\n RARROW <p>Indicates the token is a <code>-&gt;</code></p>\n\n LARROW <p>Indicates the token is a <code>&lt;-</code></p>\n\n QUOTE <p>Indicates the token is a <code>\"</code></p>\n\n WHITESPACE <p>Indicates the token is a whitespace</p>\n\n COMMENT <p>Indicates the token is a comment</p>\n\n LINE_COMMENT <p>Indicates the token is a line comment</p>\n\n BEGIN <p>Indicates the token is keyword <code>begin</code></p>\n\n DO <p>Indicates the token is keyword <code>do</code></p>\n\n FUNCTION <p>Indicates the token is keyword <code>function</code></p>\n\n THEN <p>Indicates the token is keyword <code>then</code></p>\n\n ELSE <p>Indicates the token is keyword <code>else</code></p>\n\n STRUCT <p>Indicates the token is keyword <code>struct</code></p>\n\n CLASS <p>Indicates the token is keyword <code>class</code></p>\n\n TRY <p>Indicates the token is keyword <code>try</code></p>\n\n WITH <p>Indicates the token is keyword <code>with</code></p>\n\n OWITH <p>Indicates the token is keyword <code>with</code> in #light</p>\n\n NEW <p>Indicates the token is keyword <code>new</code></p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-interfacestubgenerator.html","title":"InterfaceStubGenerator","content":"InterfaceStubGenerator \n  \n  \n  \n getInterfaceMembers <p>Get members in the decreasing order of inheritance chain</p>\n\n hasNoInterfaceMember <p>Check whether an interface is empty</p>\n\n getMemberNameAndRanges <p>Get associated member names and ranges\nIn case of properties, intrinsic ranges might not be correct for the purpose of getting\npositions of 'member', which indicate the indentation for generating new members</p>\n\n getImplementedMemberSignatures  isInterface <p>Check whether an entity is an interface or type abbreviation of an interface</p>\n\n formatInterface <p>Generate stub implementation of an interface at a start column</p>\n\n tryFindInterfaceDeclaration <p>Find corresponding interface declaration at a given position</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-keywords.html","title":"Keywords","content":"Keywords \n  \n  \n  \n DoesIdentifierNeedQuotation <p>Checks if adding backticks to identifier is needed.</p>\n\n QuoteIdentifierIfNeeded <p>Add backticks if the identifier is a keyword.</p>\n\n NormalizeIdentifierBackticks <p>Remove backticks if present.</p>\n\n KeywordsWithDescription <p>Keywords paired with their descriptions. Used in completion and quick info.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lexer.html","title":"Lexer","content":"Lexer \n  \n  \n FSharpLexer  FSharpLexerFlags  FSharpSyntaxToken  FSharpSyntaxTokenKind  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-navigateto.html","title":"NavigateTo","content":"NavigateTo \n  \n  \n Container  ContainerType  NavigableItem  NavigableItemKind  \n getNavigableItems  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-paramtypesymbolmodule.html","title":"ParamTypeSymbol","content":"ParamTypeSymbol \n  \n  \n  \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-parsedinput.html","title":"ParsedInput","content":"ParsedInput \n <p>Parse AST helpers.</p>\n\n \n  \n  \n tryFindInsertionContext <p>Returns <a href=\"fsharp-compiler-sourcecodeservices-insertcontext.html\" title=\"InsertContext\"><code>InsertContext</code></a> based on current position and symbol idents.</p>\n\n findNearestPointToInsertOpenDeclaration <p>Returns <a href=\"fsharp-compiler-sourcecodeservices-insertcontext.html\" title=\"InsertContext\"><code>InsertContext</code></a> based on current position and symbol idents.</p>\n\n getLongIdentAt <p>Returns long identifier at position.</p>\n\n adjustInsertionPoint <p>Corrects insertion line number based on kind of scope and text surrounding the insertion point.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-prettynaming.html","title":"PrettyNaming","content":"PrettyNaming \n <p>A set of helpers related to naming of identifiers</p>\n\n \n  \n  \n IsIdentifierPartCharacter  IsLongIdentifierPartCharacter  IsOperatorName  GetLongNameFromString  FormatAndOtherOverloadsString  QuoteIdentifierIfNeeded <p>A utility to help determine if an identifier needs to be quoted</p>\n\n KeywordNames <p>All the keywords in the F# language</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-simplifynames.html","title":"SimplifyNames","content":"SimplifyNames \n  \n  \n SimplifiableRange <p>Data for use in finding unnecessarily-qualified names and generating diagnostics to simplify them</p>\n\n \n getSimplifiableNames <p>Get all ranges that can be simplified in a file</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-sourcefile.html","title":"SourceFile","content":"SourceFile \n <p>Information about F# source file names</p>\n\n \n  \n  \n IsCompilable <p>Whether or not this file is compilable</p>\n\n MustBeSingleFileProject <p>Whether or not this file should be a single-file project</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-structure.html","title":"Structure","content":"Structure \n  \n  \n Collapse <p>Collapse indicates the way a range/snapshot should be collapsed. <code>Same</code> is for a scope inside\nsome kind of scope delimiter, e.g. <code>[| ... |]</code>, <code>[ ... ]</code>, <code>{ ... }</code>, etc.  <code>Below</code> is for expressions\nfollowing a binding or the right hand side of a pattern, e.g. <code>let x = ...</code></p>\n\n Scope <p>Tag to identify the construct that can be stored alongside its associated ranges</p>\n\n ScopeRange <p>Stores the range for a construct, the sub-range that should be collapsed for outlinging,\na tag for the construct type, and a tag for the collapse style</p>\n\n \n getOutliningRanges <p>Returns outlining ranges for given parsed input.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-symbol.html","title":"Symbol","content":"Symbol \n <p>Patterns over FSharpSymbol and derivatives.</p>\n\n \n  \n  \n isAttribute  tryGetAttribute  hasModuleSuffixAttribute  isOperator  isUnnamedUnionCaseField  getEntityAbbreviatedType  getAbbreviatedType  hasAttribute  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-tooltips.html","title":"Tooltips","content":"Tooltips \n  \n  \n  \n ToFSharpToolTipElement  ToFSharpToolTipText  Map  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-untypedparseimpl.html","title":"UntypedParseImpl","content":"UntypedParseImpl \n  \n  \n  \n TryFindExpressionASTLeftOfDotLeftOfCursor  GetRangeOfExprLeftOfDot  TryFindExpressionIslandInPosition  TryGetCompletionContext  GetEntityKind  GetFullNameOfSmallestModuleOrNamespaceAtPoint  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-unuseddeclarations.html","title":"UnusedDeclarations","content":"UnusedDeclarations \n  \n  \n  \n getUnusedDeclarations <p>Get all unused declarations in a file</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-unusedopens.html","title":"UnusedOpens","content":"UnusedOpens \n  \n  \n  \n getUnusedOpens <p>Get all unused open declarations in a file</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-xmldoccomment.html","title":"XmlDocComment","content":"XmlDocComment \n  \n  \n  \n isBlank <p>if it's a blank XML comment with trailing \"&lt;\", returns Some (index of the \"&lt;\"), otherwise returns None</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-xmldocparser.html","title":"XmlDocParser","content":"XmlDocParser \n  \n  \n  \n getXmlDocables <p>Get the list of Xml documentation from current source code</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-text-sourcetext.html","title":"SourceText","content":"SourceText \n  \n  \n  \n ofString  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-display.html","title":"Display","content":"Display \n  \n  \n  \n any_to_string <p>Convert any value to a string using a standard formatter\nData is typically formatted in a structured format, e.g.\nlists are formatted using the \"[1;2]\" notation.\nThe details of the format are not specified and may change\nfrom version to version and according to the flags given\nto the F# compiler.  The format is intended to be human-readable,\nnot machine readable.  If alternative generic formats are required\nyou should develop your own formatter, using the code in the\nimplementation of this file as a starting point.</p>\n<p>Data from other .NET languages is formatted using a virtual\ncall to Object.ToString() on the boxed version of the input.</p>\n\n output_any <p>Output any value to a channel using the same set of formatting rules\nas any<em>to</em>string</p>\n\n asTaggedTextWriter  any_to_layout  squash_layout  output_layout_tagged  output_layout  layout_as_string  layout_to_string <p>Convert any value to a layout using the given formatting options.  The\nlayout can then be processed using formatting display engines such as\nthose in the LayoutOps module.  any<em>to</em>string and output<em>any are\nbuilt using any</em>to_layout with default format options.</p>\n\n fsi_any_to_layout  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-layoutops.html","title":"LayoutOps","content":"LayoutOps \n <p>A layout is a sequence of strings which have been joined together.\nThe strings are classified as words, separators and left and right parenthesis.\nThis classification determines where spaces are inserted.\nA joint is either unbreakable, breakable or broken.\nIf a joint is broken the RHS layout occurs on the next line with optional indentation.\nA layout can be squashed to for given width which forces breaks as required.</p>\n\n \n  \n  \n emptyL <p>The empty layout</p>\n\n isEmptyL <p>Is it the empty layout?</p>\n\n objL <p>An uninterpreted leaf, to be interpreted into a string\nby the layout engine. This allows leaf layouts for numbers, strings and\nother atoms to be customized according to culture.</p>\n\n wordL <p>An string leaf</p>\n\n sepL <p>An string which requires no spaces either side.</p>\n\n rightL <p>An string which is right parenthesis (no space on the left).</p>\n\n leftL <p>An string which is left  parenthesis (no space on the right).</p>\n\n ( ^^ ) <p>Join, unbreakable.</p>\n\n ( ++ ) <p>Join, possible break with indent=0</p>\n\n ( -- ) <p>Join, possible break with indent=1</p>\n\n ( --- ) <p>Join, possible break with indent=2</p>\n\n ( @@ ) <p>Join broken with ident=0</p>\n\n ( @@- ) <p>Join broken with ident=1</p>\n\n ( @@-- ) <p>Join broken with ident=2</p>\n\n commaListL <p>Join layouts into a comma separated list.</p>\n\n spaceListL <p>Join layouts into a space separated list.</p>\n\n semiListL <p>Join layouts into a semi-colon separated list.</p>\n\n sepListL <p>Join layouts into a list separated using the given Layout.</p>\n\n bracketL <p>Wrap round brackets around Layout.</p>\n\n squareBracketL <p>Wrap square brackets around layout.</p>\n\n braceL <p>Wrap braces around layout.</p>\n\n tupleL <p>Form tuple of layouts.</p>\n\n aboveL <p>Layout two vertically.</p>\n\n aboveListL <p>Layout list vertically.</p>\n\n optionL <p>Layout like an F# option.</p>\n\n listL <p>Layout like an F# list.</p>\n\n tagAttrL <p>See tagL</p>\n\n unfoldL <p>For limiting layout of list-like sequences (lists,arrays,etc).\nunfold a list of items using (project and z) making layout list via itemL.\nIf reach maxLength (before exhausting) then truncate.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-taggedtextops.html","title":"TaggedTextOps","content":"TaggedTextOps \n  \n Literals  \n  \n tag  keywordFunctions  tagAlias  tagClass  tagUnionCase  tagDelegate  tagEnum  tagEvent  tagField  tagInterface  tagKeyword  tagLineBreak  tagMethod  tagModuleBinding  tagLocal  tagRecord  tagRecordField  tagModule  tagNamespace  tagNumericLiteral  tagOperator  tagParameter  tagProperty  tagSpace  tagStringLiteral  tagStruct  tagTypeParameter  tagText  tagPunctuation  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-taggedtextops-literals.html","title":"Literals","content":"Literals \n  \n  \n  \n lineBreak  space  comma  semicolon  leftParen  rightParen  leftBracket  rightBracket  leftBrace  rightBrace  leftBraceBar  rightBraceBar  equals  arrow  questionMark  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-partiallongname.html","title":"PartialLongName","content":"PartialLongName \n <p>Qualified long name.</p>\n\n \n Empty <p>Empty partial long name.</p>\n\n QualifyingIdents <p>Qualifying idents, prior to the last dot, not including the last part.</p>\n\n PartialIdent <p>Last part of long ident.</p>\n\n EndColumn <p>The column number at the end of full partial name.</p>\n\n LastDotPos <p>Position of the last dot.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-assemblycontenttype.html","title":"AssemblyContentType","content":"AssemblyContentType \n <p>Assembly content type.</p>\n\n \n Public <p>Public assembly content only.</p>\n\n Full <p>All assembly content.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-assemblypath.html","title":"AssemblyPath","content":"AssemblyPath \n <p>Assembly path.</p>\n\n \n Chars  Length "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-assemblysymbol.html","title":"AssemblySymbol","content":"AssemblySymbol \n <p>Represents type, module, member, function or value in a compiled assembly.</p>\n\n \n FullName <p>Full entity name as it's seen in compiled code (raw FSharpEntity.FullName, FSharpValueOrFunction.FullName).</p>\n\n CleanedIdents <p>Entity name parts with removed module suffixes (Ns.M1Module.M2Module.M3.entity -&gt; Ns.M1.M2.M3.entity)\nand replaced compiled names with display names (FSharpEntity.DisplayName, FSharpValueOrFunction.DisplayName).\nNote: <em>all</em> parts are cleaned, not the last one.</p>\n\n Namespace <p><code>FSharpEntity.Namespace</code>.</p>\n\n NearestRequireQualifiedAccessParent <p>The most narrative parent module that has <code>RequireQualifiedAccess</code> attribute.</p>\n\n TopRequireQualifiedAccessParent <p>Parent module that has the largest scope and has <code>RequireQualifiedAccess</code> attribute.</p>\n\n AutoOpenParent <p>Parent module that has <code>AutoOpen</code> attribute.</p>\n\n Symbol  Kind <p>Function that returns <a href=\"fsharp-compiler-sourcecodeservices-entitykind.html\" title=\"EntityKind\"><code>EntityKind</code></a> based of given <a href=\"fsharp-compiler-nameresolution-lookupkind.html\" title=\"LookupKind\"><code>LookupKind</code></a>.</p>\n\n UnresolvedSymbol <p>Cache display name and namespace, used for completion.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-compilerenvironment.html","title":"CompilerEnvironment","content":"CompilerEnvironment \n <p>Information about the compilation environment</p>\n\n \n BinFolderOfDefaultFSharpCompiler <p>The default location of FSharp.Core.dll and fsc.exe based on the version of fsc.exe that is running</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-completioncontext.html","title":"CompletionContext","content":"CompletionContext \n  \n Invalid <p>completion context cannot be determined due to errors</p>\n\n Inherit <p>completing something after the inherit keyword</p>\n\n RecordField <p>completing records field</p>\n\n RangeOperator  ParameterList <p>completing named parameters\\setters in parameter list of constructor\\method calls\nend of name ast node * list of properties\\parameters that were already set</p>\n\n AttributeApplication  OpenDeclaration  PatternType <p>completing pattern type (e.g. foo (x: |))</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-completionitemkind.html","title":"CompletionItemKind","content":"CompletionItemKind \n  \n Field  Property  Method  Event  Argument  CustomOperation  Other "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-completionpath.html","title":"CompletionPath","content":"CompletionPath \n  \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-entity.html","title":"Entity","content":"Entity \n <p>Helper data structure representing a symbol, suitable for implementing unresolved identifiers resolution code fixes.</p>\n\n \n FullRelativeName <p>Full name, relative to the current scope.</p>\n\n Qualifier <p>Ident parts needed to append to the current ident to make it resolvable in current scope.</p>\n\n Namespace <p>Namespace that is needed to open to make the entity resolvable in the current scope.</p>\n\n Name <p>Full display name (i.e. last ident plus modules with <code>RequireQualifiedAccess</code> attribute prefixed).</p>\n\n LastIdent <p>Last part of the entity's full name.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-entitycache.html","title":"EntityCache","content":"EntityCache \n <p>Thread safe wrapper over <a href=\"fsharp-compiler-sourcecodeservices-iassemblycontentcache.html\" title=\"IAssemblyContentCache\"><code>IAssemblyContentCache</code></a>.</p>\n\n \n ( .ctor )  Clear <p>Clears the cache.</p>\n\n Locking <p>Performs an operation on the cache in thread safe manner.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-entitykind.html","title":"EntityKind","content":"EntityKind \n  \n Attribute  Type  FunctionOrValue  Module "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-externalsymbol.html","title":"ExternalSymbol","content":"ExternalSymbol \n <p>Represents a symbol in an external (non F#) assembly</p>\n\n \n Type  Constructor  Method  Field  Event  Property "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-externaltype.html","title":"ExternalType","content":"ExternalType \n <p>Represents a type in an external (non F#) assembly.</p>\n\n \n Type <p>Type defined in non-F# assembly.</p>\n\n Array <p>Array of type that is defined in non-F# assembly.</p>\n\n Pointer <p>Pointer defined in non-F# assembly.</p>\n\n TypeVar <p>Type variable defined in non-F# assembly.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpabstractparameter.html","title":"FSharpAbstractParameter","content":"FSharpAbstractParameter \n <p>Represents a parameter in an abstract method of a class or interface</p>\n\n \n Type <p>The declared or inferred type of the parameter</p>\n\n Name <p>The optional name of the parameter</p>\n\n IsOutArg <p>Indicate this is an out argument</p>\n\n IsOptionalArg <p>Indicate this is an optional argument</p>\n\n IsInArg <p>Indicate this is an in argument</p>\n\n Attributes <p>The declared attributes of the parameter</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpabstractsignature.html","title":"FSharpAbstractSignature","content":"FSharpAbstractSignature \n <p>Represents the signature of an abstract slot of a class or interface</p>\n\n \n Name <p>Get the name of the abstract slot</p>\n\n MethodGenericParameters <p>Get the generic arguments of the abstract slot</p>\n\n DeclaringTypeGenericParameters <p>Get the generic arguments of the type defining the abstract slot</p>\n\n DeclaringType <p>Get the declaring type of the abstract slot</p>\n\n AbstractReturnType <p>Get the return type of the abstract slot</p>\n\n AbstractArguments <p>Get the arguments of the abstract slot</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpaccessibility.html","title":"FSharpAccessibility","content":"FSharpAccessibility \n <p>Indicates the accessibility of a symbol, as seen by the F# language</p>\n\n \n IsPublic <p>Indicates the symbol has public accessibility.</p>\n\n IsProtected <p>Indicates the symbol has protected accessibility.</p>\n\n IsPrivate <p>Indicates the symbol has private accessibility.</p>\n\n IsInternal <p>Indicates the symbol has internal accessibility.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpaccessibilityrights.html","title":"FSharpAccessibilityRights","content":"FSharpAccessibilityRights \n <p>Represents the rights of a compilation to access symbols</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpactivepatterncase.html","title":"FSharpActivePatternCase","content":"FSharpActivePatternCase \n <p>A subtype of FSharpSymbol that represents a single case within an active pattern</p>\n\n \n XmlDocSig <p>XML documentation signature for the active pattern case, used for .xml file lookup for compiled code</p>\n\n XmlDoc <p>Get the in-memory XML documentation for the active pattern case, used when code is checked in-memory</p>\n\n Name <p>The name of the active pattern case</p>\n\n Index <p>Index of the case in the pattern group</p>\n\n Group <p>The group of active pattern cases this belongs to</p>\n\n DeclarationLocation <p>The location of declaration of the active pattern case</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpactivepatterngroup.html","title":"FSharpActivePatternGroup","content":"FSharpActivePatternGroup \n <p>Represents all cases within an active pattern</p>\n\n \n OverallType <p>Get the type indicating signature of the active pattern</p>\n\n Names <p>The names of the active pattern cases</p>\n\n Name <p>The whole group name</p>\n\n IsTotal <p>Indicate this is a total active pattern</p>\n\n DeclaringEntity <p>Try to get the entity in which the active pattern is declared</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpanonrecordtypedetails.html","title":"FSharpAnonRecordTypeDetails","content":"FSharpAnonRecordTypeDetails \n <p>A subtype of FSharpSymbol that represents a record or union case field as seen by the F# language</p>\n\n \n SortedFieldNames <p>The sorted labels of the anonymous type</p>\n\n EnclosingCompiledTypeNames <p>Names of any enclosing types of the compiled form of the anonymous type (if the anonymous type was defined as a nested type)</p>\n\n CompiledName <p>The name of the compiled form of the anonymous type</p>\n\n Assembly <p>The assembly where the compiled form of the anonymous type is defined</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpassembly.html","title":"FSharpAssembly","content":"FSharpAssembly \n <p>Represents an assembly as seen by the F# language</p>\n\n \n SimpleName <p>The simple name for the assembly</p>\n\n QualifiedName <p>The qualified name of the assembly</p>\n\n IsProviderGenerated <p>Indicates if the assembly was generated by a type provider and is due for static linking</p>\n\n FileName <p>The file name for the assembly, if any</p>\n\n Contents <p>The contents of the this assembly</p>\n\n CodeLocation "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpassemblycontents.html","title":"FSharpAssemblyContents","content":"FSharpAssemblyContents \n <p>Represents the definitional contents of an assembly, as seen by the F# language</p>\n\n \n ImplementationFiles <p>The contents of the implementation files in the assembly</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpassemblysignature.html","title":"FSharpAssemblySignature","content":"FSharpAssemblySignature \n <p>Represents an inferred signature of part of an assembly as seen by the F# language</p>\n\n \n FindEntityByPath <p>Find entity using compiled names</p>\n\n Entities <p>The (non-nested) module and type definitions in this signature</p>\n\n Attributes <p>Get the declared attributes for the assembly.\nOnly available when parsing an entire project.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpattribute.html","title":"FSharpAttribute","content":"FSharpAttribute \n <p>Represents a custom attribute attached to F# source code or a compiler .NET component</p>\n\n \n Format <p>Format the attribute using the rules of the given display context</p>\n\n NamedArguments <p>The named arguments for the attribute</p>\n\n IsUnresolved <p>Indicates if the attribute type is in an unresolved assembly</p>\n\n ConstructorArguments <p>The arguments to the constructor for the attribute</p>\n\n AttributeType <p>The type of the attribute</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpcheckfileanswer.html","title":"FSharpCheckFileAnswer","content":"FSharpCheckFileAnswer \n <p>The result of calling TypeCheckResult including the possibility of abort and background compiler not caught up.</p>\n\n \n Aborted <p>Aborted because cancellation caused an abandonment of the operation</p>\n\n Succeeded <p>Success</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpcheckfileresults.html","title":"FSharpCheckFileResults","content":"FSharpCheckFileResults \n <p>A handle to the results of CheckFileInProject.</p>\n\n \n GetAllUsesOfAllSymbolsInFile <p>Get all textual usages of all symbols throughout the file</p>\n\n GetDeclarationListInfo <p>Get the items for a declaration list</p>\n\n GetDeclarationListSymbols <p>Get the items for a declaration list in FSharpSymbol format</p>\n\n GetDeclarationLocation <p>Resolve the names at the given location to the declaration location of the corresponding construct.</p>\n\n GetDisplayContextForPos <p>Find the most precise display environment for the given line and column.</p>\n\n GetF1Keyword <p>Compute the Visual Studio F1-help key identifier for the given location, based on name resolution results</p>\n\n GetFormatSpecifierLocations <p>Get the locations of format specifiers</p>\n\n GetFormatSpecifierLocationsAndArity <p>Get the locations of and number of arguments associated with format specifiers</p>\n\n GetMethods <p>Compute a set of method overloads to show in a dialog relevant to the given code location.</p>\n\n GetMethodsAsSymbols <p>Compute a set of method overloads to show in a dialog relevant to the given code location.  The resulting method overloads are returned as symbols.</p>\n\n GetSemanticClassification <p>Get any extra colorization info that is available after the typecheck</p>\n\n GetStructuredToolTipText <p>Compute a formatted tooltip for the given location</p>\n\n GetSymbolUseAtLocation <p>Resolve the names at the given location to a use of symbol.</p>\n\n GetToolTipText <p>Compute a formatted tooltip for the given location</p>\n\n GetUsesOfSymbolInFile <p>Get the textual usages that resolved to the given symbol throughout the file</p>\n\n IsRelativeNameResolvableFromSymbol <p>Determines if a long ident is resolvable at a specific point.\n<param name=\"userOpName\">An optional string used for tracing compiler operations associated with this request.</param></p>\n\n ProjectContext <p>Get the resolution of the ProjectOptions</p>\n\n PartialAssemblySignature <p>Get a view of the contents of the assembly up to and including the file just checked</p>\n\n OpenDeclarations <p>Open declarations in the file, including auto open modules.</p>\n\n ImplementationFile <p>Represents complete typechecked implementation file, including its typechecked signatures if any.</p>\n\n HasFullTypeCheckInfo <p>Indicates whether type checking successfully occurred with some results returned. If false, indicates that\nan unrecoverable error in earlier checking/parsing/resolution steps.</p>\n\n Errors <p>The errors returned by parsing a source file.</p>\n\n DependencyFiles <p>Indicates the set of files which must be watched to accurately track changes that affect these results,\nClients interested in reacting to updates to these files should watch these files and take actions as described\nin the documentation for compiler service.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpcheckprojectresults.html","title":"FSharpCheckProjectResults","content":"FSharpCheckProjectResults \n <p>A handle to the results of CheckFileInProject.</p>\n\n \n GetAllUsesOfAllSymbols <p>Get all textual usages of all symbols throughout the project</p>\n\n GetOptimizedAssemblyContents <p>Get an optimized view of the overall contents of the assembly. Only valid to use if HasCriticalErrors is false.</p>\n\n GetUsesOfSymbol <p>Get the textual usages that resolved to the given symbol throughout the project</p>\n\n ProjectContext <p>Get the resolution of the ProjectOptions</p>\n\n HasCriticalErrors <p>Indicates if critical errors existed in the project options</p>\n\n Errors <p>The errors returned by processing the project</p>\n\n DependencyFiles <p>Indicates the set of files which must be watched to accurately track changes that affect these results,\nClients interested in reacting to updates to these files should watch these files and take actions as described\nin the documentation for compiler service.</p>\n\n AssemblySignature <p>Get a view of the overall signature of the assembly. Only valid to use if HasCriticalErrors is false.</p>\n\n AssemblyContents <p>Get a view of the overall contents of the assembly. Only valid to use if HasCriticalErrors is false.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpchecker.html","title":"FSharpChecker","content":"FSharpChecker \n <p>Used to parse and check F# source code.</p>\n\n \n CheckFileInProject <p>Check a source code file, returning a handle to the results</p>\n<p>Note: all files except the one being checked are read from the FileSystem API</p>\n<p>Return FSharpCheckFileAnswer.Aborted if a parse tree was not available.</p>\n\n CheckFileInProjectAllowingStaleCachedResults <p>Check a source code file, returning a handle to the results of the parse including\nthe reconstructed types in the file.All files except the one being checked are read from the FileSystem APINote: returns NoAntecedent if the background builder is not yet done preparing the type check context for the\nfile (e.g. loading references and parsing/checking files in the project that this file depends upon).\nIn this case, the caller can either retry, or wait for FileTypeCheckStateIsDirty to be raised for this file.</p>\n\n CheckProjectInBackground <p>Set the project to be checked in the background.  Overrides any previous call to <c>CheckProjectInBackground</c></p>\n\n ClearCache <p>Clear the internal cache of the given projects.\n<param name=\"options\">The given project options.</param>\n<param name=\"userOpName\">An optional string used for tracing compiler operations associated with this request.</param></p>\n\n ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients <p>Flush all caches and garbage collect</p>\n\n Compile <p>TypeCheck and compile provided AST</p>\n\n Compile <p>Compile using the given flags.  Source files names are resolved via the FileSystem API.\nThe output file must be given by a -o flag.\nThe first argument is ignored and can just be \"fsc.exe\".</p>\n\n CompileToDynamicAssembly <p>TypeCheck and compile provided AST</p>\n\n CompileToDynamicAssembly <p>Compiles to a dynamic assembly using the given flags.</p>\n<p>The first argument is ignored and can just be \"fsc.exe\".</p>\n<p>Any source files names are resolved via the FileSystem API. An output file name must be given by a -o flag, but this will not\nbe written - instead a dynamic assembly will be created and loaded.</p>\n<p>If the 'execute' parameter is given the entry points for the code are executed and\nthe given TextWriters are used for the stdout and stderr streams respectively. In this\ncase, a global setting is modified during the execution.</p>\n\n FindBackgroundReferencesInFile <p>Optimized find references for a given symbol in a file of project.All files are read from the FileSystem API, including the file being checked.</p>\n\n GetBackgroundCheckResultsForFileInProject <p>Like CheckFileInProject, but uses the existing results from the background builder.All files are read from the FileSystem API, including the file being checked.</p>\n\n GetBackgroundParseResultsForFileInProject <p>Like ParseFile, but uses results from the background builder.All files are read from the FileSystem API, including the file being checked.</p>\n\n GetBackgroundSemanticClassificationForFile <p>Get semantic classification for a file.All files are read from the FileSystem API, including the file being checked.</p>\n\n GetParsingOptionsFromCommandLineArgs <p>Get the FSharpParsingOptions implied by a set of command line arguments.</p>\n\n GetParsingOptionsFromCommandLineArgs <p>Get the FSharpParsingOptions implied by a set of command line arguments and list of source files.</p>\n\n GetParsingOptionsFromProjectOptions <p>Get the FSharpParsingOptions implied by a FSharpProjectOptions.</p>\n\n GetProjectOptionsFromCommandLineArgs <p>Get the FSharpProjectOptions implied by a set of command line arguments.</p>\n\n GetProjectOptionsFromScript <p>For a given script file, get the FSharpProjectOptions implied by the #load closure.All files are read from the FileSystem API, except the file being checked.</p>\n\n InvalidateAll <p>This function is called when the entire environment is known to have changed for reasons not encoded in the ProjectOptions of any project/compilation.</p>\n\n InvalidateConfiguration <p>This function is called when the configuration is known to have changed for reasons not encoded in the ProjectOptions.\nFor example, dependent references may have been deleted or created.\n<param name=\"startBackgroundCompileIfAlreadySeen\">Start a background compile of the project if a project with the same name has already been seen before.</param>\n<param name=\"userOpName\">An optional string used for tracing compiler operations associated with this request.</param></p>\n\n MatchBraces <p>Parse a source code file, returning information about brace matching in the file.\nReturn an enumeration of the matching parenthetical tokens in the file.</p>\n\n MatchBraces <p>Parse a source code file, returning information about brace matching in the file.\nReturn an enumeration of the matching parenthetical tokens in the file.</p>\n\n NotifyProjectCleaned <p>This function is called when a project has been cleaned/rebuilt, and thus any live type providers should be refreshed.</p>\n\n ParseAndCheckFileInProject <p>Parse and check a source code file, returning a handle to the results</p>\n<p>Note: all files except the one being checked are read from the FileSystem API</p>\n<p>Return FSharpCheckFileAnswer.Aborted if a parse tree was not available.</p>\n\n ParseAndCheckProject <p>Parse and typecheck all files in a project.All files are read from the FileSystem API</p>\n\n ParseFile <p>Parses a source code for a file and caches the results. Returns an AST that can be traversed for various features.</p>\n\n ParseFileInProject <p>Parses a source code for a file. Returns an AST that can be traversed for various features.</p>\n\n ParseFileNoCache <p>Parses a source code for a file. Returns an AST that can be traversed for various features.</p>\n\n StopBackgroundCompile <p>Stop the background compile.</p>\n\n TokenizeFile <p>Tokenize an entire file, line by line</p>\n\n TokenizeLine <p>Tokenize a single line, returning token information and a tokenization state represented by an integer</p>\n\n TryGetRecentCheckResultsForFile <p>Try to get type check results for a file. This looks up the results of recent type checks of the\nsame file, regardless of contents. The version tag specified in the original check of the file is returned.\nIf the source of the file has changed the results returned by this function may be out of date, though may\nstill be usable for generating intellisense menus and information.</p>\n\n WaitForBackgroundCompile <p>Block until the background compile finishes.</p>\n\n ImplicitlyStartBackgroundWork <p>Get or set a flag which controls if background work is started implicitly.</p>\n<p>If true, calls to CheckFileInProject implicitly start a background check of that project, replacing\nany other background checks in progress. This is useful in IDE applications with spare CPU cycles as\nit prepares the project analysis results for use.  The default is 'true'.</p>\n\n MaxMemory <p>A maximum number of megabytes of allocated memory. If the figure reported by <c>System.GC.GetTotalMemory(false)</c> goes over this limit, the FSharpChecker object will attempt to free memory and reduce cache sizes to a minimum.</param></p>\n\n PauseBeforeBackgroundWork <p>Get or set the pause time in milliseconds before background work is started.</p>\n\n PauseBeforeBackgroundWork <p>Get or set the pause time in milliseconds before background work is started.</p>\n\n MaxMemory <p>A maximum number of megabytes of allocated memory. If the figure reported by <c>System.GC.GetTotalMemory(false)</c> goes over this limit, the FSharpChecker object will attempt to free memory and reduce cache sizes to a minimum.</param></p>\n\n ImplicitlyStartBackgroundWork <p>Get or set a flag which controls if background work is started implicitly.</p>\n<p>If true, calls to CheckFileInProject implicitly start a background check of that project, replacing\nany other background checks in progress. This is useful in IDE applications with spare CPU cycles as\nit prepares the project analysis results for use.  The default is 'true'.</p>\n\n ProjectChecked <p>Notify the host that a project has been fully checked in the background (using file contents provided by the file system API)</p>\n<p>The event may be raised on a background thread.</p>\n\n MaxMemoryReached <p>Raised after the maxMB memory threshold limit is reached</p>\n\n FileParsed <p>Raised after a parse of a file in the background analysis.</p>\n<p>The event will be raised on a background thread.</p>\n\n FileChecked <p>Raised after a check of a file in the background analysis.</p>\n<p>The event will be raised on a background thread.</p>\n\n CurrentQueueLength <p>Current queue length of the service, for debug purposes.\nIn addition, a single async operation or a step of a background build\nmay be in progress - such an operation is not counted in the queue length.</p>\n\n BeforeBackgroundFileCheck <p>Notify the host that the logical type checking context for a file has now been updated internally\nand that the file has become eligible to be re-typechecked for errors.</p>\n<p>The event will be raised on a background thread.</p>\n\n Create <p>Create an instance of an FSharpChecker.</p>\n\n Instance  GlobalForegroundTypeCheckCountStatistic <p>Report a statistic for testability</p>\n\n GlobalForegroundParseCountStatistic <p>Report a statistic for testability</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpdeclarationlistinfo.html","title":"FSharpDeclarationListInfo","content":"FSharpDeclarationListInfo \n <p>Represents a set of declarations in F# source code, with information attached ready for display by an editor.\nReturned by GetDeclarations.</p>\n\n \n Items  IsForType  IsError  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpdeclarationlistitem.html","title":"FSharpDeclarationListItem","content":"FSharpDeclarationListItem \n <p>Represents a declaration in F# source code, with information attached ready for display by an editor.\nReturned by GetDeclarations.</p>\n\n \n StructuredDescriptionTextAsync <p>Get the description text, asynchronously.  Never returns \"Loading...\".</p>\n\n NamespaceToOpen  NameInCode <p>Get the name for the declaration as it's presented in source code.</p>\n\n Name <p>Get the display name for the declaration.</p>\n\n MinorPriority  Kind  IsResolved  IsOwnMember  Glyph  FullName  DescriptionTextAsync  Accessibility "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpdelegatesignature.html","title":"FSharpDelegateSignature","content":"FSharpDelegateSignature \n <p>Represents a delegate signature in an F# symbol</p>\n\n \n DelegateReturnType <p>Get the return type of the delegate signature</p>\n\n DelegateArguments <p>Get the argument types of the delegate signature</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpdisplaycontext.html","title":"FSharpDisplayContext","content":"FSharpDisplayContext \n <p>Represents the information needed to format types and other information in a style\nsuitable for use in F# source text at a particular source location.</p>\n<p>Acquired via GetDisplayEnvAtLocationAlternate and similar methods. May be passed\nto the Format method on FSharpType and other methods.</p>\n\n \n WithShortTypeNames  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpenclosingentitykind.html","title":"FSharpEnclosingEntityKind","content":"FSharpEnclosingEntityKind \n  \n Namespace  Module  Class  Exception  Interface  Record  Enum  DU "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpentity.html","title":"FSharpEntity","content":"FSharpEntity \n <p>A subtype of FSharpSymbol that represents a type definition or module as seen by the F# language</p>\n\n \n XmlDocSig <p>Get the XML documentation signature for the entity, used for .xml file lookup for compiled code</p>\n\n XmlDoc <p>Get the in-memory XML documentation for the entity, used when code is checked in-memory</p>\n\n UsesPrefixDisplay <p>Indicates if the type prefers the \"tycon<a,b>\" syntax for display etc.</p>\n\n UnionCases <p>Get the cases of a union type</p>\n\n TryFullName <p>Get the full name of the type or module if it is available</p>\n\n StaticParameters <p>Get the static parameters for a provided type</p>\n\n RepresentationAccessibility <p>Get the declared accessibility of the representation, not taking signatures into account</p>\n\n RecordFields  QualifiedName <p>Get the fully qualified name of the type or module</p>\n\n NestedEntities <p>Get the modules and types defined in a module, or the nested types of a type</p>\n\n Namespace <p>Get the namespace containing the type or module, if any. Use 'None' for item not in a namespace.</p>\n\n MembersOrValues  MembersFunctionsAndValues <p>Get the properties, events and methods of a type definitions, or the functions and values of a module</p>\n\n LogicalName <p>Get the name of the type or module, possibly with `n mangling</p>\n\n IsValueType <p>Indicates if the entity is a struct or enum</p>\n\n IsUnresolved <p>Indicates if the entity is in an unresolved assembly</p>\n\n IsStaticInstantiation <p>Indicates if the entity is a 'fake' symbol related to a static instantiation of a type provider</p>\n\n IsProvidedAndGenerated <p>Indicates if the entity is a generated provided type</p>\n\n IsProvidedAndErased <p>Indicates if the entity is an erased provided type</p>\n\n IsProvided <p>Indicates if the entity is a provided type</p>\n\n IsOpaque <p>Indicates if the entity is a type definition for a reference type where the implementation details are hidden by a signature</p>\n\n IsNamespace <p>Indicates if the entity is a part of a namespace path</p>\n\n IsMeasure <p>Indicates if the entity is a measure definition</p>\n\n IsInterface <p>Indicates if the entity is an interface type definition</p>\n\n IsFSharpUnion <p>Indicates if the entity is union type</p>\n\n IsFSharpRecord <p>Indicates if the entity is record type</p>\n\n IsFSharpModule <p>Indicates if the entity is an F# module definition</p>\n\n IsFSharpExceptionDeclaration <p>Indicates an F# exception declaration</p>\n\n IsFSharpAbbreviation <p>Indicates if the entity is a measure, type or exception abbreviation</p>\n\n IsFSharp <p>Indicates if this is a reference to something in an F#-compiled assembly</p>\n\n IsEnum <p>Indicates if the entity is an enum type definition</p>\n\n IsDelegate <p>Indicates if the entity is a delegate type definition</p>\n\n IsClass <p>Indicates if the entity is a class type definition</p>\n\n IsByRef <p>Indicates if is the 'byref<_>' type definition used for byref types in F#-compiled assemblies</p>\n\n IsAttributeType <p>Check if the entity inherits from System.Attribute in its type hierarchy</p>\n\n IsArrayType <p>Indicates if the entity is an array type</p>\n\n HasFSharpModuleSuffix <p>Indicates that a module is compiled to a class with the given mangled name. The mangling is reversed during lookup</p>\n\n HasAssemblyCodeRepresentation <p>Indicates if the type is implemented through a mapping to IL assembly code. This is only\ntrue for types in FSharp.Core.dll</p>\n\n GenericParameters <p>Get the generic parameters, possibly including unit-of-measure parameters</p>\n\n FullName <p>Get the full name of the type or module</p>\n\n FSharpFields <p>Get the fields of a record, class, struct or enum from the perspective of the F# language.\nThis includes static fields, the 'val' bindings in classes and structs, and the value definitions in enums.\nFor classes, the list may include compiler generated fields implied by the use of primary constructors.</p>\n\n FSharpDelegateSignature <p>Indicates if the type is a delegate with the given Invoke signature</p>\n\n DisplayName <p>Get the name of the type or module as displayed in F# code</p>\n\n DeclaringEntity <p>Get the enclosing entity for the definition</p>\n\n DeclaredInterfaces <p>Get the declared interface implementations</p>\n\n DeclarationLocation <p>Get the declaration location for the type constructor</p>\n\n CompiledName <p>Get the compiled name of the type or module, possibly with `n mangling. This is identical to LogicalName\nunless the CompiledName attribute is used.</p>\n\n BaseType <p>Get the base type, if any</p>\n\n Attributes <p>Get the declared attributes for the type</p>\n\n ArrayRank <p>Get the rank of an array type</p>\n\n AllInterfaces <p>Get all the interface implementations, by walking the type hierarchy</p>\n\n AllCompilationPaths <p>Get all compilation paths, taking <code>Module</code> suffixes into account.</p>\n\n ActivePatternCases <p>Get all active pattern cases defined in all active patterns in the module.</p>\n\n Accessibility <p>Get the declared accessibility of the type</p>\n\n AccessPath <p>Get the path used to address the entity (e.g. \"Namespace.Module1.NestedModule2\"). Gives\n\"global\" for items not in a namespace.</p>\n\n AbbreviatedType <p>Get the type abbreviated by an F# type abbreviation</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharperrorinfo.html","title":"FSharpErrorInfo","content":"FSharpErrorInfo \n <p>Object model for diagnostics</p>\n\n \n Subcategory  StartLineAlternate  StartColumn  Start  Severity  Range  Message  FileName  ErrorNumber  EndLineAlternate  EndColumn  End "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharperrorseverity.html","title":"FSharpErrorSeverity","content":"FSharpErrorSeverity \n  \n Warning  Error "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpexpr.html","title":"FSharpExpr","content":"FSharpExpr \n <p>Represents a checked and reduced expression, as seen by the F# language.  The active patterns\nin 'FSharp.Compiler.SourceCodeServices' can be used to analyze information about the expression.</p>\n<p>Pattern matching is reduced to decision trees and conditional tests. Some other\nconstructs may be represented in reduced form.</p>\n\n \n Type <p>The type of the expression</p>\n\n Range <p>The range of the expression</p>\n\n ImmediateSubExpressions <p>The immediate sub-expressions of the expression.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpfield.html","title":"FSharpField","content":"FSharpField \n <p>A subtype of FSharpSymbol that represents a record or union case field as seen by the F# language</p>\n\n \n XmlDocSig <p>Get the XML documentation signature for .xml file lookup for the field, used for .xml file lookup for compiled code</p>\n\n XmlDoc <p>Get the in-memory XML documentation for the field, used when code is checked in-memory</p>\n\n PropertyAttributes <p>Get the attributes attached to generated property</p>\n\n Name <p>Get the name of the field</p>\n\n LiteralValue <p>Get the default initialization info, for static literals</p>\n\n IsVolatile <p>Indicates if the field is declared volatile</p>\n\n IsUnresolved <p>Indicates if the record field is for a type in an unresolved assembly</p>\n\n IsUnionCaseField <p>Indicates if the field is declared in a union case</p>\n\n IsStatic <p>Indicates a static field</p>\n\n IsNameGenerated <p>Indicates if the field name was generated by compiler (e.g. ItemN names in union cases and DataN in exceptions).\nThis API returns true for source defined symbols only.</p>\n\n IsMutable <p>Indicates if the field is declared 'static'</p>\n\n IsLiteral <p>Indicates if the field has a literal value</p>\n\n IsDefaultValue <p>Indicates if the field declared is declared 'DefaultValue'</p>\n\n IsCompilerGenerated <p>Indicates a compiler generated field, not visible to Intellisense or name resolution</p>\n\n IsAnonRecordField <p>Is this a field from an anonymous record type?</p>\n\n FieldType <p>Get the type of the field, w.r.t. the generic parameters of the enclosing type constructor</p>\n\n FieldAttributes <p>Get the attributes attached to generated field</p>\n\n DeclaringUnionCase <p>Returns the declaring union case symbol</p>\n\n DeclaringEntity <p>Get the declaring entity of this field, if any. Fields from anonymous types do not have a declaring entity</p>\n\n DeclarationLocation <p>Get the declaration location of the field</p>\n\n AnonRecordFieldDetails <p>If the field is from an anonymous record type then get the details of the field including the index in the sorted array of fields</p>\n\n Accessibility <p>Indicates if the declared visibility of the field, not taking signatures into account</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpfinddeclfailurereason.html","title":"FSharpFindDeclFailureReason","content":"FSharpFindDeclFailureReason \n <p>Represents the reason why the GetDeclarationLocation operation failed.</p>\n\n \n Unknown <p>Generic reason: no particular information about error apart from a message</p>\n\n NoSourceCode <p>Source code file is not available</p>\n\n ProvidedType <p>Trying to find declaration of ProvidedType without TypeProviderDefinitionLocationAttribute</p>\n\n ProvidedMember <p>Trying to find declaration of ProvidedMember without TypeProviderDefinitionLocationAttribute</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpfinddeclresult.html","title":"FSharpFindDeclResult","content":"FSharpFindDeclResult \n <p>Represents the result of the GetDeclarationLocation operation.</p>\n\n \n DeclNotFound <p>Indicates a declaration location was not found, with an additional reason</p>\n\n DeclFound <p>Indicates a declaration location was found</p>\n\n ExternalDecl <p>Indicates an external declaration was found</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpgenericparameter.html","title":"FSharpGenericParameter","content":"FSharpGenericParameter \n <p>A subtype of FSharpSymbol that represents a generic parameter for an FSharpSymbol</p>\n\n \n XmlDoc <p>Get the in-memory XML documentation for the type parameter, used when code is checked in-memory</p>\n\n Name <p>Get the name of the generic parameter</p>\n\n IsSolveAtCompileTime <p>Indicates if this is a statically resolved type variable</p>\n\n IsMeasure <p>Indicates if this is a measure variable</p>\n\n IsCompilerGenerated <p>Indicates if this is a compiler generated type parameter</p>\n\n DeclarationLocation <p>Get the range of the generic parameter</p>\n\n Constraints <p>Get the declared or inferred constraints for the type parameter</p>\n\n Attributes <p>Get the declared attributes of the type parameter.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpgenericparameterconstraint.html","title":"FSharpGenericParameterConstraint","content":"FSharpGenericParameterConstraint \n <p>Represents a constraint on a generic type parameter</p>\n\n \n SimpleChoices <p>Gets further information about a choice constraint</p>\n\n MemberConstraintData <p>Gets further information about a member constraint</p>\n\n IsUnmanagedConstraint <p>Indicates a constraint that a type is an unmanaged type</p>\n\n IsSupportsNullConstraint <p>Indicates a constraint that a type has a 'null' value</p>\n\n IsSimpleChoiceConstraint <p>Indicates a constraint that is a type is a simple choice between one of the given ground types. Used by printf format strings.</p>\n\n IsRequiresDefaultConstructorConstraint <p>Indicates a constraint that a type has a parameterless constructor</p>\n\n IsReferenceTypeConstraint <p>Indicates a constraint that a type is a reference type</p>\n\n IsNonNullableValueTypeConstraint <p>Indicates a constraint that a type is a non-Nullable value type</p>\n\n IsMemberConstraint <p>Indicates a constraint that a type has a member with the given signature</p>\n\n IsEqualityConstraint <p>Indicates a constraint that a type supports F# generic equality</p>\n\n IsEnumConstraint <p>Indicates a constraint that a type is an enum with the given underlying</p>\n\n IsDelegateConstraint <p>Indicates a constraint that a type is a delegate from the given tuple of args to the given return type</p>\n\n IsDefaultsToConstraint <p>Indicates a default value for an inference type variable should it be neither generalized nor solved</p>\n\n IsComparisonConstraint <p>Indicates a constraint that a type supports F# generic comparison</p>\n\n IsCoercesToConstraint <p>Indicates a constraint that a type is a subtype of the given type</p>\n\n EnumConstraintTarget <p>Gets further information about an enumeration constraint</p>\n\n DelegateConstraintData <p>Gets further information about a delegate constraint</p>\n\n DefaultsToConstraintData <p>Gets further information about a defaults-to constraint</p>\n\n CoercesToTarget <p>Gets further information about a coerces-to constraint</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpgenericparameterdefaultstoconstraint.html","title":"FSharpGenericParameterDefaultsToConstraint","content":"FSharpGenericParameterDefaultsToConstraint \n <p>Represents further information about a 'defaults to' constraint on a generic type parameter</p>\n\n \n DefaultsToTarget <p>Get the default type associated with the 'defaults to' constraint</p>\n\n DefaultsToPriority <p>Get the priority off the 'defaults to' constraint</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpgenericparameterdelegateconstraint.html","title":"FSharpGenericParameterDelegateConstraint","content":"FSharpGenericParameterDelegateConstraint \n <p>Represents further information about a delegate constraint on a generic type parameter</p>\n\n \n DelegateTupledArgumentType <p>Get the tupled argument type required by the constraint</p>\n\n DelegateReturnType <p>Get the return type required by the constraint</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpgenericparametermemberconstraint.html","title":"FSharpGenericParameterMemberConstraint","content":"FSharpGenericParameterMemberConstraint \n <p>Represents further information about a member constraint on a generic type parameter</p>\n\n \n MemberSources <p>Get the types that may be used to satisfy the constraint</p>\n\n MemberReturnType <p>Get the return type of the method required by the constraint</p>\n\n MemberName <p>Get the name of the method required by the constraint</p>\n\n MemberIsStatic <p>Indicates if the the method required by the constraint must be static</p>\n\n MemberArgumentTypes <p>Get the argument types of the method required by the constraint</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpglyph.html","title":"FSharpGlyph","content":"FSharpGlyph \n  \n Class  Constant  Delegate  Enum  EnumMember  Event  Exception  Field  Interface  Method  OverridenMethod  Module  NameSpace  Property  Struct  Typedef  Type  Union  Variable  ExtensionMethod  Error "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpimplementationfilecontents.html","title":"FSharpImplementationFileContents","content":"FSharpImplementationFileContents \n <p>Represents the definitional contents of a single file or fragment in an assembly, as seen by the F# language</p>\n\n \n QualifiedName <p>The qualified name acts to fully-qualify module specifications and implementations</p>\n\n IsScript <p>Indicates if the implementation file is a script</p>\n\n HasExplicitEntryPoint <p>Indicates if the implementation file has an explicit entry point</p>\n\n FileName <p>Get the system path of the implementation file</p>\n\n Declarations <p>Get the declarations that make up this implementation file</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpimplementationfiledeclaration.html","title":"FSharpImplementationFileDeclaration","content":"FSharpImplementationFileDeclaration \n <p>Represents a declaration in an implementation file, as seen by the F# language</p>\n\n \n Entity <p>Represents the declaration of a type</p>\n\n MemberOrFunctionOrValue <p>Represents the declaration of a member, function or value, including the parameters and body of the member</p>\n\n InitAction <p>Represents the declaration of a static initialization action</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpinlineannotation.html","title":"FSharpInlineAnnotation","content":"FSharpInlineAnnotation \n  \n PseudoValue <p>Indicates the value is inlined and compiled code for the function does not exist</p>\n\n AlwaysInline <p>Indicates the value is inlined but compiled code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined</p>\n\n OptionalInline <p>Indicates the value is optionally inlined</p>\n\n NeverInline <p>Indicates the value is never inlined</p>\n\n AggressiveInline <p>Indicates the value is aggressively inlined by the .NET runtime</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharplinetokenizer.html","title":"FSharpLineTokenizer","content":"FSharpLineTokenizer \n <p>Object to tokenize a line of F# source code, starting with the given lexState.  The lexState should be FSharpTokenizerLexState.Initial for\nthe first line of text. Returns an array of ranges of the text and two enumerations categorizing the\ntokens and characters covered by that range, i.e. FSharpTokenColorKind and FSharpTokenCharKind.  The enumerations\nare somewhat adhoc but useful enough to give good colorization options to the user in an IDE.</p>\n<p>A new lexState is also returned.  An IDE-plugin should in general cache the lexState\nvalues for each line of the edited code.</p>\n\n \n ScanToken <p>Scan one token from the line</p>\n\n ColorStateOfLexState  LexStateOfColorState "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpmemberorfunctionorvalue.html","title":"FSharpMemberOrFunctionOrValue","content":"FSharpMemberOrFunctionOrValue \n <p>A subtype of F# symbol that represents an F# method, property, event, function or value, including extension members.</p>\n\n \n FormatLayout <p>Format the type using the rules of the given display context</p>\n\n Overloads <p>Gets the overloads for the current method\nmatchParameterNumber indicates whether to filter the overloads to match the number of parameters in the current symbol</p>\n\n XmlDocSig <p>XML documentation signature for the value, used for .xml file lookup for compiled code</p>\n\n XmlDoc <p>Get the in-memory XML documentation for the value, used when code is checked in-memory</p>\n\n SetterMethod <p>Get an associated setter method of the property</p>\n\n ReturnParameter  LogicalName <p>Get the logical name of the member</p>\n\n LiteralValue <p>Indicates if this is a [<Literal>] value, and if so what value? (may be null)</p>\n\n IsValue <p>Indicated if this is a value</p>\n\n IsValCompiledAsMethod <p>Indicated if this is a value compiled to a method</p>\n\n IsUnresolved <p>Indicates if the member, function or value is in an unresolved assembly</p>\n\n IsTypeFunction <p>Indicates if this is an F# type function</p>\n\n IsSetterMethod <p>Indicates if this is a setter method for a property, or a use of a property in setter mode</p>\n\n IsPropertySetterMethod <p>Indicates if this is a setter method for a property, or a use of a property in setter mode</p>\n\n IsPropertyGetterMethod <p>Indicates if this is a getter method for a property, or a use of a property in getter mode</p>\n\n IsProperty <p>Indicates if this is a property member</p>\n\n IsOverrideOrExplicitMember  IsOverrideOrExplicitInterfaceImplementation <p>Indicates if this is an 'override', 'default' or an explicit implementation of an interface member</p>\n\n IsMutable <p>Indicates if this is a mutable value</p>\n\n IsModuleValueOrMember <p>Indicates if this is a module or member value</p>\n\n IsMemberThisValue <p>Indicates if this is the \"x\" in \"member x.M = ...\"</p>\n\n IsMember <p>Indicates if this is a member, including extension members?</p>\n\n IsInstanceMemberInCompiledCode <p>Indicates if this is an instance member in compiled code.</p>\n<p>Explanatory note: some members such as IsNone and IsSome on types with UseNullAsTrueValue appear\nas instance members in F# code but are compiled as static members.</p>\n\n IsInstanceMember <p>Indicates if this is an instance member, when seen from F#?</p>\n\n IsImplicitConstructor <p>Indicates if this is an implicit constructor?</p>\n\n IsGetterMethod <p>Indicates if this is a getter method for a property, or a use of a property in getter mode</p>\n\n IsExtensionMember <p>Indicates if this is an extension member?</p>\n\n IsExplicitInterfaceImplementation <p>Indicates if this is an explicit implementation of an interface member</p>\n\n IsEventRemoveMethod <p>Indicates if this is a remove method for an event</p>\n\n IsEventAddMethod <p>Indicates if this is an add method for an event</p>\n\n IsEvent <p>Indicates if this is an event member</p>\n\n IsDispatchSlot <p>Indicates if this is an abstract member?</p>\n\n IsConstructorThisValue <p>Indicates if this is the \"x\" in \"type C() as x = ...\"</p>\n\n IsConstructor <p>Indicates if this is a constructor.</p>\n\n IsCompilerGenerated <p>Indicates if this is a compiler generated value</p>\n\n IsBaseValue <p>Indicates if this is \"base\" in \"base.M(...)\"</p>\n\n IsActivePattern <p>Indicates if this value or member is an F# active pattern</p>\n\n InlineAnnotation <p>Get a result indicating if this is a must-inline value</p>\n\n ImplementedAbstractSignatures <p>Gets the list of the abstract slot signatures implemented by the member</p>\n\n HasSetterMethod <p>Indicates if this is a property and there exists an associated setter method</p>\n\n HasGetterMethod <p>Indicates if this is a property and there exists an associated getter method</p>\n\n GetterMethod <p>Get an associated getter method of the property</p>\n\n GenericParameters <p>Get the typars of the member, function or value</p>\n\n FullType <p>Get the full type of the member, function or value when used as a first class value</p>\n\n EventRemoveMethod <p>Get an associated remove method of an event</p>\n\n EventIsStandard <p>Indicate if an event can be considered to be a property for the F# type system of type IEvent or IDelegateEvent.\nIn this case ReturnParameter will have a type corresponding to the property type.  For\nnon-standard events, ReturnParameter will have a type corresponding to the delegate type.</p>\n\n EventForFSharpProperty <p>Gets the event symbol implied by the use of a property,\nfor the case where the property is actually an F#-declared CLIEvent.</p>\n<p>Uses of F#-declared events are considered to be properties as far as the language specification\nand this API are concerned.</p>\n\n EventDelegateType <p>Get an associated delegate type of an event</p>\n\n EventAddMethod <p>Get an associated add method of an event</p>\n\n DisplayName <p>Get the name as presented in F# error messages and documentation</p>\n\n DeclaringEntity <p>Get the enclosing entity for the definition</p>\n\n DeclarationLocation <p>Get the declaration location of the member, function or value</p>\n\n CurriedParameterGroups  CompiledName <p>Get the member name in compiled code</p>\n\n Attributes <p>Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup<br />\nthese value references after copying a collection of values.</p>\n\n ApparentEnclosingEntity <p>Get the logical enclosing entity, which for an extension member is type being extended</p>\n\n Accessibility <p>Get the accessibility information for the member, function or value</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpmethodgroup.html","title":"FSharpMethodGroup","content":"FSharpMethodGroup \n <p>Represents a group of methods (or other items) returned by GetMethods.</p>\n\n \n Methods <p>The methods (or other items) in the group</p>\n\n MethodName <p>The shared name of the methods (or other items) in the group</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpmethodgroupitem.html","title":"FSharpMethodGroupItem","content":"FSharpMethodGroupItem \n <p>Represents one method (or other item) in a method group. The item may represent either a method or\na single, non-overloaded item such as union case or a named function value.</p>\n\n \n XmlDoc <p>The documentation for the item</p>\n\n StructuredReturnTypeText <p>The The structured description representation for the method (or other item)</p>\n\n StructuredDescription <p>The structured description representation for the method (or other item)</p>\n\n StaticParameters <p>Does the type name or method support a static arguments list, like TP<42,\"foo\"> or conn.CreateCommand<42, \"foo\">(arg1, arg2)?</p>\n\n ReturnTypeText <p>The formatted type text for the method (or other item)</p>\n\n Parameters <p>The parameters of the method in the overload set</p>\n\n HasParameters <p>Does the method support an arguments list?  This is always true except for static type instantiations like TP<42,\"foo\">.</p>\n\n HasParamArrayArg <p>Does the method support a params list arg?</p>\n\n Description <p>The formatted description text for the method (or other item)</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpmethodgroupitemparameter.html","title":"FSharpMethodGroupItemParameter","content":"FSharpMethodGroupItemParameter \n <p>Represents one parameter for one method (or other item) in a group.</p>\n\n \n StructuredDisplay <p>The structured representation for the parameter including its name, its type and visual indicators of other\ninformation such as whether it is optional.</p>\n\n ParameterName <p>The name of the parameter.</p>\n\n IsOptional <p>Is the parameter optional</p>\n\n Display <p>The text to display for the parameter including its name, its type and visual indicators of other\ninformation such as whether it is optional.</p>\n\n CanonicalTypeTextForSorting <p>A key that can be used for sorting the parameters, used to help sort overloads.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnavigationdeclarationitem.html","title":"FSharpNavigationDeclarationItem","content":"FSharpNavigationDeclarationItem \n <p>Represents an item to be displayed in the navigation bar</p>\n\n \n UniqueName  Range  Name  Kind  IsSingleTopLevel  IsAbstract  Glyph  EnclosingEntityKind  BodyRange  Access "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnavigationdeclarationitemkind.html","title":"FSharpNavigationDeclarationItemKind","content":"FSharpNavigationDeclarationItemKind \n <p>Indicates a kind of item to show in an F# navigation bar</p>\n\n \n NamespaceDecl  ModuleFileDecl  ExnDecl  ModuleDecl  TypeDecl  MethodDecl  PropertyDecl  FieldDecl  OtherDecl "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnavigationitems.html","title":"FSharpNavigationItems","content":"FSharpNavigationItems \n <p>Represents result of 'GetNavigationItems' operation - this contains\nall the members and currently selected indices. First level correspond to\ntypes &amp; modules and second level are methods etc.</p>\n\n \n Declarations "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnavigationtopleveldeclaration.html","title":"FSharpNavigationTopLevelDeclaration","content":"FSharpNavigationTopLevelDeclaration \n <p>Represents top-level declarations (that should be in the type drop-down)\nwith nested declarations (that can be shown in the member drop-down)</p>\n\n \n Declaration  Nested "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpnoteworthyparaminfolocations.html","title":"FSharpNoteworthyParamInfoLocations","content":"FSharpNoteworthyParamInfoLocations \n <p>Represents the locations relevant to activating parameter info in an IDE</p>\n\n \n TupleEndLocations <p>The locations of commas and close parenthesis (or, last char of last arg, if no final close parenthesis)</p>\n\n OpenParenLocation <p>The location of the open-parentheses</p>\n\n NamedParamNames <p>Either empty or a name if an actual named parameter; f(0,a=4,?b=None) would be [|None; Some \"a\"; Some \"b\"|]</p>\n\n LongIdStartLocation <p>The start location of long identifier prior to the open-parentheses</p>\n\n LongIdEndLocation <p>The end location of long identifier prior to the open-parentheses</p>\n\n LongId <p>The text of the long identifier prior to the open-parentheses</p>\n\n IsThereACloseParen <p>Is false if either this is a call without parens \"f x\" or the parser recovered as in \"f(x,y\"</p>\n\n Find <p>Find the information about parameter info locations at a particular source location</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpobjectexproverride.html","title":"FSharpObjectExprOverride","content":"FSharpObjectExprOverride \n <p>Represents a checked method in an object expression, as seen by the F# language.</p>\n\n \n Signature <p>The signature of the implemented abstract slot</p>\n\n GenericParameters <p>The generic parameters of the method</p>\n\n CurriedParameterGroups <p>The parameters of the method</p>\n\n Body <p>The expression that forms the body of the method</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpopendeclaration.html","title":"FSharpOpenDeclaration","content":"FSharpOpenDeclaration \n <p>Represents open declaration in F# code.</p>\n\n \n Range <p>Range of the open declaration.</p>\n\n Modules <p>Modules or namespaces which is opened with this declaration.</p>\n\n LongId <p>Idents.</p>\n\n IsOwnNamespace <p>If it's <code>namespace Xxx.Yyy</code> declaration.</p>\n\n AppliedScope <p>Scope in which open declaration is visible.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpparameter.html","title":"FSharpParameter","content":"FSharpParameter \n <p>A subtype of FSharpSymbol that represents a parameter</p>\n\n \n Type <p>The declared or inferred type of the parameter</p>\n\n Name <p>The optional name of the parameter</p>\n\n IsParamArrayArg <p>Indicate this is a param array argument</p>\n\n IsOutArg <p>Indicate this is an out argument</p>\n\n IsOptionalArg <p>Indicate this is an optional argument</p>\n\n IsInArg <p>Indicate this is an in argument</p>\n\n DeclarationLocation <p>The declaration location of the parameter</p>\n\n Attributes <p>The declared attributes of the parameter</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpparsefileresults.html","title":"FSharpParseFileResults","content":"FSharpParseFileResults \n <p>Represents the results of parsing an F# file</p>\n\n \n FindNoteworthyParamInfoLocations <p>Notable parse info for ParameterInfo at a given location</p>\n\n GetNavigationItems <p>Get declared items and the selected item at the specified location</p>\n\n ValidateBreakpointLocation <p>Return the inner-most range associated with a possible breakpoint location</p>\n\n ParseTree <p>The syntax tree resulting from the parse</p>\n\n ParseHadErrors <p>Indicates if any errors occurred during the parse</p>\n\n FileName <p>Name of the file for which this information were created</p>\n\n Errors <p>Get the errors and warnings for the parse</p>\n\n DependencyFiles <p>When these files change then the build is invalid</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpparsingoptions.html","title":"FSharpParsingOptions","content":"FSharpParsingOptions \n <p>Options used to determine active --define conditionals and other options relevant to parsing files in a project</p>\n\n \n Default  SourceFiles  ConditionalCompilationDefines  ErrorSeverityOptions  IsInteractive  LightSyntax  CompilingFsLib  IsExe "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpprojectcontext.html","title":"FSharpProjectContext","content":"FSharpProjectContext \n <p>Represents the checking context implied by the ProjectOptions</p>\n\n \n GetReferencedAssemblies <p>Get the resolution and full contents of the assemblies referenced by the project options</p>\n\n AccessibilityRights <p>Get the accessibility rights for this project context w.r.t. InternalsVisibleTo attributes granting access to other assemblies</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpprojectoptions.html","title":"FSharpProjectOptions","content":"FSharpProjectOptions \n <p>A set of information describing a project or script build configuration.</p>\n\n \n ProjectFileName  ProjectId <p>This is the unique identifier for the project, it is case sensitive. If it's None, will key off of ProjectFileName in our caching.</p>\n\n SourceFiles <p>The files in the project</p>\n\n OtherOptions <p>Additional command line argument options for the project. These can include additional files and references.</p>\n\n ReferencedProjects <p>The command line arguments for the other projects referenced by this project, indexed by the\nexact text used in the \"-r:\" reference in FSharpProjectOptions.</p>\n\n IsIncompleteTypeCheckEnvironment <p>When true, the typechecking environment is known a priori to be incomplete, for\nexample when a .fs file is opened outside of a project. In this case, the number of error\nmessages reported is reduced.</p>\n\n UseScriptResolutionRules <p>When true, use the reference resolution rules for scripts rather than the rules for compiler.</p>\n\n LoadTime <p>Timestamp of project/script load, used to differentiate between different instances of a project load.\nThis ensures that a complete reload of the project or script type checking\ncontext occurs on project or script unload/reload.</p>\n\n UnresolvedReferences <p>Unused in this API and should be 'None' when used as user-specified input</p>\n\n OriginalLoadReferences <p>Unused in this API and should be '[]' when used as user-specified input</p>\n\n ExtraProjectInfo <p>Extra information passed back on event trigger</p>\n\n Stamp <p>An optional stamp to uniquely identify this set of options\nIf two sets of options both have stamps, then they are considered equal\nif and only if the stamps are equal</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpsourcetokenizer.html","title":"FSharpSourceTokenizer","content":"FSharpSourceTokenizer \n <p>Tokenizer for a source file. Holds some expensive-to-compute resources at the scope of the file.</p>\n\n \n ( .ctor )  CreateBufferTokenizer  CreateLineTokenizer "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpstaticparameter.html","title":"FSharpStaticParameter","content":"FSharpStaticParameter \n <p>A subtype of FSharpSymbol that represents a static parameter to an F# type provider</p>\n\n \n Name <p>Get the name of the static parameter</p>\n\n Kind <p>Get the kind of the static parameter</p>\n\n IsOptional <p>Indicates if the static parameter is optional</p>\n\n HasDefaultValue  DefaultValue <p>Get the default value for the static parameter</p>\n\n DeclarationLocation <p>Get the declaration location of the static parameter</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpstructuredtooltipelement.html","title":"FSharpStructuredToolTipElement","content":"FSharpStructuredToolTipElement \n <p>A single data tip display element with where text is expressed as <see cref=\"Layout\"/></p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpstructuredtooltiptext.html","title":"FSharpStructuredToolTipText","content":"FSharpStructuredToolTipText \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpsymbol.html","title":"FSharpSymbol","content":"FSharpSymbol \n <p>Represents a symbol in checked F# source code or a compiled .NET component.</p>\n<p>The subtype of the symbol may reveal further information and can be one of FSharpEntity, FSharpUnionCase\nFSharpField, FSharpGenericParameter, FSharpStaticParameter, FSharpMemberOrFunctionOrValue, FSharpParameter,\nor FSharpActivePatternCase.</p>\n\n \n GetEffectivelySameAsHash <p>A hash compatible with the IsEffectivelySameAs relation</p>\n\n IsAccessible <p>Computes if the symbol is accessible for the given accessibility rights</p>\n\n IsEffectivelySameAs <p>Return true if two symbols are effectively the same when referred to in F# source code text.<br />\nThis sees through signatures (a symbol in a signature will be considered effectively the same as\nthe matching symbol in an implementation).  In addition, other equivalences are applied\nwhen the same F# source text implies the same declaration name - for example, constructors\nare considered to be effectively the same symbol as the corresponding type definition.</p>\n<p>This is the relation used by GetUsesOfSymbol and GetUsesOfSymbolInFile.</p>\n\n SignatureLocation <p>Get the signature location for the symbol if it was declared in an implementation</p>\n\n IsExplicitlySuppressed  ImplementationLocation <p>Get the implementation location for the symbol if it was declared in a signature that has an implementation</p>\n\n FullName <p>Get a textual representation of the full name of the symbol. The text returned for some symbols\nmay not be a valid identifier path in F# code, but rather a human-readable representation of the symbol.</p>\n\n DisplayName <p>Gets the short display name for the symbol</p>\n\n DeclarationLocation <p>Get the declaration location for the symbol</p>\n\n Assembly <p>Get the assembly declaring this symbol</p>\n\n GetAccessibility "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpsymboluse.html","title":"FSharpSymbolUse","content":"FSharpSymbolUse \n <p>Represents the use of an F# symbol from F# source code</p>\n\n \n Symbol <p>The symbol referenced</p>\n\n RangeAlternate <p>The range of text representing the reference to the symbol</p>\n\n IsPrivateToFile <p>Indicates if the FSharpSymbolUse is declared as private</p>\n\n IsFromType <p>Indicates if the reference is in a syntactic type</p>\n\n IsFromPattern <p>Indicates if the reference is in a pattern</p>\n\n IsFromOpenStatement <p>Indicates if the reference is in open statement</p>\n\n IsFromDispatchSlotImplementation <p>Indicates if the reference is via the member being implemented in a class or object expression</p>\n\n IsFromDefinition <p>Indicates if the reference is a definition for the symbol, either in a signature or implementation</p>\n\n IsFromComputationExpression <p>Indicates if the reference is either a builder or a custom operation in a computation expression</p>\n\n IsFromAttribute <p>Indicates if the reference is in an attribute</p>\n\n FileName <p>The file name the reference occurs in</p>\n\n DisplayContext <p>The display context active at the point where the symbol is used. Can be passed to FSharpType.Format\nand other methods to format items in a way that is suitable for a specific source code location.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokencharkind.html","title":"FSharpTokenCharKind","content":"FSharpTokenCharKind \n <p>Gives an indication of the class to assign to the characters of the token an IDE</p>\n\n \n Default  Text  Keyword  Identifier  String  Literal  Operator  Delimiter  WhiteSpace  LineComment  Comment "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokencolorkind.html","title":"FSharpTokenColorKind","content":"FSharpTokenColorKind \n <p>Gives an indication of the color class to assign to the token an IDE</p>\n\n \n Default  Text  Keyword  Comment  Identifier  String  UpperIdentifier  InactiveCode  PreprocessorKeyword  Number  Operator  Punctuation "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokeninfo.html","title":"FSharpTokenInfo","content":"FSharpTokenInfo \n <p>Information about a particular token from the tokenizer</p>\n\n \n LeftColumn <p>Left column of the token.</p>\n\n RightColumn <p>Right column of the token.</p>\n\n ColorClass  CharClass <p>Gives an indication of the class to assign to the token an IDE</p>\n\n FSharpTokenTriggerClass <p>Actions taken when the token is typed</p>\n\n Tag <p>The tag is an integer identifier for the token</p>\n\n TokenName <p>Provides additional information about the token</p>\n\n FullMatchedLength <p>The full length consumed by this match, including delayed tokens (which can be ignored in naive lexers)</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokentriggerclass.html","title":"FSharpTokenTriggerClass","content":"FSharpTokenTriggerClass \n <p>Gives an indication of what should happen when the token is typed in an IDE</p>\n\n \n None  MemberSelect  MatchBraces  ChoiceSelect  MethodTip  ParamStart  ParamNext  ParamEnd "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokenizercolorstate.html","title":"FSharpTokenizerColorState","content":"FSharpTokenizerColorState \n <p>Represents stable information for the state of the lexing engine at the end of a line</p>\n\n \n Token  IfDefSkip  String  Comment  StringInComment  VerbatimStringInComment  CamlOnly  VerbatimString  SingleLineComment  EndLineThenSkip  EndLineThenToken  TripleQuoteString  TripleQuoteStringInComment  InitialState "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptokenizerlexstate.html","title":"FSharpTokenizerLexState","content":"FSharpTokenizerLexState \n <p>Represents encoded information for the end-of-line continuation of lexing</p>\n\n \n Equals  Initial  PosBits  OtherBits "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptooltipelement-1.html","title":"FSharpToolTipElement<'T>","content":"FSharpToolTipElement<'T> \n <p>A single tool tip display element</p>\n\n \n Single  None  Group <p>A single type, method, etc with comment. May represent a method overload group.</p>\n\n CompositionError <p>An error occurred formatting this element</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptooltipelement.html","title":"FSharpToolTipElement","content":"FSharpToolTipElement \n <p>A single data tip display element with where text is expressed as string</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptooltipelementdata-1.html","title":"FSharpToolTipElementData<'T>","content":"FSharpToolTipElementData<'T> \n <p>A single data tip display element</p>\n\n \n MainDescription  XmlDoc  TypeMapping <p>typar instantiation text, to go after xml</p>\n\n Remarks <p>Extra text, goes at the end</p>\n\n ParamName <p>Parameter name</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptooltiptext-1.html","title":"FSharpToolTipText<'T>","content":"FSharpToolTipText<'T> \n <p>Information for building a tool tip box.</p>\n\n \n FSharpToolTipText <p>A list of data tip elements to display.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptooltiptext.html","title":"FSharpToolTipText","content":"FSharpToolTipText \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharptype.html","title":"FSharpType","content":"FSharpType \n  \n Format <p>Format the type using the rules of the given display context</p>\n\n FormatLayout <p>Format the type using the rules of the given display context</p>\n\n Instantiate <p>Instantiate generic type parameters in a type</p>\n\n TypeDefinition <p>Get the type definition for a type</p>\n\n NamedEntity  IsUnresolved <p>Indicates this is a named type in an unresolved assembly</p>\n\n IsTupleType <p>Indicates if the type is a tuple type (reference or struct). The GenericArguments property returns the elements of the tuple type.</p>\n\n IsStructTupleType <p>Indicates if the type is a struct tuple type. The GenericArguments property returns the elements of the tuple type.</p>\n\n IsNamedType  IsGenericParameter <p>Indicates if the type is a variable type, whether declared, generalized or an inference type parameter</p>\n\n IsFunctionType <p>Indicates if the type is a function type. The GenericArguments property returns the domain and range of the function type.</p>\n\n IsAnonRecordType <p>Indicates if the type is an anonymous record type. The GenericArguments property returns the type instantiation of the anonymous record type</p>\n\n IsAbbreviation <p>Indicates this is an abbreviation for another type</p>\n\n HasTypeDefinition <p>Indicates if the type is constructed using a named entity, including array and byref types</p>\n\n GenericParameter <p>Get the generic parameter data for a generic parameter type</p>\n\n GenericArguments <p>Get the generic arguments for a tuple type, a function type or a type constructed using a named entity</p>\n\n BaseType <p>Get the base type, if any, taking into account the instantiation of this type\nif it is an instantiation of a generic type.</p>\n\n AnonRecordTypeDetails <p>Get the details of the anonymous record type.</p>\n\n AllInterfaces <p>Get all the interface implementations, by walking the type hierarchy, taking into account the instantiation of this type\nif it is an instantiation of a generic type.</p>\n\n AbbreviatedType <p>Get the type for which this is an abbreviation</p>\n\n Prettify <p>Adjust the types in a group of curried parameters and return type by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n Prettify <p>Adjust the types in a group of curried parameters by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n Prettify <p>Adjust the types in a group of parameters by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n Prettify <p>Adjust the type in a single parameter by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n Prettify <p>Adjust a group of types by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n Prettify <p>Adjust the type by removing any occurrences of type inference variables, replacing them\nsystematically with lower-case type inference variables such as <c>'a</c>.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpunioncase.html","title":"FSharpUnionCase","content":"FSharpUnionCase \n <p>A subtype of FSharpSymbol that represents a union case as seen by the F# language</p>\n\n \n XmlDocSig <p>Get the XML documentation signature for .xml file lookup for the union case, used for .xml file lookup for compiled code</p>\n\n XmlDoc <p>Get the in-memory XML documentation for the union case, used when code is checked in-memory</p>\n\n UnionCaseFields <p>Get the data carried by the case.</p>\n\n ReturnType <p>Get the type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it</p>\n\n Name <p>Get the name of the union case</p>\n\n IsUnresolved <p>Indicates if the union case is for a type in an unresolved assembly</p>\n\n HasFields <p>Indicates if the union case has field definitions</p>\n\n DeclarationLocation <p>Get the range of the name of the case</p>\n\n CompiledName <p>Get the name of the case in generated IL code</p>\n\n Attributes <p>Get the attributes for the case, attached to the generated static method to make instances of the case</p>\n\n Accessibility <p>Indicates if the declared visibility of the union constructor, not taking signatures into account</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-fsharpxmldoc.html","title":"FSharpXmlDoc","content":"FSharpXmlDoc \n <p>Describe a comment as either a block of text or a file+signature reference into an intellidoc file.</p>\n\n \n None <p>No documentation is available</p>\n\n Text <p>The text for documentation</p>\n\n XmlDocFileSignature <p>Indicates that the text for the documentation can be found in a .xml documentation file, using the given signature key</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-iassemblycontentcache.html","title":"IAssemblyContentCache","content":"IAssemblyContentCache \n <p>Assembly content cache.</p>\n\n \n Set <p>Store an assembly content.</p>\n\n TryGet <p>Try get an assembly cached content.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-idents.html","title":"Idents","content":"Idents \n <p>An array of <a href=\"fsharp-compiler-sourcecodeservices-shortident.html\" title=\"ShortIdent\"><code>ShortIdent</code></a>.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-inheritancecontext.html","title":"InheritanceContext","content":"InheritanceContext \n  \n Class  Interface  Unknown "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-insertcontext.html","title":"InsertContext","content":"InsertContext \n <p>Insert open namespace context.</p>\n\n \n ScopeKind <p>Current scope kind.</p>\n\n Pos <p>Current position (F# compiler line number).</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-interfacedata.html","title":"InterfaceData","content":"InterfaceData \n <p>Capture information about an interface in ASTs</p>\n\n \n TypeParameters  Range  Interface  ObjExpr "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-layout.html","title":"Layout","content":"Layout \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lookuptype.html","title":"LookupType","content":"LookupType \n <p>Entity lookup type.</p>\n\n \n Fuzzy  Precise "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-maybeunresolvedident.html","title":"MaybeUnresolvedIdent","content":"MaybeUnresolvedIdent \n <p><a href=\"fsharp-compiler-sourcecodeservices-shortident.html\" title=\"ShortIdent\"><code>ShortIdent</code></a> with a flag indicating if it's resolved in some scope.</p>\n\n \n Ident  Resolved "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-maybeunresolvedidents.html","title":"MaybeUnresolvedIdents","content":"MaybeUnresolvedIdents \n <p>Array of <a href=\"fsharp-compiler-sourcecodeservices-maybeunresolvedident.html\" title=\"MaybeUnresolvedIdent\"><code>MaybeUnresolvedIdent</code></a>.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-modulekind.html","title":"ModuleKind","content":"ModuleKind \n  \n IsAutoOpen  HasModuleSuffix "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-openstatementinsertionpoint.html","title":"OpenStatementInsertionPoint","content":"OpenStatementInsertionPoint \n <p>Where open statements should be added.</p>\n\n \n TopLevel  Nearest "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-paramtypesymbol.html","title":"ParamTypeSymbol","content":"ParamTypeSymbol \n <p>Represents the type of a single method parameter</p>\n\n \n Param  Byref "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-position.html","title":"Position","content":"Position \n  \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-range.html","title":"Range","content":"Range \n  \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-recordcontext.html","title":"RecordContext","content":"RecordContext \n  \n CopyOnUpdate  Constructor  New "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-scopekind.html","title":"ScopeKind","content":"ScopeKind \n <p>Kind of lexical scope.</p>\n\n \n Namespace  TopModule  NestedModule  OpenDeclaration  HashDirective "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-semanticclassificationtype.html","title":"SemanticClassificationType","content":"SemanticClassificationType \n <p>A kind that determines what range in a source's text is semantically classified as after type-checking.</p>\n\n \n ReferenceType  ValueType  UnionCase  Function  Property  MutableVar  Module  Printf  ComputationExpression  IntrinsicFunction  Enumeration  Interface  TypeArgument  Operator  Disposable "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-shortident.html","title":"ShortIdent","content":"ShortIdent \n <p>Short identifier, i.e. an identifier that contains no dots.</p>\n\n \n Chars  Length "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-stringlongident.html","title":"StringLongIdent","content":"StringLongIdent \n <p>Long identifier (i.e. it may contain dots).</p>\n\n \n Chars  Length "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-unresolvedreferencesset.html","title":"UnresolvedReferencesSet","content":"UnresolvedReferencesSet \n <p>Unused in this API</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-unresolvedsymbol.html","title":"UnresolvedSymbol","content":"UnresolvedSymbol \n  \n FullName  DisplayName  Namespace "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-xmldocable.html","title":"XmlDocable","content":"XmlDocable \n <p>Represent an Xml documentation block in source code</p>\n\n \n XmlDocable "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-text-isourcetext.html","title":"ISourceText","content":"ISourceText \n  \n ContentEquals  CopyTo  GetLastCharacterPosition  GetLineCount  GetLineString  GetSubTextString  SubTextEquals  Length  Item "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-pathmap.html","title":"PathMap","content":"PathMap \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-formatoptions.html","title":"FormatOptions","content":"FormatOptions \n <p>A record of options to control structural formatting.\nFor F# Interactive properties matching those of this value can be accessed via the 'fsi'\nvalue.</p>\n<p>Floating Point format given in the same format accepted by System.Double.ToString,\ne.g. f6 or g15.</p>\n<p>If ShowProperties is set the printing process will evaluate properties of the values being\ndisplayed.  This may cause additional computation.</p>\n<p>The ShowIEnumerable is set the printing process will force the evaluation of IEnumerable objects\nto a small, finite depth, as determined by the printing parameters.\nThis may lead to additional computation being performed during printing.</p>\n<example>\nFrom F# Interactive the default settings can be adjusted using, for example, \n<pre>\n  open FSharp.Compiler.Interactive.Settings;;\n  setPrintWidth 120;;\n</pre>\n</example>\n\n \n Default  FloatingPointFormat  AttributeProcessor  PrintIntercepts  StringLimit  FormatProvider  BindingFlags  PrintWidth  PrintDepth  PrintLength  PrintSize  ShowProperties  ShowIEnumerable "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-ienvironment.html","title":"IEnvironment","content":"IEnvironment \n  \n GetLayout <p>Return to the layout-generation\nenvironment to layout any otherwise uninterpreted object</p>\n\n MaxRows <p>The maximum number of rows for which to generate layout for table-like\nstructures.  -1 if no maximum.</p>\n\n MaxColumns <p>The maximum number of elements for which to generate layout for\nlist-like structures, or columns in table-like\nstructures.  -1 if no maximum.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-joint.html","title":"Joint","content":"Joint \n <p>Data representing joints in structured layouts of terms.  The representation\nof this data type is only for the consumption of formatting engines.</p>\n\n \n Unbreakable  Breakable  Broken "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-layout.html","title":"Layout","content":"Layout \n <p>Data representing structured layouts of terms.  The representation\nof this data type is only for the consumption of formatting engines.</p>\n\n \n ObjLeaf  Leaf  Node  Attr "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-layouttag.html","title":"LayoutTag","content":"LayoutTag \n  \n ActivePatternCase  ActivePatternResult  Alias  Class  Union  UnionCase  Delegate  Enum  Event  Field  Interface  Keyword  LineBreak  Local  Record  RecordField  Method  Member  ModuleBinding  Module  Namespace  NumericLiteral  Operator  Parameter  Property  Space  StringLiteral  Struct  TypeParameter  Text  Punctuation  UnknownType  UnknownEntity "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-taggedtext.html","title":"TaggedText","content":"TaggedText \n  \n Text  Tag "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/internal-utilities-structuredformat-taggedtextwriter.html","title":"TaggedTextWriter","content":"TaggedTextWriter \n  \n Write  WriteLine "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-assemblyresolutionprobe.html","title":"AssemblyResolutionProbe","content":"AssemblyResolutionProbe \n <p>Signature for ResolutionProbe callback\nhost implements this, it's job is to return a list of assembly paths to probe.</p>\n\n \n Invoke "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-assemblyresolvehandler.html","title":"AssemblyResolveHandler","content":"AssemblyResolveHandler \n <p>Handle Assembly resolution</p>\n\n \n ( .ctor ) <p>Construct a new DependencyProvider</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-dependencyprovider.html","title":"DependencyProvider","content":"DependencyProvider \n <p>Provides DependencyManagement functions.\nClass is IDisposable</p>\n\n \n ( .ctor ) <p>Construct a new DependencyProvider</p>\n\n ( .ctor ) <p>Construct a new DependencyProvider</p>\n\n CreatePackageManagerUnknownError <p>Returns a formatted error message for the host to present</p>\n\n RemoveDependencyManagerKey <p>Remove the dependency mager with the specified key</p>\n\n Resolve <p>Resolve reference for a list of package manager lines</p>\n\n TryFindDependencyManagerByKey <p>Fetch a dependencymanager that supports a specific key</p>\n\n TryFindDependencyManagerInPath <p>TryFindDependencyManagerInPath - given a #r \"key:sometext\" go and find a DependencyManager that satisfies the key</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-errorreporttype.html","title":"ErrorReportType","content":"ErrorReportType \n <p>Todo describe this API</p>\n\n \n Warning  Error "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-idependencymanagerprovider.html","title":"IDependencyManagerProvider","content":"IDependencyManagerProvider \n <p>Wraps access to a DependencyManager implementation</p>\n\n \n ResolveDependencies <p>Resolve the dependencies, for the given set of arguments, go find the .dll references, scripts and additional include values.</p>\n\n Name <p>Name of the dependency manager</p>\n\n Key <p>Key that identifies the types of dependencies that this DependencyManager operates on\nE.g\nnuget: indicates that this DM is for nuget packages\npaket: indicates that this DM is for paket scripts, which manage nuget packages, github source dependencies etc ...</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-iresolvedependenciesresult.html","title":"IResolveDependenciesResult","content":"IResolveDependenciesResult \n <p>The results of ResolveDependencies</p>\n\n \n Success <p>Succeded?</p>\n\n StdOut <p>The resolution output log</p>\n\n StdError <p>The resolution error log (process stderr)</p>\n\n SourceFiles <p>The source code file paths</p>\n\n Roots <p>The roots to package directories</p>\n\n Resolutions <p>The resolution paths</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-nativedllresolvehandler.html","title":"NativeDllResolveHandler","content":"NativeDllResolveHandler \n  \n ( .ctor ) <p>Construct a new DependencyProvider</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-nativeresolutionprobe.html","title":"NativeResolutionProbe","content":"NativeResolutionProbe \n <p>Signature for Native library resolution probe callback\nhost implements this, it's job is to return a list of package roots to probe.</p>\n\n \n Invoke "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/microsoft-dotnet-dependencymanager-resolvingerrorreport.html","title":"ResolvingErrorReport","content":"ResolvingErrorReport \n  \n Invoke "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-compilerglobalstate-nicenamegenerator.html","title":"NiceNameGenerator","content":"NiceNameGenerator \n <p>Generates compiler-generated names. Each name generated also includes the StartLine number of the range passed in\nat the point of first generation.</p>\n<p>This type may be accessed concurrently, though in practice it is only used from the compilation thread.\nIt is made concurrency-safe since a global instance of the type is allocated in tast.fs, and it is good\npolicy to make all globally-allocated objects concurrency safe in case future versions of the compiler\nare used to host multiple concurrent instances of compilation.</p>\n\n \n ( .ctor )  FreshCompilerGeneratedName  Reset "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-compilerglobalstate-stablenicenamegenerator.html","title":"StableNiceNameGenerator","content":"StableNiceNameGenerator \n <p>Generates compiler-generated names marked up with a source code location, but if given the same unique value then\nreturn precisely the same name. Each name generated also includes the StartLine number of the range passed in\nat the point of first generation.</p>\n<p>This type may be accessed concurrently, though in practice it is only used from the compilation thread.\nIt is made concurrency-safe since a global instance of the type is allocated in tast.fs.</p>\n\n \n ( .ctor )  GetUniqueCompilerGeneratedName  Reset "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-compilerglobalstate-unique.html","title":"Unique","content":"Unique \n <p>Unique name generator for stamps attached to lambdas and object expressions</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-buildphase.html","title":"BuildPhase","content":"BuildPhase \n <p>Closed enumeration of build phases.</p>\n\n \n DefaultPhase  Compile  Parameter  Parse  TypeCheck  CodeGen  Optimize  IlxGen  IlGen  Output  Interactive "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-capturingerrorlogger.html","title":"CapturingErrorLogger","content":"CapturingErrorLogger \n  \n ( .ctor )  CommitDelayedDiagnostics  Diagnostics "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-deprecated.html","title":"Deprecated","content":"Deprecated \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-error.html","title":"Error","content":"Error \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-errorlogger.html","title":"ErrorLogger","content":"ErrorLogger \n  \n ( .ctor )  DebugDisplay  DiagnosticSink  ErrorCount "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-errorstyle.html","title":"ErrorStyle","content":"ErrorStyle \n <p>Represents the style being used to format errors</p>\n\n \n DefaultErrors  EmacsErrors  TestErrors  VSErrors  GccErrors "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-errorwithsuggestions.html","title":"ErrorWithSuggestions","content":"ErrorWithSuggestions \n  \n Data0  Data1  Data2  Data3 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-exiter.html","title":"Exiter","content":"Exiter \n  \n Exit "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-experimental.html","title":"Experimental","content":"Experimental \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-fsharperrorseverityoptions.html","title":"FSharpErrorSeverityOptions","content":"FSharpErrorSeverityOptions \n  \n Default  WarnLevel  GlobalWarnAsError  WarnOff  WarnOn  WarnAsError  WarnAsWarn "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-imperativeoperationresult.html","title":"ImperativeOperationResult","content":"ImperativeOperationResult \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-internalerror.html","title":"InternalError","content":"InternalError \n  \n msg  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-libraryuseonly.html","title":"LibraryUseOnly","content":"LibraryUseOnly \n  \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-numberederror.html","title":"NumberedError","content":"NumberedError \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-operationresult-1.html","title":"OperationResult<'T>","content":"OperationResult<'T> \n  \n OkResult  ErrorResult "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-phaseddiagnostic.html","title":"PhasedDiagnostic","content":"PhasedDiagnostic \n  \n DebugDisplay  IsPhaseInCompile <p>the language service knows about.</p>\n\n Subcategory <p>This is the textual subcategory to display in error and warning messages (shows only under --vserrors):</p>\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\">1: </span>\n</pre></td>\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"id\">file1</span><span class=\"pn\">.</span><span class=\"id\">fs</span><span class=\"pn\">(</span><span class=\"n\">72</span><span class=\"pn\">)</span><span class=\"pn\">:</span> <span class=\"id\">subcategory</span> <span class=\"id\">warning</span> <span class=\"id\">FS0072</span><span class=\"pn\">:</span> <span class=\"id\">This</span> <span class=\"id\">is</span> <span class=\"id\">a</span> <span class=\"id\">warning</span> <span class=\"id\">message</span>\n</code></pre></td>\n</tr>\n</table>\n\n Create <p>Construct a phased error</p>\n\n IsSubcategoryOfCompile <p>Return true if the textual phase given is from the compile part of the build process.\nThis set needs to be equal to the set of subcategories that the language service can produce.</p>\n\n Exception  Phase "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-possibleunverifiablecode.html","title":"PossibleUnverifiableCode","content":"PossibleUnverifiableCode \n  \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-reportederror.html","title":"ReportedError","content":"ReportedError \n <p>Thrown when immediate, local error recovery is not possible. This indicates\nwe've reported an error but need to make a non-local transfer of control.\nError recovery may catch this and continue (see 'errorRecovery')</p>\n<p>The exception that caused the report is carried as data because in some\nsituations (LazyWithContext) we may need to re-report the original error\nwhen a lazy thunk is re-evaluated.</p>\n\n \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-stopprocessingexn.html","title":"StopProcessingExn","content":"StopProcessingExn \n <p>Thrown when we stop processing the F# Interactive entry or #load.</p>\n\n \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-suggestions.html","title":"Suggestions","content":"Suggestions \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-trackerrorsbuilder.html","title":"TrackErrorsBuilder","content":"TrackErrorsBuilder \n  \n ( .ctor )  Bind  Combine  Delay  For  Return  ReturnFrom  Run  While  Zero "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-unresolvedpathreference.html","title":"UnresolvedPathReference","content":"UnresolvedPathReference \n  \n Data0  Data1  Data2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-unresolvedpathreferencenorange.html","title":"UnresolvedPathReferenceNoRange","content":"UnresolvedPathReferenceNoRange \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-unresolvedreferenceerror.html","title":"UnresolvedReferenceError","content":"UnresolvedReferenceError \n  \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-unresolvedreferencenorange.html","title":"UnresolvedReferenceNoRange","content":"UnresolvedReferenceNoRange \n  \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-usercompilermessage.html","title":"UserCompilerMessage","content":"UserCompilerMessage \n  \n Data0  Data1  Data2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-errorlogger-wrappederror.html","title":"WrappedError","content":"WrappedError \n <p>Thrown when we want to add some range information to a .NET exception</p>\n\n \n Data0  Data1 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-layoutrenderer-2.html","title":"LayoutRenderer<'a, 'b>","content":"LayoutRenderer<'a, 'b> \n <p>Render a Layout yielding an 'a using a 'b (hidden state) type</p>\n\n \n AddBreak  AddTag  AddText  Finish  Start "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-layouttag.html","title":"LayoutTag","content":"LayoutTag \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-navigabletaggedtext.html","title":"NavigableTaggedText","content":"NavigableTaggedText \n  \n ( .ctor )  Range "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-noresult.html","title":"NoResult","content":"NoResult \n  \n NoResult "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-nostate.html","title":"NoState","content":"NoState \n  \n NoState "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-taggedtext.html","title":"TaggedText","content":"TaggedText \n  \n Text  Tag "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-layout-layout.html","title":"layout","content":"layout \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexcont.html","title":"LexCont","content":"LexCont \n  \n LexerIfdefStack "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerendlinecontinuation.html","title":"LexerEndlineContinuation","content":"LexerEndlineContinuation \n <p>Specifies how the 'endline' function in the lexer should continue after\nit reaches end of line or eof. The options are to continue with 'token' function\nor to continue with 'skip' function.</p>\n\n \n LexerIfdefStack  Token  Skip "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerifdefexpression.html","title":"LexerIfdefExpression","content":"LexerIfdefExpression \n  \n IfdefAnd  IfdefOr  IfdefNot  IfdefId "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerifdefstack.html","title":"LexerIfdefStack","content":"LexerIfdefStack \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerifdefstackentries.html","title":"LexerIfdefStackEntries","content":"LexerIfdefStackEntries \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerifdefstackentry.html","title":"LexerIfdefStackEntry","content":"LexerIfdefStackEntry \n  \n IfDefIf  IfDefElse "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-lexerwhitespacecontinuation.html","title":"LexerWhitespaceContinuation","content":"LexerWhitespaceContinuation \n <p>The parser defines a number of tokens for whitespace and\ncomments eliminated by the lexer.  These carry a specification of\na continuation for the lexer for continued processing after we've dealt with\nthe whitespace.</p>\n\n \n LexerIfdefStack  Token  IfDefSkip  String  VerbatimString  TripleQuoteString  Comment  SingleLineComment  StringInComment  VerbatimStringInComment  TripleQuoteStringInComment  MLOnly  EndLine "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-parsehelpers-syntaxerror.html","title":"SyntaxError","content":"SyntaxError \n <p>The error raised by the parse<em>error</em>rich function, which is called by the parser engine\nwhen a syntax error occurs. The first object is the ParseErrorContext which contains a dump of\ninformation about the grammar at the point where the error occurred, e.g. what tokens\nare valid to shift next at that point in the grammar. This information is processed in CompileOps.fs.</p>\n\n \n Data0  range "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming-activepatterninfo.html","title":"ActivePatternInfo","content":"ActivePatternInfo \n  \n Range  IsTotal  ActiveTagsWithRanges  ActiveTags  APInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming-invalidmangledstaticarg.html","title":"InvalidMangledStaticArg","content":"InvalidMangledStaticArg \n  \n Data0 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-prettynaming-namearitypair.html","title":"NameArityPair","content":"NameArityPair \n  \n NameArityPair "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-fileindex.html","title":"FileIndex","content":"FileIndex \n <p>An index into a global tables of filenames</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-line0.html","title":"Line0","content":"Line0 \n <p>Represents a line number when using zero-based line counting (used by Visual Studio)</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-pos01.html","title":"Pos01","content":"Pos01 \n <p>Represents a position using zero-based line counting (used by Visual Studio)</p>\n\n \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-range01.html","title":"Range01","content":"Range01 \n <p>Represents a range using zero-based line counting (used by Visual Studio)</p>\n\n \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-pos.html","title":"pos","content":"pos \n <p>Represents a position in a file</p>\n\n \n Line <p>The line number for the position</p>\n\n Encoding <p>The encoding of the position as a 64-bit integer</p>\n\n Column <p>The column number for the position</p>\n\n Decode <p>Decode a position fro a 64-bit integer</p>\n\n EncodingSize <p>The maximum number of bits needed to store an encoded position</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-range-range.html","title":"range","content":"range \n <p>Represents a range within a known file</p>\n\n \n MakeSynthetic <p>Convert a range to be synthetic</p>\n\n ToShortString <p>Convert a range to string</p>\n\n StartRange <p>The empty range that is located at the start position of the range</p>\n\n StartLine <p>The start line of the range</p>\n\n StartColumn <p>The start column of the range</p>\n\n Start <p>The start position of the range</p>\n\n IsSynthetic <p>Synthetic marks ranges which are produced by intermediate compilation phases. This\nbit signifies that the range covers something that should not be visible to language\nservice operations like dot-completion.</p>\n\n FileName <p>The file name for the file of the range</p>\n\n FileIndex <p>The file index for the range</p>\n\n EndRange <p>The empty range that is located at the end position of the range</p>\n\n EndLine <p>The line number for the end position of the range</p>\n\n EndColumn <p>The column number for the end position of the range</p>\n\n End <p>The end position of the range</p>\n\n Zero <p>The range where all values are zero</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-referenceresolver-resolutionenvironment.html","title":"ResolutionEnvironment","content":"ResolutionEnvironment \n  \n EditingOrCompilation <p>Indicates a script or source being edited or compiled. Uses reference assemblies (not implementation assemblies).</p>\n\n CompilationAndEvaluation <p>Indicates a script or source being dynamically compiled and executed. Uses implementation assemblies.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-referenceresolver-resolvedfile.html","title":"ResolvedFile","content":"ResolvedFile \n  \n itemSpec <p>Item specification.</p>\n\n prepareToolTip <p>Prepare textual information about where the assembly was resolved from, used for tooltip output</p>\n\n baggage <p>Round-tripped baggage</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-referenceresolver-resolver.html","title":"Resolver","content":"Resolver \n  \n HighestInstalledNetFrameworkVersion <p>Get the \"v4.5.1\"-style moniker for the highest installed .NET Framework version.\nThis is the value passed back to Resolve if no explicit \"mscorlib\" has been given.</p>\n<p>Note: If an explicit \"mscorlib\" is given, then --noframework is being used, and the whole ReferenceResolver logic is essentially\nunused.  However in the future an option may be added to allow an explicit specification of\na .NET Framework version to use for scripts.</p>\n\n Resolve <p>Perform assembly resolution on the given references under the given conditions</p>\n\n DotNetFrameworkReferenceAssembliesRootDirectory <p>Get the Reference Assemblies directory for the .NET Framework (on Windows)\nThis is added to the default resolution path for\ndesign-time compilations.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-blockseparator.html","title":"BlockSeparator","content":"BlockSeparator \n <p>Represents the location of the separator block + optional position\nof the semicolon (used for tooling support)</p>\n\n \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointatfinally.html","title":"DebugPointAtFinally","content":"DebugPointAtFinally \n <p>Represents whether a debug point should be present for the 'finally' in a 'try .. finally',\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointatfor.html","title":"DebugPointAtFor","content":"DebugPointAtFor \n <p>Represents whether a debug point should be present for the 'for' in a 'for...' loop,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointatsequential.html","title":"DebugPointAtSequential","content":"DebugPointAtSequential \n <p>Represents whether a debug point should be present for either the\nfirst or second part of a sequential execution, that is whether the\nconstruct corresponds to a debug point in the original source.</p>\n\n \n Both  StmtOnly  ExprOnly "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointattry.html","title":"DebugPointAtTry","content":"DebugPointAtTry \n <p>Represents whether a debug point should be present for a 'try', that is whether\nthe construct corresponds to a debug point in the original source.</p>\n\n \n Yes  Body  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointatwhile.html","title":"DebugPointAtWhile","content":"DebugPointAtWhile \n <p>Represents whether a debug point should be present for the 'while' in a 'while...' loop,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointatwith.html","title":"DebugPointAtWith","content":"DebugPointAtWith \n <p>Represents whether a debug point should be present for the 'with' in a 'try .. with',\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointforbinding.html","title":"DebugPointForBinding","content":"DebugPointForBinding \n <p>Represents whether a debug point should be present for a 'let' binding,\nthat is whether the construct corresponds to a debug point in the original source.</p>\n\n \n Combine  DebugPointAtBinding  NoDebugPointAtDoBinding  NoDebugPointAtLetBinding  NoDebugPointAtStickyBinding  NoDebugPointAtInvisibleBinding "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-debugpointfortarget.html","title":"DebugPointForTarget","content":"DebugPointForTarget \n <p>Represents whether a debug point should be present for the target\nof a decision tree, that is whether the construct corresponds to a debug\npoint in the original source.</p>\n\n \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-expratomicflag.html","title":"ExprAtomicFlag","content":"ExprAtomicFlag \n <p>Indicates if an expression is an atomic expression.</p>\n<p>An atomic expression has no whitespace unless enclosed in parentheses, e.g.\n1, \"3\", ident, ident.[expr] and (expr). If an atomic expression has type T,\nthen the largest expression ending at the same range as the atomic expression\nalso has type T.</p>\n\n \n Atomic  NonAtomic "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-ident.html","title":"Ident","content":"Ident \n <p>Represents an identifier in F# code</p>\n\n \n ( .ctor )  idText  idRange "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-longident.html","title":"LongIdent","content":"LongIdent \n <p>Represents a long identifier e.g. 'A.B.C'</p>\n\n \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-longidentwithdots.html","title":"LongIdentWithDots","content":"LongIdentWithDots \n <p>Represents a long identifier with possible '.' at end.</p>\n<p>Typically dotms.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. \"Foo.Bar.\"\nThe dots mostly matter for parsing, and are typically ignored by the typechecker, but\nif dotms.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed\nmore freedom about typechecking these expressions.\nLongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)</p>\n\n \n ThereIsAnExtraDotAtTheEnd <p>Indicates if the construct ends in '.' due to error recovery</p>\n\n RangeSansAnyExtraDot <p>Gets the syntax range for part of this construct</p>\n\n Range <p>Gets the syntax range of this construct</p>\n\n Lid <p>Get the long ident for this construct</p>\n\n LongIdentWithDots "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-memberflags.html","title":"MemberFlags","content":"MemberFlags \n <p>Represents the flags for a 'member' declaration</p>\n\n \n IsInstance <p>The member is an instance member (non-static)</p>\n\n IsDispatchSlot <p>The member is a dispatch slot</p>\n\n IsOverrideOrExplicitImpl <p>The member is an 'override' or explicit interface implementation</p>\n\n IsFinal <p>The member is 'final'</p>\n\n MemberKind <p>The kind of the member</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-memberkind.html","title":"MemberKind","content":"MemberKind \n <p>Note the member kind is actually computed partially by a syntax tree transformation in tc.fs</p>\n\n \n ClassConstructor <p>The member is a class initializer</p>\n\n Constructor <p>The member is a object model constructor</p>\n\n Member <p>The member kind is not yet determined</p>\n\n PropertyGet <p>The member kind is property getter</p>\n\n PropertySet <p>The member kind is property setter</p>\n\n PropertyGetSet <p>An artificial member kind used prior to the point where a\nget/set property is split into two distinct members.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedfsiinteraction.html","title":"ParsedFsiInteraction","content":"ParsedFsiInteraction \n <p>Represents a parsed syntax tree for an F# Interactive interaction</p>\n\n \n IDefns  IHash "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedhashdirective.html","title":"ParsedHashDirective","content":"ParsedHashDirective \n <p>Represents a parsed hash directive</p>\n\n \n ParsedHashDirective "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedimplfile.html","title":"ParsedImplFile","content":"ParsedImplFile \n <p>Represents a parsed implementation file made up of fragments</p>\n\n \n ParsedImplFile "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedimplfilefragment.html","title":"ParsedImplFileFragment","content":"ParsedImplFileFragment \n <p>Represents the syntax tree for the contents of a parsed implementation file</p>\n\n \n AnonModule <p>An implementation file which is an anonymous module definition, e.g. a script</p>\n\n NamedModule <p>An implementation file is a named module definition, 'module N'</p>\n\n NamespaceFragment <p>An implementation file fragment which declares a namespace fragment</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedimplfileinput.html","title":"ParsedImplFileInput","content":"ParsedImplFileInput \n <p>Represents the full syntax tree, file name and other parsing information for an implementation file</p>\n\n \n ParsedImplFileInput "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedinput.html","title":"ParsedInput","content":"ParsedInput \n <p>Represents the syntax tree for a parsed implementation or signature file</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ImplFile <p>A parsed implementation file</p>\n\n SigFile <p>A parsed signature file</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedsigfile.html","title":"ParsedSigFile","content":"ParsedSigFile \n <p>Represents a parsed signature file made up of fragments</p>\n\n \n ParsedSigFile "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedsigfilefragment.html","title":"ParsedSigFileFragment","content":"ParsedSigFileFragment \n <p>Represents the syntax tree for the contents of a parsed signature file</p>\n\n \n AnonModule <p>A signature file which is an anonymous module, e.g. the signature file for the final file in an application</p>\n\n NamedModule <p>A signature file which is a module, 'module N'</p>\n\n NamespaceFragment <p>A signature file namespace fragment</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parsedsigfileinput.html","title":"ParsedSigFileInput","content":"ParsedSigFileInput \n <p>Represents the full syntax tree, file name and other parsing information for a signature file</p>\n\n \n ParsedSigFileInput "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-parserdetail.html","title":"ParserDetail","content":"ParserDetail \n <p>Indicates if the construct arises from error recovery</p>\n\n \n Ok <p>The construct arises normally</p>\n\n ErrorRecovery <p>The construct arises from error recovery</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-qualifiednameoffile.html","title":"QualifiedNameOfFile","content":"QualifiedNameOfFile \n <p>Represents a qualifying name for anonymous module specifications and implementations,</p>\n\n \n Text <p>The name of the file</p>\n\n Range <p>Gets the syntax range of this construct</p>\n\n Id <p>The identifier for the name of the file</p>\n\n QualifiedNameOfFile "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-recordfieldname.html","title":"RecordFieldName","content":"RecordFieldName \n <p>Represents a record field name plus a flag indicating if given record field name is syntactically\ncorrect and can be used in name resolution.</p>\n\n \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-scopedpragma.html","title":"ScopedPragma","content":"ScopedPragma \n <p>Represents a scoped pragma</p>\n\n \n WarningOff <p>A pragma to turn a warning off</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-seqexpronly.html","title":"SeqExprOnly","content":"SeqExprOnly \n <p>Indicates if a for loop is 'for x in e1 -&gt; e2', only valid in sequence expressions</p>\n\n \n SeqExprOnly <p>Indicates if a for loop is 'for x in e1 -&gt; e2', only valid in sequence expressions</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synaccess.html","title":"SynAccess","content":"SynAccess \n <p>Represents an accessibility modifier in F# syntax</p>\n\n \n Public <p>A construct marked or assumed 'public'</p>\n\n Internal <p>A construct marked or assumed 'internal'</p>\n\n Private <p>A construct marked or assumed 'private'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synarginfo.html","title":"SynArgInfo","content":"SynArgInfo \n <p>Represents the argument names and other metadata for a parameter for a member or function</p>\n\n \n SynArgInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synargpats.html","title":"SynArgPats","content":"SynArgPats \n <p>Represents a syntax tree for arguments patterns</p>\n\n \n Pats  NamePatPairs "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synattribute.html","title":"SynAttribute","content":"SynAttribute \n <p>Represents an attribute</p>\n\n \n TypeName <p>The name of the type for the attribute</p>\n\n ArgExpr <p>The argument of the attribute, perhaps a tuple</p>\n\n Target <p>Target specifier, e.g. \"assembly\", \"module\", etc.</p>\n\n AppliesToGetterAndSetter <p>Is this attribute being applied to a property getter or setter?</p>\n\n Range <p>The syntax range of the attribute</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synattributelist.html","title":"SynAttributeList","content":"SynAttributeList \n <p>List of attributes enclosed in [< ... >].</p>\n\n \n Attributes <p>The list of attributes</p>\n\n Range <p>The syntax range of the list of attributes</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synattributes.html","title":"SynAttributes","content":"SynAttributes \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synbinding.html","title":"SynBinding","content":"SynBinding \n <p>Represents a binding for a 'let' or 'member' declaration</p>\n\n \n RangeOfHeadPat  RangeOfBindingSansRhs  RangeOfBindingAndRhs  Binding "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synbindingkind.html","title":"SynBindingKind","content":"SynBindingKind \n <p>The kind associated with a binding - \"let\", \"do\" or a standalone expression</p>\n\n \n StandaloneExpression <p>A standalone expression in a module</p>\n\n NormalBinding <p>A normal 'let' binding in a module</p>\n\n DoBinding <p>A 'do' binding in a module. Must have type 'unit'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synbindingreturninfo.html","title":"SynBindingReturnInfo","content":"SynBindingReturnInfo \n <p>Represents the return information in a binding for a 'let' or 'member' declaration</p>\n\n \n SynBindingReturnInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syncomponentinfo.html","title":"SynComponentInfo","content":"SynComponentInfo \n <p>Represents the syntax tree associated with the name of a type definition or module\nin signature or implementation.</p>\n<p>This includes the name, attributes, type parameters, constraints, documentation and accessibility\nfor a type definition or module. For modules, entries such as the type parameters are\nalways empty.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ComponentInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synconst.html","title":"SynConst","content":"SynConst \n <p>The unchecked abstract syntax tree of constants in F# types and expressions.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Unit <p>F# syntax: ()</p>\n\n Bool <p>F# syntax: true, false</p>\n\n SByte <p>F# syntax: 13y, 0xFFy, 0o077y, 0b0111101y</p>\n\n Byte <p>F# syntax: 13uy, 0x40uy, 0oFFuy, 0b0111101uy</p>\n\n Int16 <p>F# syntax: 13s, 0x4000s, 0o0777s, 0b0111101s</p>\n\n UInt16 <p>F# syntax: 13us, 0x4000us, 0o0777us, 0b0111101us</p>\n\n Int32 <p>F# syntax: 13, 0x4000, 0o0777</p>\n\n UInt32 <p>F# syntax: 13u, 0x4000u, 0o0777u</p>\n\n Int64 <p>F# syntax: 13L</p>\n\n UInt64 <p>F# syntax: 13UL</p>\n\n IntPtr <p>F# syntax: 13n</p>\n\n UIntPtr <p>F# syntax: 13un</p>\n\n Single <p>F# syntax: 1.30f, 1.40e10f etc.</p>\n\n Double <p>F# syntax: 1.30, 1.40e10 etc.</p>\n\n Char <p>F# syntax: 'a'</p>\n\n Decimal <p>F# syntax: 23.4M</p>\n\n UserNum <p>UserNum(value, suffix)</p>\n<p>F# syntax: 1Q, 1Z, 1R, 1N, 1G</p>\n\n String <p>F# syntax: verbatim or regular string, e.g. \"abc\"</p>\n\n Bytes <p>F# syntax: verbatim or regular byte string, e.g. \"abc\"B.</p>\n<p>Also used internally in the typechecker once an array of unit16 constants\nis detected, to allow more efficient processing of large arrays of uint16 constants.</p>\n\n UInt16s <p>Used internally in the typechecker once an array of unit16 constants\nis detected, to allow more efficient processing of large arrays of uint16 constants.</p>\n\n Measure <p>Old comment: \"we never iterate, so the const here is not another SynConst.Measure\"</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synenumcase.html","title":"SynEnumCase","content":"SynEnumCase \n <p>Represents the syntax tree for one case in an enum definition.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n EnumCase "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synexceptiondefn.html","title":"SynExceptionDefn","content":"SynExceptionDefn \n <p>Represents the right hand side of an exception declaration 'exception E = ... ' plus\nany member definitions for the exception</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n SynExceptionDefn "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synexceptiondefnrepr.html","title":"SynExceptionDefnRepr","content":"SynExceptionDefnRepr \n <p>Represents the right hand side of an exception declaration 'exception E = ... '</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n SynExceptionDefnRepr "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synexceptionsig.html","title":"SynExceptionSig","content":"SynExceptionSig \n <p>Represents the right hand side of an exception definition in a signature file</p>\n\n \n SynExceptionSig "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synexpr.html","title":"SynExpr","content":"SynExpr \n <p>Represents a syntax tree for F# expressions</p>\n\n \n RangeSansAnyExtraDot <p>Get the Range ignoring any (parse error) extra trailing dots</p>\n\n RangeOfFirstPortion <p>Attempt to get the range of the first token or initial portion only - this\nis ad-hoc, just a cheap way to improve a certain 'query custom operation' error range</p>\n\n Range <p>Gets the syntax range of this construct</p>\n\n IsArbExprAndThusAlreadyReportedError <p>Indicates if this expression arises from error recovery</p>\n\n Paren <p>F# syntax: (expr)</p>\n<p>Parenthesized expressions. Kept in AST to distinguish A.M((x, y))\nfrom A.M(x, y), among other things.</p>\n\n Quote <p>F# syntax: <@ expr @>, <@@ expr @@></p>\n<p>Quote(operator, isRaw, quotedSynExpr, isFromQueryExpression, m)</p>\n\n Const <p>F# syntax: 1, 1.3, () etc.</p>\n\n Typed <p>F# syntax: expr: type</p>\n\n Tuple <p>F# syntax: e1, ..., eN</p>\n\n AnonRecd <p>F# syntax: {| id1=e1; ...; idN=eN |}\nF# syntax: struct {| id1=e1; ...; idN=eN |}</p>\n\n ArrayOrList <p>F# syntax: [ e1; ...; en ], [| e1; ...; en |]</p>\n\n Record <p>F# syntax: { f1=e1; ...; fn=en }\ninherit includes location of separator (for tooling)\ncopyOpt contains range of the following WITH part (for tooling)\nevery field includes range of separator after the field (for tooling)</p>\n\n New <p>F# syntax: new C(...)\nThe flag is true if known to be 'family' ('protected') scope</p>\n\n ObjExpr <p>F# syntax: { new ... with ... }</p>\n\n While <p>F# syntax: 'while ... do ...'</p>\n\n For <p>F# syntax: 'for i = ... to ... do ...'</p>\n\n ForEach <p>F# syntax: 'for ... in ... do ...'</p>\n\n ArrayOrListOfSeqExpr <p>F# syntax: [ expr ], [| expr |]</p>\n\n CompExpr <p>F# syntax: { expr }</p>\n\n Lambda <p>First bool indicates if lambda originates from a method. Patterns here are always \"simple\"\nSecond bool indicates if this is a \"later\" part of an iterated sequence of lambdas</p>\n<p>F# syntax: fun pat -&gt; expr</p>\n\n MatchLambda <p>F# syntax: function pat1 -&gt; expr | ... | patN -&gt; exprN</p>\n\n Match <p>F# syntax: match expr with pat1 -&gt; expr | ... | patN -&gt; exprN</p>\n\n Do <p>F# syntax: do expr</p>\n\n Assert <p>F# syntax: assert expr</p>\n\n App <p>F# syntax: f x</p>\n<p>flag: indicates if the application is syntactically atomic, e.g. f.[1] is atomic, but 'f x' is not\nisInfix is true for the first app of an infix operator, e.g. 1+2\nbecomes App(App(+, 1), 2), where the inner node is marked isInfix</p>\n\n TypeApp <p>F# syntax: expr<type1, ..., typeN></p>\n\n LetOrUse <p>F# syntax: let pat = expr in expr\nF# syntax: let f pat1 .. patN = expr in expr\nF# syntax: let rec f pat1 .. patN = expr in expr\nF# syntax: use pat = expr in expr</p>\n\n TryWith <p>F# syntax: try expr with pat -&gt; expr</p>\n\n TryFinally <p>F# syntax: try expr finally expr</p>\n\n Lazy <p>F# syntax: lazy expr</p>\n\n Sequential <p>F# syntax: expr; expr</p>\n<p>isTrueSeq: false indicates \"let v = a in b; v\"</p>\n\n IfThenElse <p>F# syntax: if expr then expr\nF# syntax: if expr then expr else expr</p>\n\n Ident <p>F# syntax: ident\nOptimized representation for SynExpr.LongIdent (false, [id], id.idRange)</p>\n\n LongIdent <p>F# syntax: ident.ident...ident</p>\n<p>isOptional: true if preceded by a '?' for an optional named parameter\naltNameRefCell: Normally 'None' except for some compiler-generated\nvariables in desugaring pattern matching. See SynSimplePat.Id</p>\n\n LongIdentSet <p>F# syntax: ident.ident...ident &lt;- expr</p>\n\n DotGet <p>F# syntax: expr.ident.ident</p>\n\n DotSet <p>F# syntax: expr.ident...ident &lt;- expr</p>\n\n Set <p>F# syntax: expr &lt;- expr</p>\n\n DotIndexedGet <p>F# syntax: expr.[expr, ..., expr]</p>\n\n DotIndexedSet <p>F# syntax: expr.[expr, ..., expr] &lt;- expr</p>\n\n NamedIndexedPropertySet <p>F# syntax: Type.Items(e1) &lt;- e2, rarely used named-property-setter notation, e.g. Foo.Bar.Chars(3) &lt;- 'a'</p>\n\n DotNamedIndexedPropertySet <p>F# syntax: expr.Items (e1) &lt;- e2, rarely used named-property-setter notation, e.g. (stringExpr).Chars(3) &lt;- 'a'</p>\n\n TypeTest <p>F# syntax: expr :? type</p>\n\n Upcast <p>F# syntax: expr :&gt; type</p>\n\n Downcast <p>F# syntax: expr :?&gt; type</p>\n\n InferredUpcast <p>F# syntax: upcast expr</p>\n\n InferredDowncast <p>F# syntax: downcast expr</p>\n\n Null <p>F# syntax: null</p>\n\n AddressOf <p>F# syntax: &amp;expr, &amp;&amp;expr</p>\n\n TraitCall <p>F# syntax: ((typar1 or ... or typarN): (member-dig) expr)</p>\n\n JoinIn <p>F# syntax: ... in ...\nComputation expressions only, based on JOIN_IN token from lex filter</p>\n\n ImplicitZero <p>Used in parser error recovery and internally during type checking for translating computation expressions.</p>\n\n SequentialOrImplicitYield <p>Used internally during type checking for translating computation expressions.</p>\n\n YieldOrReturn <p>F# syntax: yield expr\nF# syntax: return expr\nComputation expressions only</p>\n\n YieldOrReturnFrom <p>F# syntax: yield! expr\nF# syntax: return! expr\nComputation expressions only</p>\n\n LetOrUseBang <p>F# syntax: let! pat = expr in expr\nF# syntax: use! pat = expr in expr\nF# syntax: let! pat = expr and! ... and! ... and! pat = expr in expr\nComputation expressions only</p>\n\n MatchBang <p>F# syntax: match! expr with pat1 -&gt; expr | ... | patN -&gt; exprN</p>\n\n DoBang <p>F# syntax: do! expr\nComputation expressions only</p>\n\n LibraryOnlyILAssembly <p>Only used in FSharp.Core</p>\n\n LibraryOnlyStaticOptimization <p>Only used in FSharp.Core</p>\n\n LibraryOnlyUnionCaseFieldGet <p>Only used in FSharp.Core</p>\n\n LibraryOnlyUnionCaseFieldSet <p>Only used in FSharp.Core</p>\n\n ArbitraryAfterError <p>Inserted for error recovery</p>\n\n FromParseError <p>Inserted for error recovery</p>\n\n DiscardAfterMissingQualificationAfterDot <p>Inserted for error recovery when there is \"expr.\" and missing tokens or error recovery after the dot</p>\n\n Fixed <p>'use x = fixed expr'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synfield.html","title":"SynField","content":"SynField \n <p>Represents the syntax tree for a field declaration in a record or class</p>\n\n \n Field "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synindexerarg.html","title":"SynIndexerArg","content":"SynIndexerArg \n <p>Represents a syntax tree for an F# indexer expression argument</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Exprs <p>Get the one or two expressions as a list</p>\n\n Two <p>A two-element range indexer argument</p>\n\n One <p>A one-element item indexer argument</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syninterfaceimpl.html","title":"SynInterfaceImpl","content":"SynInterfaceImpl \n <p>Represents a set of bindings that implement an interface</p>\n\n \n InterfaceImpl "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmatchclause.html","title":"SynMatchClause","content":"SynMatchClause \n <p>Represents a clause in a 'match' expression</p>\n\n \n RangeOfGuardAndRhs <p>Gets the syntax range of part of this construct</p>\n\n Range <p>Gets the syntax range of this construct</p>\n\n Clause "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmeasure.html","title":"SynMeasure","content":"SynMeasure \n <p>Represents an unchecked syntax tree of F# unit of measure annotations.</p>\n\n \n Named <p>A named unit of measure</p>\n\n Product <p>A product of two units of measure, e.g. 'kg * m'</p>\n\n Seq <p>A sequence of several units of measure, e.g. 'kg m m'</p>\n\n Divide <p>A division of two units of measure, e.g. 'kg / m'</p>\n\n Power <p>A power of a unit of measure, e.g. 'kg ^ 2'</p>\n\n One <p>The '1' unit of measure</p>\n\n Anon <p>An anonymous (inferred) unit of measure</p>\n\n Var <p>A variable unit of measure</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmemberdefn.html","title":"SynMemberDefn","content":"SynMemberDefn \n <p>Represents a definition element within a type definition, e.g. 'member ... '</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Open <p>An 'open' definition within a type</p>\n\n Member <p>A 'member' definition within a type</p>\n\n ImplicitCtor <p>An implicit constructor definition</p>\n\n ImplicitInherit <p>An implicit inherit definition, 'inherit <typ>(args...) as base'</p>\n\n LetBindings <p>A 'let' definition within a class</p>\n\n AbstractSlot <p>An abstract slot definition within a class or interface</p>\n\n Interface <p>An interface implementation definition within a class</p>\n\n Inherit <p>An 'inherit' definition within a class</p>\n\n ValField <p>A 'val' definition within a class</p>\n\n NestedType <p>A nested type definition, a feature that is not implemented</p>\n\n AutoProperty <p>An auto-property definition, F# syntax: 'member val X = expr'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmemberdefns.html","title":"SynMemberDefns","content":"SynMemberDefns \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmembersig.html","title":"SynMemberSig","content":"SynMemberSig \n <p>Represents the syntax tree for a member signature (used in signature files, abstract member declarations\nand member constraints)</p>\n\n \n Member <p>A member definition in a type in a signature file</p>\n\n Interface <p>An interface definition in a type in a signature file</p>\n\n Inherit <p>An 'inherit' definition in a type in a signature file</p>\n\n ValField <p>A 'val' definition in a type in a signature file</p>\n\n NestedType <p>A nested type definition in a signature file (an unimplemented feature)</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmoduledecl.html","title":"SynModuleDecl","content":"SynModuleDecl \n <p>Represents a definition within a module</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ModuleAbbrev <p>A module abbreviation definition 'module X = A.B.C'</p>\n\n NestedModule <p>A nested module definition 'module X = ...'</p>\n\n Let <p>A 'let' definition within a module</p>\n\n DoExpr <p>A 'do expr' within a module</p>\n\n Types <p>One or more 'type' definitions within a module</p>\n\n Exception <p>An 'exception' definition within a module</p>\n\n Open <p>An 'open' definition within a module</p>\n\n Attributes <p>An attribute definition within a module, for assembly and .NET module attributes</p>\n\n HashDirective <p>A hash directive within a module</p>\n\n NamespaceFragment <p>A namespace fragment within a module</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmoduleornamespace.html","title":"SynModuleOrNamespace","content":"SynModuleOrNamespace \n <p>Represents the definition of a module or namespace</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n SynModuleOrNamespace "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmoduleornamespacekind.html","title":"SynModuleOrNamespaceKind","content":"SynModuleOrNamespaceKind \n <p>Represents the kind of a module or namespace definition</p>\n\n \n IsModule <p>Indicates if this is a module definition</p>\n\n NamedModule <p>A module is explicitly named 'module N'</p>\n\n AnonModule <p>A module is anonymously named, e.g. a script</p>\n\n DeclaredNamespace <p>A namespace is explicitly declared</p>\n\n GlobalNamespace <p>A namespace is declared 'global'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmoduleornamespacesig.html","title":"SynModuleOrNamespaceSig","content":"SynModuleOrNamespaceSig \n <p>Represents the definition of a module or namespace in a signature file</p>\n\n \n SynModuleOrNamespaceSig "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synmodulesigdecl.html","title":"SynModuleSigDecl","content":"SynModuleSigDecl \n <p>Represents a definition within a module or namespace in a signature file</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ModuleAbbrev <p>A module abbreviation definition within a module or namespace in a signature file</p>\n\n NestedModule <p>A nested module definition within a module or namespace in a signature file</p>\n\n Val <p>A 'val' definition within a module or namespace in a signature file, corresponding\nto a 'let' definition in the implementation</p>\n\n Types <p>A set of one or more type definitions within a module or namespace in a signature file</p>\n\n Exception <p>An exception definition within a module or namespace in a signature file</p>\n\n Open <p>An 'open' definition within a module or namespace in a signature file</p>\n\n HashDirective <p>A hash directive within a module or namespace in a signature file</p>\n\n NamespaceFragment <p>A namespace fragment within a namespace in a signature file</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synpat.html","title":"SynPat","content":"SynPat \n <p>Represents a syntax tree for an F# pattern</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Const <p>A constant in a pattern</p>\n\n Wild <p>A wildcard '_' in a pattern</p>\n\n Named <p>A named pattern 'pat as ident'</p>\n\n Typed <p>A typed pattern 'pat : type'</p>\n\n Attrib <p>An attributed pattern, used in argument or declaration position</p>\n\n Or <p>A disjunctive pattern 'pat1 | pat2'</p>\n\n Ands <p>A conjunctive pattern 'pat1 &amp; pat2'</p>\n\n LongIdent <p>A long identifier pattern possibly with argument patterns</p>\n\n Tuple <p>A tuple pattern</p>\n\n Paren <p>A parenthesized pattern</p>\n\n ArrayOrList <p>An array or a list as a pattern</p>\n\n Record <p>A record pattern</p>\n\n Null <p>The 'null' pattern</p>\n\n OptionalVal <p>'?id' -- for optional argument names</p>\n\n IsInst <p>A type test pattern ':? type '</p>\n\n QuoteExpr <p>&lt;@ expr @&gt;, used for active pattern arguments</p>\n\n DeprecatedCharRange <p>Deprecated character range: ranges</p>\n\n InstanceMember <p>Used internally in the type checker</p>\n\n FromParseError <p>A pattern arising from a parse error</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synrationalconst.html","title":"SynRationalConst","content":"SynRationalConst \n <p>Represents an unchecked syntax tree of F# unit of measure exponents.</p>\n\n \n Integer  Rational  Negate "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synreturninfo.html","title":"SynReturnInfo","content":"SynReturnInfo \n <p>Represents the syntactic elements associated with the \"return\" of a function or method.</p>\n\n \n SynReturnInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synsimplepat.html","title":"SynSimplePat","content":"SynSimplePat \n <p>Represents a syntax tree for simple F# patterns</p>\n\n \n Id <p>Indicates a simple pattern variable.</p>\n<p>altNameRefCell:\nNormally 'None' except for some compiler-generated variables in desugaring pattern matching.\nPattern processing sets this reference for hidden variable introduced\nby desugaring pattern matching in arguments. The info indicates an\nalternative (compiler generated) identifier to be used because the\nname of the identifier is already bound.</p>\n<p>isCompilerGenerated: true if a compiler generated name\nisThisVar: true if 'this' variable in member\nisOptArg: true if a '?' is in front of the name</p>\n\n Typed <p>A type annotated simple pattern</p>\n\n Attrib <p>An attributed simple pattern</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synsimplepatalternativeidinfo.html","title":"SynSimplePatAlternativeIdInfo","content":"SynSimplePatAlternativeIdInfo \n <p>Represents the alternative identifier for a simple pattern</p>\n\n \n Undecided <p>We have not decided to use an alternative name in the pattern and related expression</p>\n\n Decided <p>We have decided to use an alternative name in the pattern and related expression</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synsimplepats.html","title":"SynSimplePats","content":"SynSimplePats \n <p>Represents a simple set of variable bindings a, (a, b) or (a: Type, b: Type) at a lambda,\nfunction definition or other binding point, after the elimination of pattern matching\nfrom the construct, e.g. after changing a \"function pat1 -&gt; rule1 | ...\" to a\n\"fun v -&gt; match v with ...\"</p>\n\n \n SimplePats  Typed "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synstaticoptimizationconstraint.html","title":"SynStaticOptimizationConstraint","content":"SynStaticOptimizationConstraint \n <p>Represents a syntax tree for a static optimization constraint in the F# core library</p>\n\n \n WhenTyparTyconEqualsTycon <p>A static optimization conditional that activates for a particular type instantiation</p>\n\n WhenTyparIsStruct <p>A static optimization conditional that activates for a struct</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypar.html","title":"SynTypar","content":"SynTypar \n <p>Represents a syntactic type parameter</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Typar "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypardecl.html","title":"SynTyparDecl","content":"SynTyparDecl \n <p>Represents the explicit declaration of a type parameter</p>\n\n \n TyparDecl "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntype.html","title":"SynType","content":"SynType \n <p>Represents a syntax tree for F# types</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n LongIdent <p>F# syntax: A.B.C</p>\n\n App <p>F# syntax: type<type, ..., type> or type type or (type, ..., type) type\nisPostfix: indicates a postfix type application e.g. \"int list\" or \"(int, string) dict\"</p>\n\n LongIdentApp <p>F# syntax: type.A.B.C<type, ..., type></p>\n\n Tuple <p>F# syntax: type <em> ... </em> type\nF# syntax: struct (type <em> ... </em> type)</p>\n\n AnonRecd <p>F# syntax: {| id: type; ...; id: type |}\nF# syntax: struct {| id: type; ...; id: type |}</p>\n\n Array <p>F# syntax: type[]</p>\n\n Fun <p>F# syntax: type -&gt; type</p>\n\n Var <p>F# syntax: 'Var</p>\n\n Anon <p>F# syntax: _</p>\n\n WithGlobalConstraints <p>F# syntax: typ with constraints</p>\n\n HashConstraint <p>F# syntax: #type</p>\n\n MeasureDivide <p>F# syntax: for units of measure e.g. m / s</p>\n\n MeasurePower <p>F# syntax: for units of measure e.g. m^3, kg^1/2</p>\n\n StaticConstant <p>F# syntax: 1, \"abc\" etc, used in parameters to type providers\nFor the dimensionless units i.e. 1, and static parameters to provided types</p>\n\n StaticConstantExpr <p>F# syntax: const expr, used in static parameters to type providers</p>\n\n StaticConstantNamed <p>F# syntax: ident=1 etc., used in static parameters to type providers</p>\n\n Paren "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypeconstraint.html","title":"SynTypeConstraint","content":"SynTypeConstraint \n <p>The unchecked abstract syntax tree of F# type constraints</p>\n\n \n WhereTyparIsValueType <p>F# syntax: is 'typar: struct</p>\n\n WhereTyparIsReferenceType <p>F# syntax: is 'typar: not struct</p>\n\n WhereTyparIsUnmanaged <p>F# syntax is 'typar: unmanaged</p>\n\n WhereTyparSupportsNull <p>F# syntax is 'typar: null</p>\n\n WhereTyparIsComparable <p>F# syntax is 'typar: comparison</p>\n\n WhereTyparIsEquatable <p>F# syntax is 'typar: equality</p>\n\n WhereTyparDefaultsToType <p>F# syntax is default ^T: type</p>\n\n WhereTyparSubtypeOfType <p>F# syntax is 'typar :&gt; type</p>\n\n WhereTyparSupportsMember <p>F# syntax is ^T: (static member MemberName: ^T * int -&gt; ^T)</p>\n\n WhereTyparIsEnum <p>F# syntax is 'typar: enum<'UnderlyingType></p>\n\n WhereTyparIsDelegate <p>F# syntax is 'typar: delegate<'Args, unit></p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefn.html","title":"SynTypeDefn","content":"SynTypeDefn \n <p>Represents a type or exception declaration 'type C = ... ' plus\nany additional member definitions for the type</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n TypeDefn "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefnkind.html","title":"SynTypeDefnKind","content":"SynTypeDefnKind \n <p>Represents the kind of a type definition whether explicit or inferred</p>\n\n \n TyconUnspecified  TyconClass  TyconInterface  TyconStruct  TyconRecord  TyconUnion  TyconAbbrev  TyconHiddenRepr  TyconAugmentation  TyconILAssemblyCode  TyconDelegate "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefnrepr.html","title":"SynTypeDefnRepr","content":"SynTypeDefnRepr \n <p>Represents the right hand side of a type or exception declaration 'type C = ... ' plus\nany additional member definitions for the type</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ObjectModel <p>An object model type definition (class or interface)</p>\n\n Simple <p>A simple type definition (record, union, abbreviation)</p>\n\n Exception <p>An exception definition</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefnsig.html","title":"SynTypeDefnSig","content":"SynTypeDefnSig \n <p>Represents the syntax tree for a type definition in a signature</p>\n\n \n TypeDefnSig <p>The information for a type definition in a signature</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefnsigrepr.html","title":"SynTypeDefnSigRepr","content":"SynTypeDefnSigRepr \n <p>Represents the syntax tree for the right-hand-side of a type definition in a signature.\nNote: in practice, using a discriminated union to make a distinction between\n\"simple\" types and \"object oriented\" types is not particularly useful.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n ObjectModel <p>Indicates the right right-hand-side is a class, struct, interface or other object-model type</p>\n\n Simple <p>Indicates the right right-hand-side is a record, union or other simple type.</p>\n\n Exception "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-syntypedefnsimplerepr.html","title":"SynTypeDefnSimpleRepr","content":"SynTypeDefnSimpleRepr \n <p>Represents the syntax tree for the core of a simple type definition, in either signature\nor implementation.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n Union <p>A union type definition, type X = A | B</p>\n\n Enum <p>An enum type definition, type X = A = 1 | B = 2</p>\n\n Record <p>A record type definition, type X = { A: int; B: int }</p>\n\n General <p>An object oriented type definition. This is not a parse-tree form, but represents the core\ntype representation which the type checker splits out from the \"ObjectModel\" cases of type definitions.</p>\n\n LibraryOnlyILAssembly <p>A type defined by using an IL assembly representation. Only used in FSharp.Core.</p>\n<p>F# syntax: \"type X = (# \"...\"#)</p>\n\n TypeAbbrev <p>A type abbreviation, \"type X = A.B.C\"</p>\n\n None <p>An abstract definition, \"type X\"</p>\n\n Exception <p>An exception definition, \"exception E = ...\"</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synunioncase.html","title":"SynUnionCase","content":"SynUnionCase \n <p>Represents the syntax tree for one case in a union definition.</p>\n\n \n Range <p>Gets the syntax range of this construct</p>\n\n UnionCase "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synunioncasetype.html","title":"SynUnionCaseType","content":"SynUnionCaseType \n <p>Represents the syntax tree for the right-hand-side of union definition, excluding members,\nin either a signature or implementation.</p>\n\n \n UnionCaseFields <p>Normal style declaration</p>\n\n UnionCaseFullType <p>Full type spec given by 'UnionCase: ty1 * tyN -&gt; rty'. Only used in FSharp.Core, otherwise a warning.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synvaldata.html","title":"SynValData","content":"SynValData \n <p>Represents extra information about the declaration of a value</p>\n\n \n SynValData "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synvalinfo.html","title":"SynValInfo","content":"SynValInfo \n <p>The argument names and other metadata for a member or function</p>\n\n \n ArgInfos  SynValInfo <p>SynValInfo(curriedArgInfos, returnInfo)</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synvalsig.html","title":"SynValSig","content":"SynValSig \n <p>Represents the syntax tree for a 'val' definition in an abstract slot or a signature file</p>\n\n \n SynType  SynInfo  RangeOfId  ValSpfn "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-synvaltypardecls.html","title":"SynValTyparDecls","content":"SynValTyparDecls \n <p>Represents the names and other metadata for the type parameters for a member or function</p>\n\n \n SynValTyparDecls "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtree-typarstaticreq.html","title":"TyparStaticReq","content":"TyparStaticReq \n <p>Represents whether a type parameter has a static requirement or not (^T or 'T)</p>\n\n \n NoStaticReq <p>The construct is a normal type inference variable</p>\n\n HeadTypeStaticReq <p>The construct is a statically inferred type inference variable '^T'</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-syntaxtreeops-synargnamegenerator.html","title":"SynArgNameGenerator","content":"SynArgNameGenerator \n  \n ( .ctor )  New  Reset "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-xmldoc-prexmldoc.html","title":"PreXmlDoc","content":"PreXmlDoc \n <p>Represents the XmlDoc fragments as collected from the lexer during parsing</p>\n\n \n ToXmlDoc  CreateFromGrabPoint  Merge  Empty  PreXmlMerge  PreXmlDoc  PreXmlDocEmpty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-xmldoc-xmldoc.html","title":"XmlDoc","content":"XmlDoc \n <p>Represents the final form of collected XmlDoc lines</p>\n\n \n NonEmpty  Merge  Process <p>This code runs for .XML generation and thus influences cross-project xmldoc tooltips; for within-project tooltips,\nsee XmlDocumentation.fs in the language service</p>\n\n Empty  XmlDoc "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-xmldoc-xmldoccollector.html","title":"XmlDocCollector","content":"XmlDocCollector \n <p>Used to collect XML documentation during lexing and parsing.</p>\n\n \n ( .ctor )  AddGrabPoint  AddXmlDocLine  LinesBefore "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-xmldoc-xmldocstatics.html","title":"XmlDocStatics","content":"XmlDocStatics \n  \n ( .ctor )  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilalignment.html","title":"ILAlignment","content":"ILAlignment \n  \n Aligned  Unaligned1  Unaligned2  Unaligned4 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilargconvention.html","title":"ILArgConvention","content":"ILArgConvention \n  \n Default  CDecl  StdCall  ThisCall  FastCall  VarArg "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilarraybound.html","title":"ILArrayBound","content":"ILArrayBound \n <p>Array shapes. For most purposes the rank is the only thing that matters.</p>\n\n \n Value  IsSome  IsNone  None "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilarraybounds.html","title":"ILArrayBounds","content":"ILArrayBounds \n <p>Lower-bound/size pairs</p>\n\n \n Item1  Item2 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilarrayshape.html","title":"ILArrayShape","content":"ILArrayShape \n  \n Rank  FromRank  SingleDimensional <p>Bounds for a single dimensional, zero based array</p>\n\n ILArrayShape "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilassemblylongevity.html","title":"ILAssemblyLongevity","content":"ILAssemblyLongevity \n  \n Unspecified  Library  PlatformAppDomain  PlatformProcess  PlatformSystem "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilassemblymanifest.html","title":"ILAssemblyManifest","content":"ILAssemblyManifest \n <p>The main module of an assembly is a module plus some manifest information.</p>\n\n \n SecurityDecls  CustomAttrs  Name  AuxModuleHashAlgorithm <p>This is the ID of the algorithm used for the hashes of auxiliary\nfiles in the assembly.   These hashes are stored in the\n<c>ILModuleRef.Hash</c> fields of this assembly. These are not\ncryptographic hashes: they are simple file hashes. The algorithm\nis normally <c>0x00008004</c> indicating the SHA1 hash algorithm.</p>\n\n SecurityDeclsStored  PublicKey <p>This is the public key used to sign this\nassembly (the signature itself is stored elsewhere: see the\nbinary format, and may not have been written if delay signing\nis used).  (member Name, member PublicKey) forms the full\npublic name of the assembly.</p>\n\n Version  Locale  CustomAttrsStored  AssemblyLongevity  DisableJitOptimizations  JitTracking  IgnoreSymbolStoreSequencePoints  Retargetable  ExportedTypes <p>Records the types implemented by this assembly in auxiliary\nmodules.</p>\n\n EntrypointElsewhere <p>Records whether the entrypoint resides in another module.</p>\n\n MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilassemblyref.html","title":"ILAssemblyRef","content":"ILAssemblyRef \n  \n EqualsIgnoringVersion  Version  Retargetable <p>CLI says this indicates if the assembly can be retargeted (at runtime) to be from a different publisher.</p>\n\n QualifiedName <p>The fully qualified name of the assembly reference, e.g. mscorlib, Version=1.0.3705 etc.</p>\n\n PublicKey  Name  Locale  Hash  Create  FromAssemblyName "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilattribelem.html","title":"ILAttribElem","content":"ILAttribElem \n  \n String <p>Represents a custom attribute parameter of type 'string'. These may be null, in which case they are encoded in a special\nway as indicated by Ecma-335 Partition II.</p>\n\n Bool  Char  SByte  Int16  Int32  Int64  Byte  UInt16  UInt32  UInt64  Single  Double  Null  Type  TypeRef  Array "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilattribute.html","title":"ILAttribute","content":"ILAttribute \n <p>Custom attribute.</p>\n\n \n WithMethod  Method <p>Attribute instance constructor.</p>\n\n Elements <p>Decoded arguments. May be empty in encoded attribute form.</p>\n\n Encoded <p>Attribute with args encoded to a binary blob according to ECMA-335 II.21 and II.23.3.\n'decodeILAttribData' is used to parse the byte[] blob to ILAttribElem's as best as possible.</p>\n\n Decoded <p>Attribute with args in decoded form.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilattributenamedarg.html","title":"ILAttributeNamedArg","content":"ILAttributeNamedArg \n <p>Named args: values and flags indicating if they are fields or properties.</p>\n\n \n Item1  Item2  Item3  Item4 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilattributes.html","title":"ILAttributes","content":"ILAttributes \n  \n AsList  AsArray "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilattributesstored.html","title":"ILAttributesStored","content":"ILAttributesStored \n <p>Represents the efficiency-oriented storage of ILAttributes in another item.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilbasictype.html","title":"ILBasicType","content":"ILBasicType \n  \n DT_R  DT_I1  DT_U1  DT_I2  DT_U2  DT_I4  DT_U4  DT_I8  DT_U8  DT_R4  DT_R8  DT_I  DT_U  DT_REF "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilboxity.html","title":"ILBoxity","content":"ILBoxity \n  \n AsObject  AsValue "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilcallingconv.html","title":"ILCallingConv","content":"ILCallingConv \n  \n ThisConv  IsStatic  IsInstanceExplicit  IsInstance  BasicConv  Static  Instance  Callconv "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilcallingsignature.html","title":"ILCallingSignature","content":"ILCallingSignature \n  \n CallingConv  ArgTypes  ReturnType "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilcode.html","title":"ILCode","content":"ILCode \n  \n Labels  Instrs  Exceptions  Locals "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilcodelabel.html","title":"ILCodeLabel","content":"ILCodeLabel \n <p>ILCode labels.  In structured code each code label refers to a basic block somewhere in the code of the method.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilcomparisoninstr.html","title":"ILComparisonInstr","content":"ILComparisonInstr \n  \n BI_beq  BI_bge  BI_bge_un  BI_bgt  BI_bgt_un  BI_ble  BI_ble_un  BI_blt  BI_blt_un  BI_bne_un  BI_brfalse  BI_brtrue "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilconst.html","title":"ILConst","content":"ILConst \n  \n I4  I8  R4  R8 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ildefaultpinvokeencoding.html","title":"ILDefaultPInvokeEncoding","content":"ILDefaultPInvokeEncoding \n <p>Default Unicode encoding for P/Invoke  within a type.</p>\n\n \n Ansi  Auto  Unicode "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilenuminfo.html","title":"ILEnumInfo","content":"ILEnumInfo \n <p>Decompose a type definition according to its kind.</p>\n\n \n enumValues  enumType "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ileventdef.html","title":"ILEventDef","content":"ILEventDef \n <p>Event definitions.</p>\n\n \n ( .ctor ) <p>Functional creation of a value, immediate</p>\n\n ( .ctor ) <p>Functional creation of a value, using delayed reading via a metadata index, for ilread.fs</p>\n\n With <p>Functional update of the value</p>\n\n RemoveMethod  OtherMethods  Name  IsSpecialName  IsRTSpecialName  FireMethod  EventType  CustomAttrs  Attributes  AddMethod "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ileventdefs.html","title":"ILEventDefs","content":"ILEventDefs \n <p>Table of those events in a type definition.</p>\n\n \n LookupByName  AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ileventref.html","title":"ILEventRef","content":"ILEventRef \n <p>A utility type provided for completeness</p>\n\n \n Name  DeclaringTypeRef  Create "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilexceptionclause.html","title":"ILExceptionClause","content":"ILExceptionClause \n  \n Finally  Fault  FilterCatch  TypeCatch "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilexceptionspec.html","title":"ILExceptionSpec","content":"ILExceptionSpec \n  \n Range  Clause "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilexportedtypeorforwarder.html","title":"ILExportedTypeOrForwarder","content":"ILExportedTypeOrForwarder \n <p>these are only found in the ILExportedTypesAndForwarders table in the manifest</p>\n\n \n IsForwarder  CustomAttrs  Access  ScopeRef  Name <p>[Namespace.]Name</p>\n\n Attributes  Nested  CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilexportedtypesandforwarders.html","title":"ILExportedTypesAndForwarders","content":"ILExportedTypesAndForwarders \n  \n TryFindByName  AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilfielddef.html","title":"ILFieldDef","content":"ILFieldDef \n <p>Field definitions.</p>\n\n \n ( .ctor ) <p>Functional creation of a value, immediate</p>\n\n ( .ctor ) <p>Functional creation of a value using delayed reading via a metadata index</p>\n\n With <p>Functional update of the value</p>\n\n WithAccess  WithFieldMarshal  WithInitOnly  WithLiteralDefaultValue  WithNotSerialized  WithSpecialName  WithStatic  Offset <p>The explicit offset in bytes when explicit layout is used.</p>\n\n NotSerialized  Name  Marshal  LiteralValue  IsStatic  IsSpecialName  IsLiteral  IsInitOnly  FieldType  Data  CustomAttrs  Attributes  Access "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilfielddefs.html","title":"ILFieldDefs","content":"ILFieldDefs \n <p>Tables of fields.  Logically equivalent to a list of fields but the table is kept in\na form to allow efficient looking up fields by name.</p>\n\n \n LookupByName  AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilfieldinit.html","title":"ILFieldInit","content":"ILFieldInit \n <p>Field Init</p>\n\n \n String  Bool  Char  Int8  Int16  Int32  Int64  UInt8  UInt16  UInt32  UInt64  Single  Double  Null "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilfieldref.html","title":"ILFieldRef","content":"ILFieldRef \n <p>Formal identities of fields.</p>\n\n \n DeclaringTypeRef  Name  Type "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilfieldspec.html","title":"ILFieldSpec","content":"ILFieldSpec \n <p>Field specs.  The data given for a ldfld, stfld etc. instruction.</p>\n\n \n Name  FormalType  DeclaringTypeRef  ActualType  FieldRef  DeclaringType "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilgenericargs.html","title":"ILGenericArgs","content":"ILGenericArgs \n <p>Actual generic parameters are  always types.</p>\n\n \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilgenericargslist.html","title":"ILGenericArgsList","content":"ILGenericArgsList \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilgenericparameterdef.html","title":"ILGenericParameterDef","content":"ILGenericParameterDef \n <p>Generic parameters.  Formal generic parameter declarations may include the bounds, if any, on the generic parameter.</p>\n\n \n CustomAttrs  Name  Constraints <p>At most one is the parent type, the others are interface types.</p>\n\n Variance <p>Variance of type parameters, only applicable to generic parameters for generic interfaces and delegates.</p>\n\n HasReferenceTypeConstraint <p>Indicates the type argument must be a reference type.</p>\n\n HasNotNullableValueTypeConstraint <p>Indicates the type argument must be a value type, but not Nullable.</p>\n\n HasDefaultConstructorConstraint <p>Indicates the type argument must have a public nullary constructor.</p>\n\n CustomAttrsStored <p>Do not use this</p>\n\n MetadataIndex <p>Do not use this</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilgenericparameterdefs.html","title":"ILGenericParameterDefs","content":"ILGenericParameterDefs \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilgenericvariance.html","title":"ILGenericVariance","content":"ILGenericVariance \n  \n NonVariant  CoVariant  ContraVariant "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilglobals.html","title":"ILGlobals","content":"ILGlobals \n <p>A table of common references to items in primary assembly (System.Runtime or mscorlib).\nIf a particular version of System.Runtime.dll has been loaded then you should\nreference items from it via an ILGlobals for that specific version built using mkILGlobals.</p>\n\n \n IsPossiblePrimaryAssemblyRef <p>Is the given assembly possibly a primary assembly?\nIn practice, a primary assembly is an assembly that contains the System.Object type definition\nand has no referenced assemblies.\nHowever, we must consider assemblies that forward the System.Object type definition\nto be possible primary assemblies.\nTherefore, this will return true if the given assembly is the real primary assembly or an assembly that forwards\nthe System.Object type definition.\nAssembly equivalency ignores the version here.</p>\n\n typ_UIntPtr  typ_UInt64  typ_UInt32  typ_UInt16  typ_TypedReference  typ_Type  typ_String  typ_Single  typ_SByte  typ_Object  typ_IntPtr  typ_Int64  typ_Int32  typ_Int16  typ_Double  typ_Char  typ_Byte  typ_Bool  typ_Array  primaryAssemblyScopeRef  primaryAssemblyRef  primaryAssemblyName "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilguid.html","title":"ILGuid","content":"ILGuid \n <p>Represents guids</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilinstr.html","title":"ILInstr","content":"ILInstr \n <p>The instruction set.</p>\n\n \n AI_add  AI_add_ovf  AI_add_ovf_un  AI_and  AI_div  AI_div_un  AI_ceq  AI_cgt  AI_cgt_un  AI_clt  AI_clt_un  AI_conv  AI_conv_ovf  AI_conv_ovf_un  AI_mul  AI_mul_ovf  AI_mul_ovf_un  AI_rem  AI_rem_un  AI_shl  AI_shr  AI_shr_un  AI_sub  AI_sub_ovf  AI_sub_ovf_un  AI_xor  AI_or  AI_neg  AI_not  AI_ldnull  AI_dup  AI_pop  AI_ckfinite  AI_nop  AI_ldc  I_ldarg  I_ldarga  I_ldind  I_ldloc  I_ldloca  I_starg  I_stind  I_stloc  I_br  I_jmp  I_brcmp  I_switch  I_ret  I_call  I_callvirt  I_callconstraint  I_calli  I_ldftn  I_newobj  I_throw  I_endfinally  I_endfilter  I_leave  I_rethrow  I_ldsfld  I_ldfld  I_ldsflda  I_ldflda  I_stsfld  I_stfld  I_ldstr  I_isinst  I_castclass  I_ldtoken  I_ldvirtftn  I_cpobj  I_initobj  I_ldobj  I_stobj  I_box  I_unbox  I_unbox_any  I_sizeof  I_ldelem  I_stelem  I_ldelema  I_ldelem_any  I_stelem_any  I_newarr  I_ldlen  I_mkrefany  I_refanytype  I_refanyval  I_break  I_seqpoint  I_arglist  I_localloc  I_cpblk  I_initblk  EI_ilzero  EI_ldlen_multi "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illazymethodbody.html","title":"ILLazyMethodBody","content":"ILLazyMethodBody \n  \n Contents "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illocal.html","title":"ILLocal","content":"ILLocal \n <p>Local variables</p>\n\n \n Type  IsPinned  DebugInfo "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illocaldebuginfo.html","title":"ILLocalDebugInfo","content":"ILLocalDebugInfo \n  \n Range  DebugMappings "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illocaldebugmapping.html","title":"ILLocalDebugMapping","content":"ILLocalDebugMapping \n <p>Indicates that a particular local variable has a particular source\nlanguage name within a given set of ranges. This does not effect local\nvariable numbering, which is global over the whole method.</p>\n\n \n LocalIndex  LocalName "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illocals.html","title":"ILLocals","content":"ILLocals \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-illocalsallocator.html","title":"ILLocalsAllocator","content":"ILLocalsAllocator \n <p>Helpers for codegen: scopes for allocating new temporary variables.</p>\n\n \n ( .ctor )  AllocLocal  Close "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmemberaccess.html","title":"ILMemberAccess","content":"ILMemberAccess \n <p>Member Access</p>\n\n \n Assembly  CompilerControlled  FamilyAndAssembly  FamilyOrAssembly  Family  Private  Public "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodbody.html","title":"ILMethodBody","content":"ILMethodBody \n <p>IL method bodies</p>\n\n \n IsZeroInit  MaxStack  NoInlining  AggressiveInlining  Locals  Code  SourceMarker "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethoddef.html","title":"ILMethodDef","content":"ILMethodDef \n <p>IL Method definitions.</p>\n\n \n ( .ctor ) <p>Functional creation of a value, immediate</p>\n\n ( .ctor ) <p>Functional creation of a value, with delayed reading of some elements via a metadata index</p>\n\n With <p>Functional update of the value</p>\n\n WithAbstract  WithAccess  WithAggressiveInlining  WithFinal  WithHideBySig  WithHideBySig  WithNoInlining  WithPInvoke  WithPreserveSig  WithRuntime  WithSecurity  WithSynchronized  WithSpecialName  WithNewSlot  SecurityDecls  Return  Parameters  ParameterTypes  Name  MethodBody  MaxStack  Locals  IsZeroInit  IsVirtual <p>Indicates an instance methods that is virtual or abstract or implements an interface slot.</p>\n\n IsUnmanagedExport <p>The method is exported to unmanaged code using COM interop.</p>\n\n IsSynchronized  IsStatic <p>Indicates a static method.</p>\n\n IsSpecialName  IsReqSecObj  IsPreserveSig  IsNonVirtualInstance <p>Indicates this is an instance methods that is not virtual.</p>\n\n IsNoInline  IsNewSlot  IsMustRun <p>SafeHandle finalizer must be run.</p>\n\n IsManaged  IsInternalCall  IsIL  IsHideBySig  IsForwardRef  IsFinal  IsEntryPoint  IsConstructor <p>Indicates a .ctor method.</p>\n\n IsClassInitializer <p>Indicates a .cctor method.</p>\n\n IsCheckAccessOnOverride  IsAggressiveInline  IsAbstract  ImplAttributes  HasSecurity <p>Some methods are marked \"HasSecurity\" even if there are no permissions attached, e.g. if they use SuppressUnmanagedCodeSecurityAttribute</p>\n\n GenericParams  CustomAttrs  Code  CallingSignature  CallingConv  Body  Attributes  Access "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethoddefs.html","title":"ILMethodDefs","content":"ILMethodDefs \n <p>Tables of methods.  Logically equivalent to a list of methods but\nthe table is kept in a form optimized for looking up methods by\nname and arity.</p>\n\n \n FindByName  TryFindInstanceByNameAndCallingSignature  AsList  AsArray "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodimpldef.html","title":"ILMethodImplDef","content":"ILMethodImplDef \n <p>Method Impls</p>\n\n \n Overrides  OverrideBy "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodimpldefs.html","title":"ILMethodImplDefs","content":"ILMethodImplDefs \n  \n AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodref.html","title":"ILMethodRef","content":"ILMethodRef \n <p>Formal identities of methods.</p>\n\n \n ReturnType  Name  GenericArity  DeclaringTypeRef  CallingSignature  CallingConv  ArgTypes  ArgCount  Create <p>Functional creation</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodspec.html","title":"ILMethodSpec","content":"ILMethodSpec \n <p>The information at the callsite of a method</p>\n\n \n Name  MethodRef  GenericArity  GenericArgs  FormalReturnType  FormalArgTypes  DeclaringType  CallingConv  Create <p>Functional creation</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmethodvirtualinfo.html","title":"ILMethodVirtualInfo","content":"ILMethodVirtualInfo \n  \n IsFinal  IsNewSlot  IsCheckAccessOnOverride  IsAbstract "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmoduledef.html","title":"ILModuleDef","content":"ILModuleDef \n <p>One module in the \"current\" assembly, either a main-module or\nan auxiliary module.  The main module will have a manifest.</p>\n<p>An assembly is built by joining together a \"main\" module plus\nseveral auxiliary modules.</p>\n\n \n ManifestOfAssembly  HasManifest  CustomAttrs  Manifest  Name  TypeDefs  SubsystemVersion  UseHighEntropyVA  SubSystemFlags  IsDLL  IsILOnly  Platform  StackReserveSize  Is32Bit  Is32BitPreferred  Is64Bit  VirtualAlignment  PhysicalAlignment  ImageBase  MetadataVersion  Resources  NativeResources <p>e.g. win86 resources, as the exact contents of a .res or .obj file. Must be unlinked manually.</p>\n\n CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilmoduleref.html","title":"ILModuleRef","content":"ILModuleRef \n  \n Name  Hash  HasMetadata  Create "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilnativeresource.html","title":"ILNativeResource","content":"ILNativeResource \n  \n In <p>Represents a native resource to be read from the PE file</p>\n\n Out <p>Represents a native resource to be written in an output file</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilnativetype.html","title":"ILNativeType","content":"ILNativeType \n <p>Native Types, for marshalling to the native C interface.\nThese are taken directly from the ILASM syntax, see ECMA Spec (Partition II, 7.4).</p>\n\n \n Empty  Custom  FixedSysString  FixedArray  Currency  LPSTR  LPWSTR  LPTSTR  LPUTF8STR  ByValStr  TBSTR  LPSTRUCT  Struct  Void  Bool  Int8  Int16  Int32  Int64  Single  Double  Byte  UInt16  UInt32  UInt64  Array <p>optional idx of parameter giving size plus optional additive i.e. num elems</p>\n\n Int  UInt  Method  AsAny  BSTR  IUnknown  IDispatch  Interface  Error  SafeArray  ANSIBSTR  VariantBool "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilnativevariant.html","title":"ILNativeVariant","content":"ILNativeVariant \n  \n Empty  Null  Variant  Currency  Decimal  Date  BSTR  LPSTR  LPWSTR  IUnknown  IDispatch  SafeArray  Error  HRESULT  CArray  UserDefined  Record  FileTime  Blob  Stream  Storage  StreamedObject  StoredObject  BlobObject  CF  CLSID  Void  Bool  Int8  Int16  Int32  Int64  Single  Double  UInt8  UInt16  UInt32  UInt64  PTR  Array  Vector  Byref  Int  UInt "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilnestedexportedtype.html","title":"ILNestedExportedType","content":"ILNestedExportedType \n <p>these are only found in the \"Nested\" field of ILExportedTypeOrForwarder objects</p>\n\n \n CustomAttrs  Name  Access  Nested  CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilnestedexportedtypes.html","title":"ILNestedExportedTypes","content":"ILNestedExportedTypes \n  \n AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iloverridesspec.html","title":"ILOverridesSpec","content":"ILOverridesSpec \n \n \n MethodRef  DeclaringType  OverridesSpec "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilparameter.html","title":"ILParameter","content":"ILParameter \n <p>Method parameters and return values.</p>\n\n \n CustomAttrs  Name  Type  Default  Marshal <p>Marshalling map for parameters. COM Interop only.</p>\n\n IsIn  IsOut  IsOptional  CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilparameters.html","title":"ILParameters","content":"ILParameters \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilplatform.html","title":"ILPlatform","content":"ILPlatform \n  \n X86  AMD64  IA64 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilpretypedef.html","title":"ILPreTypeDef","content":"ILPreTypeDef \n <p>Represents a prefix of information for ILTypeDef.</p>\n<p>The information is enough to perform name resolution for the F# compiler, probe attributes\nfor ExtensionAttribute  etc.  This is key to the on-demand exploration of .NET metadata.\nThis information has to be \"Goldilocks\" - not too much, not too little, just right.</p>\n\n \n GetTypeDef <p>Realise the actual full typedef</p>\n\n Namespace  Name "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilpretypedefimpl.html","title":"ILPreTypeDefImpl","content":"ILPreTypeDefImpl \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilpropertydef.html","title":"ILPropertyDef","content":"ILPropertyDef \n <p>Property definitions</p>\n\n \n ( .ctor ) <p>Functional creation of a value, immediate</p>\n\n ( .ctor ) <p>Functional creation of a value, using delayed reading via a metadata index, for ilread.fs</p>\n\n With <p>Functional update of the value</p>\n\n SetMethod  PropertyType  Name  IsSpecialName  IsRTSpecialName  Init  GetMethod  CustomAttrs  CallingConv  Attributes  Args "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilpropertydefs.html","title":"ILPropertyDefs","content":"ILPropertyDefs \n <p>Table of properties in an IL type definition.</p>\n\n \n LookupByName  AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilpropertyref.html","title":"ILPropertyRef","content":"ILPropertyRef \n <p>A utility type provided for completeness</p>\n\n \n Name  DeclaringTypeRef  Create "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilreadonly.html","title":"ILReadonly","content":"ILReadonly \n  \n ReadonlyAddress  NormalAddress "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilreferences.html","title":"ILReferences","content":"ILReferences \n  \n AssemblyReferences  ModuleReferences "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilresource.html","title":"ILResource","content":"ILResource \n <p>\"Manifest ILResources\" are chunks of resource data, being one of:\n- the data section of the current module (byte[] of resource given directly).\n- in an external file in this assembly (offset given in the ILResourceLocation field).\n- as a resources in another assembly of the same name.</p>\n\n \n CustomAttrs  Name  Location  Access  CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilresourceaccess.html","title":"ILResourceAccess","content":"ILResourceAccess \n  \n Public  Private "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilresourcelocation.html","title":"ILResourceLocation","content":"ILResourceLocation \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilresources.html","title":"ILResources","content":"ILResources \n <p>Table of resources in a module.</p>\n\n \n AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilreturn.html","title":"ILReturn","content":"ILReturn \n <p>Method return values.</p>\n\n \n WithCustomAttrs  CustomAttrs  Marshal  Type  CustomAttrsStored  MetadataIndex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilscoperef.html","title":"ILScopeRef","content":"ILScopeRef \n  \n QualifiedName  IsLocalRef  Local <p>A reference to the type in the current module</p>\n\n Module <p>A reference to a type in a module in the same assembly</p>\n\n Assembly <p>A reference to a type in another assembly</p>\n\n PrimaryAssembly <p>A reference to a type in the primary assembly</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsecurityaction.html","title":"ILSecurityAction","content":"ILSecurityAction \n  \n Request  Demand  Assert  Deny  PermitOnly  LinkCheck  InheritCheck  ReqMin  ReqOpt  ReqRefuse  PreJitGrant  PreJitDeny  NonCasDemand  NonCasLinkDemand  NonCasInheritance  LinkDemandChoice  InheritanceDemandChoice  DemandChoice "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsecuritydecl.html","title":"ILSecurityDecl","content":"ILSecurityDecl \n  \n ILSecurityDecl "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsecuritydecls.html","title":"ILSecurityDecls","content":"ILSecurityDecls \n <p>Abstract type equivalent to ILSecurityDecl list - use helpers\nbelow to construct/destruct these.</p>\n\n \n AsList "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsecuritydeclsstored.html","title":"ILSecurityDeclsStored","content":"ILSecurityDeclsStored \n <p>Represents the efficiency-oriented storage of ILSecurityDecls in another item.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsourcedocument.html","title":"ILSourceDocument","content":"ILSourceDocument \n <p>Debug info.  Values of type \"source\" can be attached at sequence\npoints and some other locations.</p>\n\n \n Vendor  Language  File  DocumentType  Create "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilsourcemarker.html","title":"ILSourceMarker","content":"ILSourceMarker \n  \n Line  EndLine  EndColumn  Document  Column  Create "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltailcall.html","title":"ILTailcall","content":"ILTailcall \n  \n Tailcall  Normalcall "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilthisconvention.html","title":"ILThisConvention","content":"ILThisConvention \n  \n Instance <p>accepts an implicit 'this' pointer</p>\n\n InstanceExplicit <p>accepts an explicit 'this' pointer</p>\n\n Static <p>no 'this' pointer is passed</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltoken.html","title":"ILToken","content":"ILToken \n  \n ILType  ILMethod  ILField "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltype.html","title":"ILType","content":"ILType \n  \n TypeSpec <p>The type being modified.</p>\n\n TypeRef  QualifiedName  IsTyvar  IsNominal  GenericArgs  Boxity  BasicQualifiedName  Void <p>Used only in return and pointer types.</p>\n\n Array <p>Array types</p>\n\n Value <p>Unboxed types, including builtin types.</p>\n\n Boxed <p>Reference types.  Also may be used for parents of members even if for members in value types.</p>\n\n Ptr <p>Unmanaged pointers.  Nb. the type is used by tools and for binding only, not by the verifier.</p>\n\n Byref <p>Managed pointers.</p>\n\n FunctionPointer <p>ILCode pointers.</p>\n\n TypeVar <p>Reference a generic arg.</p>\n\n Modified <p>Custom modifiers.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedef.html","title":"ILTypeDef","content":"ILTypeDef \n <p>Represents IL Type Definitions.</p>\n\n \n ( .ctor ) <p>Functional creation of a value, immediate</p>\n\n ( .ctor ) <p>Functional creation of a value, using delayed reading via a metadata index, for ilread.fs</p>\n\n With <p>Functional update</p>\n\n WithAbstract  WithAccess  WithEncoding  WithHasSecurity  WithImport  WithInitSemantics  WithKind  WithLayout  WithNestedAccess  WithSealed  WithSerializable  WithSpecialName  SecurityDecls  Properties  NestedTypes  Name  Methods  MethodImpls  Layout  IsStructOrEnum  IsStruct  IsSpecialName  IsSerializable  IsSealed  IsInterface  IsEnum  IsDelegate  IsComInterop <p>Class or interface generated for COM interop.</p>\n\n IsClass  IsAbstract  Implements  HasSecurity <p>Some classes are marked \"HasSecurity\" even if there are no permissions attached,\ne.g. if they use SuppressUnmanagedCodeSecurityAttribute</p>\n\n GenericParams  Fields  Extends  Events  Encoding  CustomAttrs  Attributes  Access "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedefaccess.html","title":"ILTypeDefAccess","content":"ILTypeDefAccess \n <p>Type Access.</p>\n\n \n Public  Private  Nested "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedefkind.html","title":"ILTypeDefKind","content":"ILTypeDefKind \n <p>A categorization of type definitions into \"kinds\"</p>\n\n \n Class  ValueType  Interface  Enum  Delegate "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedeflayout.html","title":"ILTypeDefLayout","content":"ILTypeDefLayout \n <p>Type Layout information.</p>\n\n \n Auto  Sequential  Explicit "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedeflayoutinfo.html","title":"ILTypeDefLayoutInfo","content":"ILTypeDefLayoutInfo \n  \n Size  Pack "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedefstored.html","title":"ILTypeDefStored","content":"ILTypeDefStored \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypedefs.html","title":"ILTypeDefs","content":"ILTypeDefs \n <p>Tables of named type definitions.</p>\n\n \n FindByName <p>Calls to <c>FindByName</c> will result in any laziness in the overall\nset of ILTypeDefs being read in in addition\nto the details for the type found, but the remaining individual\ntype definitions will not be read.</p>\n\n AsList  AsArrayOfPreTypeDefs <p>Get some information about the type defs, but do not force the read of the type defs themselves.</p>\n\n AsArray "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypeinit.html","title":"ILTypeInit","content":"ILTypeInit \n <p>Indicate the initialization semantics of a type.</p>\n\n \n BeforeField  OnAny "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltyperef.html","title":"ILTypeRef","content":"ILTypeRef \n <p>Type refs, i.e. references to types in some .NET assembly</p>\n\n \n Scope <p>Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?</p>\n\n QualifiedName  Name <p>The name of the type. This also contains the namespace if Enclosing is empty.</p>\n\n FullName <p>The name of the type in the assembly using the '.' notation for nested types.</p>\n\n Enclosing <p>The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.</p>\n\n BasicQualifiedName <p>The name of the type in the assembly using the '+' notation for nested types.</p>\n\n Create <p>Create a ILTypeRef.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypespec.html","title":"ILTypeSpec","content":"ILTypeSpec \n <p>Type specs and types.</p>\n\n \n TypeRef <p>Which type is being referred to?</p>\n\n Scope <p>Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?</p>\n\n Name <p>The name of the type. This also contains the namespace if Enclosing is empty.</p>\n\n GenericArgs <p>The type instantiation if the type is generic, otherwise empty</p>\n\n FullName <p>The name of the type in the assembly using the '.' notation for nested types.</p>\n\n Enclosing <p>The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.</p>\n\n Create <p>Create an ILTypeSpec.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-iltypes.html","title":"ILTypes","content":"ILTypes \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilvarargs.html","title":"ILVarArgs","content":"ILVarArgs \n  \n Value  IsSome  IsNone  None "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilversioninfo.html","title":"ILVersionInfo","content":"ILVersionInfo \n  \n ( .ctor )  Major  Minor  Build  Revision "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-ilvolatility.html","title":"ILVolatility","content":"ILVolatility \n  \n Volatile  Nonvolatile "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-methodbody.html","title":"MethodBody","content":"MethodBody \n  \n IL  PInvoke  Abstract  Native  NotAvailable "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-methodcodekind.html","title":"MethodCodeKind","content":"MethodCodeKind \n  \n IL  Native  Runtime "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-methodkind.html","title":"MethodKind","content":"MethodKind \n  \n Static  Cctor  Ctor  NonVirtual  Virtual "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-pinvokecallingconvention.html","title":"PInvokeCallingConvention","content":"PInvokeCallingConvention \n <p>PInvoke attributes.</p>\n\n \n None  Cdecl  Stdcall  Thiscall  Fastcall  WinApi "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-pinvokecharbestfit.html","title":"PInvokeCharBestFit","content":"PInvokeCharBestFit \n  \n UseAssembly  Enabled  Disabled "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-pinvokecharencoding.html","title":"PInvokeCharEncoding","content":"PInvokeCharEncoding \n  \n None  Ansi  Unicode  Auto "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-pinvokemethod.html","title":"PInvokeMethod","content":"PInvokeMethod \n  \n Where  Name  CallingConv  CharEncoding  NoMangle  LastError  ThrowOnUnmappableChar  CharBestFit "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-pinvokethrowonunmappablechar.html","title":"PInvokeThrowOnUnmappableChar","content":"PInvokeThrowOnUnmappableChar \n  \n UseAssembly  Enabled  Disabled "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-primaryassembly.html","title":"PrimaryAssembly","content":"PrimaryAssembly \n  \n Name  Mscorlib  System_Runtime  NetStandard "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-il-publickey.html","title":"PublicKey","content":"PublicKey \n  \n KeyToken  Key  IsKeyToken  IsKey  KeyAsToken  PublicKey  PublicKeyToken "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-ilmodulereader.html","title":"ILModuleReader","content":"ILModuleReader \n <p>Represents a reader of the metadata of a .NET binary.  May also give some values (e.g. IL code) from the PE file\nif it was provided.</p>\n\n \n ILModuleDef  ILAssemblyRefs "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-ilreadermetadatasnapshot.html","title":"ILReaderMetadataSnapshot","content":"ILReaderMetadataSnapshot \n <p>Used to implement a Binary file over native memory, used by Roslyn integration</p>\n\n \n Item1  Item2  Item3 "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-ilreaderoptions.html","title":"ILReaderOptions","content":"ILReaderOptions \n  \n pdbDirPath  reduceMemoryUsage  metadataOnly <p>Only open a metadata reader for the metadata portion of the .NET binary without keeping alive any data associated with the PE reader\n- IL code will not be available (mdBody in ILMethodDef will return NotAvailable)\n- Managed resources will be reported back as ILResourceLocation.LocalIn (as always)\n- Native resources will not be available (none will be returned)\n- Static data associated with fields will not be available</p>\n\n tryGetMetadataSnapshot <p>A function to call to try to get an object that acts as a snapshot of the metadata section of a .NET binary,\nand from which we can read the metadata. Only used when metadataOnly=true.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-ilreadertrygetmetadatasnapshot.html","title":"ILReaderTryGetMetadataSnapshot","content":"ILReaderTryGetMetadataSnapshot \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-metadataonlyflag.html","title":"MetadataOnlyFlag","content":"MetadataOnlyFlag \n  \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-reducememoryflag.html","title":"ReduceMemoryFlag","content":"ReduceMemoryFlag \n  \n Yes  No "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-statistics.html","title":"Statistics","content":"Statistics \n  \n rawMemoryFileCount  memoryMapFileOpenedCount  memoryMapFileClosedCount  weakByteFileCount  byteFileCount "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-shim-defaultassemblyreader.html","title":"DefaultAssemblyReader","content":"DefaultAssemblyReader \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-ilbinaryreader-shim-iassemblyreader.html","title":"IAssemblyReader","content":"IAssemblyReader \n  \n GetILModuleReader "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-anycallerthreadtoken.html","title":"AnyCallerThreadToken","content":"AnyCallerThreadToken \n <p>Represents a token that indicates execution on a any of several potential user threads calling the F# compiler services.</p>\n\n \n ( .ctor ) "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-cancellable-1.html","title":"Cancellable<'TResult>","content":"Cancellable<'TResult> \n <p>Represents a cancellable computation with explicit representation of a cancelled result.</p>\n<p>A cancellable computation is passed may be cancelled via a CancellationToken, which is propagated implicitly.<br />\nIf cancellation occurs, it is propagated as data rather than by raising an OperationCanceledException.</p>\n\n \n Cancellable "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-cancellablebuilder.html","title":"CancellableBuilder","content":"CancellableBuilder \n  \n ( .ctor )  Bind  Combine  Delay  Return  ReturnFrom  TryFinally  TryWith  Using  Zero "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-compilationthreadtoken.html","title":"CompilationThreadToken","content":"CompilationThreadToken \n <p>Represents a token that indicates execution on the compilation thread, i.e.\n- we have full access to the (partially mutable) TAST and TcImports data structures\n- compiler execution may result in type provider invocations when resolving types and members\n- we can access various caches in the SourceCodeServices</p>\n<p>Like other execution tokens this should be passed via argument passing and not captured/stored beyond\nthe lifetime of stack-based calls. This is not checked, it is a discipline within the compiler code.</p>\n\n \n ( .ctor ) "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-dictionaryextensions.html","title":"DictionaryExtensions","content":"DictionaryExtensions \n  \n ( .ctor )  BagAdd  BagExistsValueForKey "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-eventually-1.html","title":"Eventually<'T>","content":"Eventually<'T> \n <p>Computations that can cooperatively yield by returning a continuation</p>\n<ul>\n<li>\n<p>Any yield of a NotYetDone should typically be \"abandonable\" without adverse consequences. No resource release\nwill be called when the computation is abandoned.</p>\n</li>\n<li>\n<p>Computations suspend via a NotYetDone may use local state (mutables), where these are\ncaptured by the NotYetDone closure. Computations do not need to be restartable.</p>\n</li>\n<li>\n<p>The key thing is that you can take an Eventually value and run it with\nEventually.repeatedlyProgressUntilDoneOrTimeShareOverOrCanceled</p>\n</li>\n<li>Cancellation results in a suspended computation rather than complete abandonment</li>\n</ul>\n\n \n Done  NotYetDone "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-eventuallybuilder.html","title":"EventuallyBuilder","content":"EventuallyBuilder \n  \n ( .ctor )  Bind  Combine  Delay  Return  ReturnFrom  TryFinally  TryWith  Zero "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-executiontoken.html","title":"ExecutionToken","content":"ExecutionToken \n <p>Represents a permission active at this point in execution</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-ipartialequalitycomparer-1.html","title":"IPartialEqualityComparer<'T>","content":"IPartialEqualityComparer<'T> \n <p>Interface that defines methods for comparing objects using partial equality relation</p>\n\n \n InEqualityRelation <p>Can the specified object be tested for equality?</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-inlinedelayinit-1.html","title":"InlineDelayInit<'T>","content":"InlineDelayInit<'T> \n <p>An efficient lazy for inline storage in a class type. Results in fewer thunks.</p>\n\n \n ( .ctor )  Value  store  func "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-layeredmap-2.html","title":"LayeredMap<'Key, 'Value>","content":"LayeredMap<'Key, 'Value> \n  \n Item  IsEmpty  Count "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-layeredmultimap-2.html","title":"LayeredMultiMap<'Key, 'Value>","content":"LayeredMultiMap<'Key, 'Value> \n <p>Immutable map collection, with explicit flattening to a backing dictionary</p>\n\n \n ( .ctor )  Add  AddAndMarkAsCollapsible  MarkAsCollapsible  TryFind  TryGetValue  Values  Item  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-lazywithcontext-2.html","title":"LazyWithContext<'T, 'ctxt>","content":"LazyWithContext<'T, 'ctxt> \n <p>Just like \"Lazy\" but EVERY forcer must provide an instance of \"ctxt\", e.g. to help track errors\non forcing back to at least one sensible user location</p>\n\n \n Force  UnsynchronizedForce  IsForced  IsDelayed  Create  NotLazy  value <p>This field holds the result of a successful computation. It's initial value is Unchecked.defaultof</p>\n\n funcOrException <p>This field holds either the function to run or a LazyWithContextFailure object recording the exception raised\nfrom running the function. It is null if the thunk has been evaluated successfully.</p>\n\n findOriginalException <p>A helper to ensure we rethrow the \"original\" exception</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-lazywithcontextfailure.html","title":"LazyWithContextFailure","content":"LazyWithContextFailure \n  \n ( .ctor )  Exception  Undefined "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-lock-1.html","title":"Lock<'LockTokenType>","content":"Lock<'LockTokenType> \n <p>Encapsulates a lock associated with a particular token-type representing the acquisition of that lock.</p>\n\n \n ( .ctor )  AcquireLock "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-locktoken.html","title":"LockToken","content":"LockToken \n <p>A base type for various types of tokens that must be passed when a lock is taken.\nEach different static lock should declare a new subtype of this type.</p>\n\n \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-memoizationtable-2.html","title":"MemoizationTable<'T, 'U>","content":"MemoizationTable<'T, 'U> \n <p>memoize tables (all entries cached, never collected)</p>\n\n \n ( .ctor )  Apply "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-multimap-2.html","title":"MultiMap<'T, 'U>","content":"MultiMap<'T, 'U> \n  \n Item  IsEmpty  Count "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-namemap-1.html","title":"NameMap<'T>","content":"NameMap<'T> \n  \n Item  IsEmpty  Count "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-namemultimap-1.html","title":"NameMultiMap<'T>","content":"NameMultiMap<'T> \n  \n Item  IsEmpty  Count "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-resultorexception-1.html","title":"ResultOrException<'TResult>","content":"ResultOrException<'TResult> \n  \n Result  Exception "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-undefinedexception.html","title":"UndefinedException","content":"UndefinedException \n  \n "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-uniquestampgenerator-1.html","title":"UniqueStampGenerator<'T>","content":"UniqueStampGenerator<'T> \n <p>Generates unique stamps</p>\n\n \n ( .ctor )  Encode  Table "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-valueorcancelled-1.html","title":"ValueOrCancelled<'TResult>","content":"ValueOrCancelled<'TResult> \n  \n Value  Cancelled "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-shim-defaultfilesystem.html","title":"DefaultFileSystem","content":"DefaultFileSystem \n  \n ( .ctor ) "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-abstractil-internal-library-shim-ifilesystem.html","title":"IFileSystem","content":"IFileSystem \n  \n AssemblyLoad <p>Used to load a dependency for F# Interactive and in an unused corner-case of type provider loading</p>\n\n AssemblyLoadFrom <p>Used to load type providers and located assemblies in F# Interactive</p>\n\n FileDelete <p>A shim over File.Delete</p>\n\n FileStreamCreateShim <p>A shim over FileStream with FileMode.Create, FileAccess.Write, FileShare.Read</p>\n\n FileStreamReadShim <p>A shim over FileStream with FileMode.Open, FileAccess.Read, FileShare.ReadWrite</p>\n\n FileStreamWriteExistingShim <p>A shim over FileStream with FileMode.Open, FileAccess.Write, FileShare.Read</p>\n\n GetFullPathShim <p>Take in a filename with an absolute path, and return the same filename\nbut canonicalized with respect to extra path separators (e.g. C:\\\\foo.txt)\nand '..' portions</p>\n\n GetLastWriteTimeShim <p>Utc time of the last modification</p>\n\n GetTempPathShim <p>A shim over Path.GetTempPath</p>\n\n IsInvalidPathShim <p>A shim over Path.IsInvalidPath</p>\n\n IsPathRootedShim <p>A shim over Path.IsPathRooted</p>\n\n IsStableFileHeuristic <p>Used to determine if a file will not be subject to deletion during the lifetime of a typical client process.</p>\n\n ReadAllBytesShim <p>A shim over File.ReadAllBytes</p>\n\n SafeExists <p>A shim over File.Exists</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-compilerinputstream.html","title":"CompilerInputStream","content":"CompilerInputStream \n <p>Defines a read-only input stream used to feed content to the hosted F# Interactive dynamic compiler.</p>\n\n \n ( .ctor )  Add <p>Feeds content into the stream.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-compileroutputstream.html","title":"CompilerOutputStream","content":"CompilerOutputStream \n <p>Defines a write-only stream used to capture output of the hosted F# Interactive dynamic compiler.</p>\n\n \n ( .ctor )  Read "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-evaluationeventargs.html","title":"EvaluationEventArgs","content":"EvaluationEventArgs \n  \n SymbolUse <p>The FSharpSymbolUse for the symbol defined</p>\n\n Symbol <p>The symbol defined</p>\n\n Name <p>The display name of the symbol defined</p>\n\n ImplementationDeclaration <p>The details of the expression defined</p>\n\n FsiValue <p>The value of the symbol defined, if any</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-fsiboundvalue.html","title":"FsiBoundValue","content":"FsiBoundValue \n <p>Represents an evaluated F# value that is bound to an identifier</p>\n\n \n Value <p>The evaluated F# value</p>\n\n Name <p>The identifier of the value</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-fsicompilationexception.html","title":"FsiCompilationException","content":"FsiCompilationException \n <p>Thrown when there was an error compiling the given code in FSI.</p>\n\n \n ( .ctor )  ErrorInfos "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-fsievaluationsession.html","title":"FsiEvaluationSession","content":"FsiEvaluationSession \n <p>Represents an F# Interactive evaluation session.</p>\n\n \n AddBoundValue <p>Creates a root-level value with the given name and .NET object.\nIf the .NET object contains types from assemblies that are not referenced in the interactive session, it will try to implicitly resolve them by default configuration.\nName must be a valid identifier.</p>\n\n EvalExpression <p>Execute the code as if it had been entered as one or more interactions, with an\nimplicit termination at the end of the input. Stop on first error, discarding the rest\nof the input. Errors are sent to the output writer. Parsing is performed on the current thread, and execution is performed\nsynchronously on the 'main' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n EvalExpressionNonThrowing <p>Execute the code as if it had been entered as one or more interactions, with an\nimplicit termination at the end of the input. Stop on first error, discarding the rest\nof the input. Errors and warnings are collected apart from any exception arising from execution\nwhich is returned via a Choice. Parsing is performed on the current thread, and execution is performed\nsynchronously on the 'main' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n EvalInteraction <p>Execute the code as if it had been entered as one or more interactions, with an\nimplicit termination at the end of the input. Stop on first error, discarding the rest\nof the input. Errors are sent to the output writer, a 'true' return value indicates there\nwere no errors overall. Execution is performed on the 'Run()' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n EvalInteractionNonThrowing <p>Execute the code as if it had been entered as one or more interactions, with an\nimplicit termination at the end of the input. Stop on first error, discarding the rest\nof the input. Errors and warnings are collected apart from any exception arising from execution\nwhich is returned via a Choice. Execution is performed on the 'Run()' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n EvalScript <p>Execute the given script. Stop on first error, discarding the rest\nof the script. Errors are sent to the output writer, a 'true' return value indicates there\nwere no errors overall. Execution is performed on the 'Run()' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n EvalScriptNonThrowing <p>Execute the given script. Stop on first error, discarding the rest\nof the script. Errors and warnings are collected apart from any exception arising from execution\nwhich is returned via a Choice. Execution is performed on the 'Run()' thread.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n FormatValue <p>Format a value to a string using the current PrintDepth, PrintLength etc settings provided by the active fsi configuration object</p>\n\n GetBoundValues <p>Gets the root-level values that are bound to an identifier</p>\n\n GetCompletions <p>A host calls this to get the completions for a long identifier, e.g. in the console</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n Interrupt <p>A host calls this to request an interrupt on the evaluation thread.</p>\n\n ParseAndCheckInteraction <p>Typecheck the given script fragment in the type checking context implied by the current state\nof F# Interactive. The results can be used to access intellisense, perform resolutions,\ncheck brace matching and other information.</p>\n<p>Operations may be run concurrently with other requests to the InteractiveChecker.</p>\n<p>Due to a current limitation, it is not fully thread-safe to run this operation concurrently with evaluation triggered\nby input from 'stdin'.</p>\n\n ReportUnhandledException <p>A host calls this to report an unhandled exception in a standard way, e.g. an exception on the GUI thread gets printed to stderr</p>\n\n Run <p>Load the dummy interaction, load the initial files, and,\nif interacting, start the background thread to read the standard input.</p>\n<p>Performs these steps:\n- Load the dummy interaction, if any\n- Set up exception handling, if any\n- Load the initial files, if any\n- Start the background thread to read the standard input, if any\n- Sit in the GUI event loop indefinitely, if needed</p>\n\n TryFindBoundValue <p>Tries to find a root-level value that is bound to the given identifier</p>\n\n ValueBound <p>Event fires when a root-level value is bound to an identifier, e.g., via <code>let x = ...</code>.</p>\n\n PartialAssemblySignatureUpdated <p>Raised when an interaction is successfully typechecked and executed, resulting in an update to the\ntype checking state.</p>\n<p>This event is triggered after parsing and checking, either via input from 'stdin', or via a call to EvalInteraction.</p>\n\n LCID <p>A host calls this to get the active language ID if provided by fsi-server-lcid</p>\n\n IsGui <p>A host calls this to determine if the --gui parameter is active</p>\n\n InteractiveChecker <p>The single, global interactive checker to use in conjunction with other operations\non the FsiEvaluationSession.</p>\n<p>If you are using an FsiEvaluationSession in this process, you should only use this InteractiveChecker\nfor additional checking operations.</p>\n\n DynamicAssembly <p>Get a handle to the dynamically generated assembly</p>\n\n CurrentPartialAssemblySignature <p>Get a handle to the resolved view of the current signature of the incrementally generated assembly.</p>\n\n Create <p>Create an FsiEvaluationSession, reading from the given text input, writing to the given text output and error writers.</p>\n<summary>Create an FsiEvaluationSession, reading from the given text input, writing to the given text output and error writers</summary>\n<param name=\"fsiConfig\">The dynamic configuration of the evaluation session</param>\n<param name=\"argv\">The command line arguments for the evaluation session</param>\n<param name=\"inReader\">Read input from the given reader</param>\n<param name=\"outWriter\">Write output to the given writer</param>\n<param name=\"collectible\">Optionally make the dynamic assembly for the session collectible</param>\n\n GetDefaultConfiguration <p>Get a configuration that uses a private inbuilt implementation of the 'fsi' object and does not\nimplicitly reference FSharp.Compiler.Interactive.Settings.dll.</p>\n\n GetDefaultConfiguration <p>Get a configuration that uses the 'fsi' object (normally from FSharp.Compiler.Interactive.Settings.dll,\nan object from another DLL with identical characteristics) to provide an implementation of the configuration.\nFSharp.Compiler.Interactive.Settings.dll  is referenced by default.</p>\n\n GetDefaultConfiguration <p>Get a configuration that uses the 'fsi' object (normally from FSharp.Compiler.Interactive.Settings.dll,\nan object from another DLL with identical characteristics) to provide an implementation of the configuration.\nThe flag indicates if FSharp.Compiler.Interactive.Settings.dll  is referenced by default.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-fsievaluationsessionhostconfig.html","title":"FsiEvaluationSessionHostConfig","content":"FsiEvaluationSessionHostConfig \n  \n ( .ctor )  EventLoopInvoke <p>Request that the given operation be run synchronously on the event loop.</p>\n\n EventLoopRun <p>Called by the evaluation session to ask the host to enter a dispatch loop like Application.Run().\nOnly called if --gui option is used (which is the default).\nGets called towards the end of startup and every time a ThreadAbort escaped to the backup driver loop.\nReturn true if a 'restart' is required, which is a bit meaningless.</p>\n\n EventLoopScheduleRestart <p>Schedule a restart for the event loop.</p>\n\n GetOptionalConsoleReadLine <p>Indicate a special console \"readline\" reader for the evaluation session, if any. A \"console\" gets used if --readline is specified (the default on Windows + .NET); and --fsi-server is  not\ngiven (always combine with --readline-), and OptionalConsoleReadLine is given.\nWhen a console is used, special rules apply to \"peekahead\", which allows early typing on the console.\nPeekahead happens if --peekahead- is not specified (the default).\nIn this case, a prompt is printed early, a background thread is created and\nthe OptionalConsoleReadLine is used to read the first line.\nIf a console is not used, then inReader.Peek() is called early instead.\nFurther lines are read using OptionalConsoleReadLine().\nIf not provided, lines are read using inReader.ReadLine().</p>\n\n ReportUserCommandLineArgs <p>The evaluation session calls this to report the preferred view of the command line arguments after\nstripping things like \"/use:file.fsx\", \"-r:Foo.dll\" etc.</p>\n\n StartServer <p>The evaluation session calls this at an appropriate point in the startup phase if the --fsi-server parameter was given</p>\n\n UseFsiAuxLib <p>Implicitly reference FSharp.Compiler.Interactive.Settings.dll</p>\n\n ShowProperties <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n ShowIEnumerable <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n ShowDeclarationValues <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n PrintWidth <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n PrintSize <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n PrintLength <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n PrintDepth <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n OnEvaluation <p>Hook for listening for evaluation bindings</p>\n\n FormatProvider <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n FloatingPointFormat <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n AddedPrinters <p>Called by the evaluation session to ask the host for parameters to format text for output</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-fsivalue.html","title":"FsiValue","content":"FsiValue \n <p>Represents an evaluated F# value</p>\n\n \n ReflectionValue <p>The value, as an object</p>\n\n ReflectionType <p>The type of the value, from the point of view of the .NET type system</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-settings-ieventloop.html","title":"IEventLoop","content":"IEventLoop \n <p>An event loop used by the currently executing F# Interactive session to execute code\nin the context of a GUI or another event-based system.</p>\n\n \n Invoke <p>Request that the given operation be run synchronously on the event loop.</p>\n\n Run <p>Run the event loop.</p>\n\n ScheduleRestart <p>Schedule a restart for the event loop.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-interactive-shell-settings-interactivesettings.html","title":"InteractiveSettings","content":"InteractiveSettings \n <p>Operations supported by the currently executing F# Interactive session.</p>\n\n \n AddPrintTransformer <p>Register a print transformer that controls the output of the interactive session.</p>\n\n AddPrinter <p>Register a printer that controls the output of the interactive session.</p>\n\n CommandLineArgs <p>The command line arguments after ignoring the arguments relevant to the interactive\nenvironment and replacing the first argument with the name of the last script file,\nif any. Thus 'fsi.exe test1.fs test2.fs -- hello goodbye' will give arguments\n'test2.fs', 'hello', 'goodbye'.  This value will normally be different to those\nreturned by System.Environment.GetCommandLineArgs.</p>\n\n EventLoop <p>Gets or sets a the current event loop being used to process interactions.</p>\n\n FloatingPointFormat <p>Get or set the floating point format used in the output of the interactive session.</p>\n\n FormatProvider <p>Get or set the format provider used in the output of the interactive session.</p>\n\n PrintDepth <p>Get or set the print depth of the interactive session.</p>\n\n PrintLength <p>Get or set the total print length of the interactive session.</p>\n\n PrintSize <p>Get or set the total print size of the interactive session.</p>\n\n PrintWidth <p>Get or set the print width of the interactive session.</p>\n\n ShowDeclarationValues <p>When set to 'false', disables the display of declaration values in the output of the interactive session.</p>\n\n ShowIEnumerable <p>When set to 'false', disables the display of sequences in the output of the interactive session.</p>\n\n ShowProperties <p>When set to 'false', disables the display of properties of evaluated objects in the output of the interactive session.</p>\n\n ShowProperties <p>When set to 'false', disables the display of properties of evaluated objects in the output of the interactive session.</p>\n\n ShowIEnumerable <p>When set to 'false', disables the display of sequences in the output of the interactive session.</p>\n\n ShowDeclarationValues <p>When set to 'false', disables the display of declaration values in the output of the interactive session.</p>\n\n PrintWidth <p>Get or set the print width of the interactive session.</p>\n\n PrintSize <p>Get or set the total print size of the interactive session.</p>\n\n PrintLength <p>Get or set the total print length of the interactive session.</p>\n\n PrintDepth <p>Get or set the print depth of the interactive session.</p>\n\n FormatProvider <p>Get or set the format provider used in the output of the interactive session.</p>\n\n FloatingPointFormat <p>Get or set the floating point format used in the output of the interactive session.</p>\n\n EventLoop <p>Gets or sets a the current event loop being used to process interactions.</p>\n\n CommandLineArgs <p>The command line arguments after ignoring the arguments relevant to the interactive\nenvironment and replacing the first argument with the name of the last script file,\nif any. Thus 'fsi.exe test1.fs test2.fs -- hello goodbye' will give arguments\n'test2.fs', 'hello', 'goodbye'.  This value will normally be different to those\nreturned by System.Environment.GetCommandLineArgs.</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-asttraversal-astvisitorbase-1.html","title":"AstVisitorBase<'T>","content":"AstVisitorBase<'T> \n  \n ( .ctor )  VisitBinding <p>VisitBinding allows overriding binding behavior (note: by default it would defaultTraverse expression)</p>\n\n VisitComponentInfo <p>VisitComponentInfo allows overriding behavior when visiting type component infos</p>\n\n VisitExpr <p>VisitExpr(path, traverseSynExpr, defaultTraverse, expr)\ncontrols the behavior when a SynExpr is reached; it can just do\ndefaultTraverse(expr)      if you have no special logic for this node, and want the default processing to pick which sub-node to dive deeper into\nor can inject non-default behavior, which might incorporate:\ntraverseSynExpr(subExpr)   to recurse deeper on some particular sub-expression based on your own logic\npath helps to track AST nodes that were passed during traversal</p>\n\n VisitHashDirective <p>VisitHashDirective allows overriding behavior when visiting hash directives in FSX scripts, like #r, #load and #I.</p>\n\n VisitImplicitInherit <p>VisitImplicitInherit(defaultTraverse,ty,expr,m), defaults to just visiting expr</p>\n\n VisitInheritSynMemberDefn <p>VisitInheritSynMemberDefn allows overriding inherit behavior (by default do nothing)</p>\n\n VisitInterfaceSynMemberDefnType <p>VisitInterfaceSynMemberDefnType allows overriding behavior for visiting interface member in types (by default - do nothing)</p>\n\n VisitLetOrUse <p>VisitLetOrUse allows overriding behavior when visiting module or local let or use bindings</p>\n\n VisitMatchClause <p>VisitMatchClause allows overriding clause behavior (note: by default it would defaultTraverse expression)</p>\n\n VisitModuleDecl <p>VisitModuleDecl allows overriding module declaration behavior</p>\n\n VisitModuleOrNamespace <p>VisitModuleOrNamespace allows overriding behavior when visiting module or namespaces</p>\n\n VisitPat <p>VisitPat allows overriding behavior when visiting patterns</p>\n\n VisitRecordField <p>VisitRecordField allows overriding behavior when visiting l.h.s. of constructed record instances</p>\n\n VisitSimplePats <p>VisitType allows overriding behavior when visiting simple pats</p>\n\n VisitType <p>VisitType allows overriding behavior when visiting type hints (x: ..., etc.)</p>\n\n VisitTypeAbbrev <p>VisitTypeAbbrev(ty,m), defaults to ignoring this leaf of the AST</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-asttraversal-traversepath.html","title":"TraversePath","content":"TraversePath \n  \n Tail  Length  Item  IsEmpty  Head  Empty "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-asttraversal-traversestep.html","title":"TraverseStep","content":"TraverseStep \n <p>used to track route during traversal AST</p>\n\n \n Expr  Module  ModuleOrNamespace  TypeDefn  MemberDefn  MatchClause  Binding "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lexer-fsharplexer.html","title":"FSharpLexer","content":"FSharpLexer \n  \n Lex "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lexer-fsharplexerflags.html","title":"FSharpLexerFlags","content":"FSharpLexerFlags \n  \n Default  LightSyntaxOn  Compiling  CompilingFSharpCore  SkipTrivia  UseLexFilter "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lexer-fsharpsyntaxtoken.html","title":"FSharpSyntaxToken","content":"FSharpSyntaxToken \n  \n Range  Kind  IsStringLiteral  IsNumericLiteral  IsKeyword  IsIdentifier  IsCommentTrivia  tok  tokRange "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-lexer-fsharpsyntaxtokenkind.html","title":"FSharpSyntaxTokenKind","content":"FSharpSyntaxTokenKind \n  \n None  HashIf  HashElse  HashEndIf  CommentTrivia  WhitespaceTrivia  HashLine  HashLight  InactiveCode  LineCommentTrivia  StringText  Fixed  OffsideInterfaceMember  OffsideBlockEnd  OffsideRightBlockEnd  OffsideDeclEnd  OffsideEnd  OffsideBlockSep  OffsideBlockBegin  OffsideReset  OffsideFun  OffsideFunction  OffsideWith  OffsideElse  OffsideThen  OffsideDoBang  OffsideDo  OffsideBinder  OffsideLet  HighPrecedenceTypeApp  HighPrecedenceParenthesisApp  HighPrecedenceBracketApp  Extern  Void  Public  Private  Internal  Global  Static  Member  Class  Abstract  Override  Default  Constructor  Inherit  GreaterRightBracket  Struct  Sig  Bar  RightBracket  RightBrace  Minus  Dollar  BarRightBracket  BarRightBrace  Underscore  Semicolon  SemicolonSemicolon  LeftArrow  Equals  LeftBracket  LeftBracketBar  LeftBraceBar  LeftBracketLess  LeftBrace  QuestionMark  QuestionMarkQuestionMark  Dot  Colon  ColonColon  ColonGreater  ColonQuestionMark  ColonQuestionMarkGreater  ColonEquals  When  While  With  Hash  Ampersand  AmpersandAmpersand  Quote  LeftParenthesis  RightParenthesis  Star  Comma  RightArrow  GreaterBarRightBracket  LeftParenthesisStarRightParenthesis  Open  Or  Rec  Then  To  True  Try  Type  Val  Inline  Interface  Instance  Const  Lazy  OffsideLazy  Match  MatchBang  Mutable  New  Of  Exception  False  For  Fun  Function  If  In  JoinIn  Finally  DoBang  And  As  Assert  OffsideAssert  Begin  Do  Done  DownTo  Else  Elif  End  DotDot  DotDotHat  BarBar  Upcast  Downcast  Null  Reserved  Module  Namespace  Delegate  Constraint  Base  LeftQuote  RightQuote  RightQuoteDot  PercentOperator  Binder  Less  Greater  Let  Yield  YieldBang  BigNumber  Decimal  Char  Ieee64  Ieee32  NativeInt  UNativeInt  UInt64  UInt32  UInt16  UInt8  Int64  Int32  Int32DotDot  Int16  Int8  FunkyOperatorName  AdjacentPrefixOperator  PlusMinusOperator  InfixAmpersandOperator  InfixStarDivideModuloOperator  PrefixOperator  InfixBarOperator  InfixAtHatOperator  InfixCompareOperator  InfixStarStarOperator  Identifier  KeywordString  String  ByteArray  Asr  InfixAsr  InfixLand  InfixLor  InfixLsl  InfixLsr  InfixLxor  InfixMod "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-navigateto-container.html","title":"Container","content":"Container \n  \n Type  Name "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-navigateto-containertype.html","title":"ContainerType","content":"ContainerType \n  \n File  Namespace  Module  Type  Exception "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-navigateto-navigableitem.html","title":"NavigableItem","content":"NavigableItem \n  \n Name  Range  IsSignature  Kind  Container "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-navigateto-navigableitemkind.html","title":"NavigableItemKind","content":"NavigableItemKind \n  \n Module  ModuleAbbreviation  Exception  Type  ModuleValue  Field  Property  Constructor  Member  EnumCase  UnionCase "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-simplifynames-simplifiablerange.html","title":"SimplifiableRange","content":"SimplifiableRange \n <p>Data for use in finding unnecessarily-qualified names and generating diagnostics to simplify them</p>\n\n \n Range <p>The range of a name that can be simplified</p>\n\n RelativeName <p>The relative name that can be applied to a simplifiable name</p>\n\n"},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-structure-collapse.html","title":"Collapse","content":"Collapse \n <p>Collapse indicates the way a range/snapshot should be collapsed. <code>Same</code> is for a scope inside\nsome kind of scope delimiter, e.g. <code>[| ... |]</code>, <code>[ ... ]</code>, <code>{ ... }</code>, etc.  <code>Below</code> is for expressions\nfollowing a binding or the right hand side of a pattern, e.g. <code>let x = ...</code></p>\n\n \n Below  Same "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-structure-scope.html","title":"Scope","content":"Scope \n <p>Tag to identify the construct that can be stored alongside its associated ranges</p>\n\n \n Open  Namespace  Module  Type  Member  LetOrUse  Val  CompExpr  IfThenElse  ThenInIfThenElse  ElseInIfThenElse  TryWith  TryInTryWith  WithInTryWith  TryFinally  TryInTryFinally  FinallyInTryFinally  ArrayOrList  ObjExpr  For  While  Match  MatchBang  MatchLambda  MatchClause  Lambda  CompExprInternal  Quote  Record  SpecialFunc  Do  New  Attribute  Interface  HashDirective  LetOrUseBang  TypeExtension  YieldOrReturn  YieldOrReturnBang  Tuple  UnionCase  EnumCase  RecordField  RecordDefn  UnionDefn  Comment  XmlDocComment "},{"uri":"//fsharp.github.io/FSharp.Compiler.Service/reference/fsharp-compiler-sourcecodeservices-structure-scoperange.html","title":"ScopeRange","content":"ScopeRange \n <p>Stores the range for a construct, the sub-range that should be collapsed for outlinging,\na tag for the construct type, and a tag for the collapse style</p>\n\n \n Scope  Collapse  Range <p>HintSpan in BlockSpan</p>\n\n CollapseRange <p>TextSpan in BlockSpan</p>\n\n"}]